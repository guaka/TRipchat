<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="script-src 'self' 'unsafe-inline' https://unpkg.com https://cdn.jsdelivr.net https://cdn.skypack.dev; connect-src 'self' wss: https:;">
    <title>TRipchat - nostr travel chat</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="alternate icon" href="favicon.ico">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script type="module">
        import * as nostrTools from 'https://cdn.skypack.dev/nostr-tools@1.7.0';
        window.nostrTools = nostrTools;
    </script>
    <style>
        * {
            box-sizing: border-box;
        }

        /* Global button styling for consistency */
        button {
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        /* Touch-friendly improvements */
        @media (hover: none) and (pointer: coarse) {
            button:hover {
                transform: none;
            }
            
            .note-item:hover {
                background: #ffffff;
                border-left: none;
                padding-left: 12px;
            }
            
            
            .compose-form:hover {
                transform: none;
            }
        }
        
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700;800&family=Fira+Code:wght@300;400;500;600;700&family=Inter:wght@300;400;500;600;700&display=swap');
        
        :root {
            /* Light theme colors */
            --bg-primary: #f8f9fa;
            --bg-secondary: #ffffff;
            --bg-tertiary: #f1f3f4;
            --text-primary: #2c3e50;
            --text-secondary: #6c757d;
            --text-muted: #888;
            --border-color: #e9ecef;
            --accent-color: #27ae60;
            --accent-hover: #229954;
            --shadow: rgba(0, 0, 0, 0.1);
            --shadow-hover: rgba(0, 0, 0, 0.15);
            --map-bg: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
        }

        [data-theme="dark"] {
            /* Dark theme colors */
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --text-primary: #f0f6fc;
            --text-secondary: #8b949e;
            --text-muted: #6e7681;
            --border-color: #30363d;
            --accent-color: #58a6ff;
            --accent-hover: #4a9eff;
            --shadow: rgba(0, 0, 0, 0.3);
            --shadow-hover: rgba(0, 0, 0, 0.4);
            --map-bg: linear-gradient(135deg, #0d1117 0%, #161b22 100%);
        }
        
        body {
            font-family: 'JetBrains Mono', 'Fira Code', 'Space Grotesk', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;
            margin: 0;
            padding: 0;
            background: var(--bg-primary);
            min-height: 100vh;
            overflow: hidden;
            font-weight: 400;
            letter-spacing: 0.02em;
            color: var(--text-primary);
            line-height: 1.5;
            font-size: 14px;
            transition: background-color 0.3s ease, color 0.3s ease;
            font-feature-settings: 'liga' 1, 'calt' 1;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        
        /* Dark mode toggle button */
        .dark-mode-toggle {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 50%;
            padding: 10px;
            cursor: pointer;
            font-size: 1.3rem;
            transition: all 0.3s ease;
            margin-left: 8px;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px var(--shadow);
        }

        .dark-mode-toggle:hover {
            background: var(--accent-color);
            color: white;
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 6px 20px var(--shadow-hover);
        }

        .main-container {
            display: flex;
            height: 100vh;
            box-shadow: 0 0 20px var(--shadow);
            background: var(--bg-secondary);
            transition: background-color 0.3s ease;
        }
        
        .map-container {
            flex: 1;
            background: var(--map-bg);
            position: relative;
            border-right: 1px solid var(--border-color);
            box-shadow: 4px 0 20px var(--shadow);
            backdrop-filter: blur(10px);
            transition: background 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
        }
        
        #map {
            width: 100%;
            height: 100%;
            background: var(--map-bg);
            transition: background 0.3s ease;
        }
        
        .note-container {
            flex: 1;
            overflow-y: auto;
            max-height: 100vh;
            background: #f8f9fa;
            -webkit-overflow-scrolling: touch;
            scroll-behavior: smooth;
        }
        
        .container {
            max-width: none;
            margin: 0;
            height: 100%;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        
        h1 {
            color: var(--accent-color);
            font-size: 1.8rem;
            font-weight: 800;
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            margin: 0;
            letter-spacing: 0.05em;
            text-transform: none;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            font-feature-settings: 'liga' 1, 'calt' 1;
            transition: color 0.3s ease;
        }
        
        .note-item {
            background: var(--bg-secondary);
            border: none;
            border-radius: 0;
            padding: 12px 16px;
            margin-bottom: 0;
            transition: all 0.3s ease;
            position: relative;
            overflow: visible;
            font-family: 'Inter', sans-serif;
            box-shadow: none;
            backdrop-filter: none;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: flex-start;
            gap: 12px;
        }

        @keyframes floatIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .note-item:hover {
            background: var(--bg-tertiary);
        }
        
        
        .note-header {
            margin-bottom: 2px;
            flex-shrink: 0;
        }
        
        .note-type {
            font-weight: 600;
            font-family: 'Inter', sans-serif;
            color: #27ae60;
            font-size: 0.75rem;
            background: rgba(39, 174, 96, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            letter-spacing: 0.5px;
            text-transform: uppercase;
        }
        
        .note-time {
            color: var(--text-muted);
            font-size: 0.5rem;
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            font-weight: 400;
            margin: 0;
            margin-left: auto;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: right;
            line-height: 1.2;
        }

        .note-time:hover {
            color: var(--accent-color);
            text-decoration: underline;
        }
        
        .note-time::after {
            content: " üîç";
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.4rem;
        }
        
        .note-time:hover::after {
            opacity: 1;
        }
        
        
        .note-content {
            line-height: 1.6;
            color: var(--text-primary);
            font-size: 0.85rem;
            word-wrap: break-word;
            white-space: pre-wrap;
            font-weight: 400;
            margin: 0;
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            flex: 1;
            transition: color 0.3s ease;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            font-feature-settings: 'liga' 1, 'calt' 1;
            letter-spacing: 0.01em;
        }

        .hashtag-link {
            color: var(--accent-color);
            text-decoration: none;
            font-weight: 500;
            padding: 2px 4px;
            border-radius: 4px;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .hashtag-link:hover {
            background-color: var(--accent-color);
            color: white;
            text-decoration: none;
        }

        .hashtag-link[data-circle] {
            background-color: rgba(88, 166, 255, 0.1);
            border: 1px solid var(--accent-color);
        }

        .hashtag-link[data-circle]:hover {
            background-color: var(--accent-color);
            color: white;
        }

        #noteContainer {
            flex: 1;
            min-height: 0;
            overflow-y: auto;
            padding: 0;
            background: var(--bg-secondary);
            border: none;
            border-radius: 0;
            scroll-behavior: smooth;
            transition: all 0.3s ease;
        }
        
        .loading {
            text-align: center;
            color: #6c757d;
            font-style: italic;
            font-size: 1rem;
            padding: 40px 20px;
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            border-radius: 16px;
            border: 1px solid #e9ecef;
            font-family: 'Inter', sans-serif;
            font-weight: 500;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            position: relative;
            overflow: hidden;
        }

        .loading::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(39, 174, 96, 0.1), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% {
                left: -100%;
            }
            100% {
                left: 100%;
            }
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--accent-color);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent-hover);
        }
        
        .error {
            color: #DC2626;
            background: rgba(220, 38, 38, 0.1);
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
            border: 1px solid rgba(220, 38, 38, 0.2);
            text-align: center;
        }
        


        .relay-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 4px 0;
            padding: 4px 0;
            font-size: 0.85rem;
        }

        .relay-status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .relay-connected {
            background: #10B981;
            box-shadow: 0 0 6px rgba(16, 185, 129, 0.5);
        }

        .relay-connecting {
            background: #F59E0B;
            animation: pulse 2s infinite;
        }

        .relay-disconnected {
            background: #EF4444;
        }

        .relay-name {
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            color: #2c3e50;
        }

        
        .map-marker {
            background: linear-gradient(135deg, #8B5CF6, #F59E0B);
            color: white;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
            border: 3px solid white;
            box-shadow: 0 6px 20px rgba(139, 92, 246, 0.4);
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .map-marker:hover {
            transform: scale(1.03);
            box-shadow: 0 4px 15px rgba(139, 92, 246, 0.4);
        }
        
        .map-popup {
            max-width: 250px;
            font-family: 'Inter', sans-serif;
        }
        
        .map-popup .note-title {
            font-weight: 600;
            color: #8B5CF6;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }
        
        .popup-content {
            font-size: 0.9rem;
            margin: 5px 0;
        }
        
        .popup-time {
            color: #666;
            font-size: 0.8rem;
        }
        
        .popup-location {
            color: #8B5CF6;
            font-weight: 500;
            margin-top: 6px;
            font-size: 0.8rem;
            border-top: 1px solid rgba(139, 92, 246, 0.2);
            padding-top: 4px;
        }

        .live-indicator {
            position: fixed;
            top: 80px;
            right: 20px;
            background: linear-gradient(135deg, #10B981, #059669);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
            animation: pulse 2s infinite;
        }

        .app-footer {
            position: fixed;
            bottom: 0;
            right: 0;
            padding: 8px 12px;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
            z-index: 1000;
        }

        .app-footer a {
            font-size: 0.5rem;
            color: #10b981; /* Emerald-500 - hacker green */
            font-family: monospace;
            text-decoration: none;
            opacity: 0.9;
            transition: all 0.2s ease;
            text-shadow: 0 0 8px rgba(16, 185, 129, 0.3);
        }

        .app-footer a:hover {
            opacity: 1;
            text-decoration: underline;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .note-new {
            animation: slideInFromTop 0.5s ease-out;
            border-left: 4px solid #10B981;
        }

        @keyframes slideInFromTop {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .tripchat-indicator {
            background: linear-gradient(135deg, #8B5CF6, #F59E0B);
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-left: 8px;
        }

        .geohash-tag {
            background: linear-gradient(135deg, #8B5CF6, #F59E0B);
            color: white;
            padding: 4px 10px;
            border-radius: 16px;
            font-size: 0.75rem;
            font-weight: 600;
            font-family: 'Courier New', monospace;
            margin: 0 4px;
            letter-spacing: 0.5px;
            text-decoration: none;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(139, 92, 246, 0.3);
            display: inline-block;
            cursor: pointer;
        }

        .geohash-tag:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(139, 92, 246, 0.5);
            background: linear-gradient(135deg, #7C3AED, #D97706);
        }

        .tripchat-packet {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 8px;
            margin: 8px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            color: #6c757d;
            word-break: break-all;
        }

        .encrypted-content {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 8px;
            margin: 8px 0;
            font-style: italic;
            color: #856404;
        }


        .filter-row {
            display: flex;
            align-items: center;
            gap: 16px;
            flex-wrap: nowrap;
        }

        .compose-form .filter-row {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--border-color);
        }


        .filter-input-group {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
            min-width: 200px;
            max-width: 400px;
        }

        .geohash-input {
            width: 120px;
            max-width: 120px;
            min-width: 120px;
            padding: 10px 14px;
            border: 1px solid var(--border-color);
            border-radius: 0;
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 0.85rem;
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            transition: all 0.3s ease;
        }

        .search-input {
            flex: 1;
            min-width: 180px;
            padding: 10px 14px;
            border: 1px solid var(--border-color);
            border-radius: 0;
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 0.85rem;
            transition: all 0.3s ease;
        }

        .geohash-input:focus,
        .search-input:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 3px rgba(88, 166, 255, 0.1);
            background: var(--bg-secondary);
        }



        .filter-options {
            margin: 12px 0;
        }




        /* Nostr Note Details Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            border: none;
            border-radius: 20px;
            padding: 32px;
            max-width: 600px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.15);
            position: relative;
            font-family: 'Inter', sans-serif;
            backdrop-filter: blur(20px);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 2px solid #e9ecef;
        }

        .modal-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: #2c3e50;
            margin: 0;
            font-family: 'Inter', sans-serif;
        }

        .modal-close {
            background: #e9ecef;
            border: none;
            font-size: 1.5rem;
            color: #6c757d;
            cursor: pointer;
            padding: 8px 12px;
            border-radius: 8px;
            transition: all 0.3s ease;
            font-family: 'Inter', sans-serif;
            font-weight: 600;
        }

        .modal-close:hover {
            background: #dc3545;
            color: #ffffff;
            transform: scale(1.1);
        }

        .modal-section {
            margin-bottom: 20px;
        }

        .modal-section-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: #27ae60;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 5px rgba(255, 136, 0, 0.5);
        }

        .modal-field {
            margin-bottom: 12px;
        }

        .modal-field-label {
            font-size: 0.8rem;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-family: 'Courier New', monospace;
        }

        .modal-field-value {
            font-family: 'Inter', sans-serif;
            font-size: 0.9rem;
            background: #f8f9fa;
            padding: 12px 16px;
            border-radius: 8px;
            border: 1px solid #e9ecef;
            word-break: break-all;
            color: #2c3e50;
        }

        .modal-content-text {
            font-size: 0.95rem;
            line-height: 1.6;
            color: #2c3e50;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-family: 'Courier New', monospace;
        }

        .modal-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .modal-tag {
            background: #e9ecef;
            color: #2c3e50;
            padding: 6px 12px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
            font-family: 'Inter', sans-serif;
            border: 1px solid #dee2e6;
        }

        .header-top-row {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 0;
            padding: 12px 16px 8px 16px;
            border-bottom: 2px solid var(--border-color);
            position: sticky;
            top: 0;
            z-index: 100;
            background: var(--bg-secondary);
            box-shadow: 0 2px 4px var(--shadow);
            transition: all 0.3s ease;
        }

        .header-title-group {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 8px;
        }


        .tripchat-links {
            display: flex;
            gap: 16px;
        }



        .settings-btn, .relay-manager-btn {
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 20px;
            padding: 8px 12px;
            cursor: pointer;
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            font-size: 0.6rem;
            font-weight: 600;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            box-shadow: 0 4px 15px var(--shadow);
            position: relative;
            overflow: hidden;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            white-space: nowrap;
        }

        .settings-btn::before, .relay-manager-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .settings-btn:hover::before, .relay-manager-btn:hover::before {
            left: 100%;
        }

        .settings-btn:hover, .relay-manager-btn:hover {
            background: var(--accent-hover);
            transform: translateY(-3px);
            box-shadow: 0 8px 25px var(--shadow-hover);
        }

        .compose-btn-bottom {
            background: var(--accent-color);
            color: white;
            border: none;
            padding: 14px 24px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            font-family: 'Inter', sans-serif;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(39, 174, 96, 0.3);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            width: 100%;
            max-width: 200px;
            margin: 0 auto;
            display: block;
            position: relative;
            overflow: hidden;
        }

        .compose-btn-bottom::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .compose-btn-bottom:hover::before {
            left: 100%;
        }

        .compose-btn-bottom:hover {
            background: var(--accent-hover);
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(39, 174, 96, 0.4);
        }

        /* Compact Inline Compose Form Styles */
        .compose-form {
            background: var(--bg-secondary);
            border-radius: 0;
            padding: 16px;
            margin-bottom: 0;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 15px var(--shadow);
            position: relative;
            transition: all 0.3s ease;
        }


        .compose-form:hover {
            box-shadow: 0 8px 30px var(--shadow-hover);
        }

        .compose-form-body {
            padding: 0;
        }

        .compose-form .compose-section {
            margin-bottom: 12px;
        }

        .compose-form .compose-section:last-child {
            margin-bottom: 0;
        }

        .compose-form label {
            display: block;
            margin-bottom: 3px;
            font-weight: 600;
            color: #2c3e50;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        .compose-form textarea,
        .compose-form input,
        .compose-form select {
            width: 100%;
            padding: 6px 10px;
            border: 1px solid var(--border-color);
            border-radius: 0;
            font-size: 0.85rem;
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            transition: all 0.3s ease;
            background: var(--bg-secondary);
            color: var(--text-primary);
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }

        .compose-form textarea {
            resize: vertical;
            min-height: 50px;
            max-height: 120px;
        }

        .compose-form textarea:focus,
        .compose-form input:focus,
        .compose-form select:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 2px rgba(88, 166, 255, 0.1);
        }

        .compose-form .location-input-group {
            display: flex;
            gap: 6px;
        }

        .compose-form .location-input-group input {
            flex: 1;
        }

        .compose-form .location-btn {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            border: none;
            padding: 6px 8px;
            border-radius: 0;
            cursor: pointer;
            font-size: 0.7rem;
            font-weight: 600;
            white-space: nowrap;
            transition: all 0.2s ease;
        }

        .compose-form .location-btn:hover {
            background: linear-gradient(135deg, #2980b9 0%, #21618c 100%);
            transform: translateY(-1px);
        }


        .compose-form .compose-actions {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #dee2e6;
        }

        .compose-form .post-btn {
            background: var(--accent-color);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 0;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(39, 174, 96, 0.2);
        }

        .compose-form .post-btn:hover {
            background: var(--accent-hover);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(39, 174, 96, 0.3);
        }

        /* Note Persistence Styles */
        .note-item.ephemeral {
            border-left: 3px solid #ff6b6b; /* Red for ephemeral */
        }

        .note-item.persistent {
            border-left: 3px solid #4ecdc4; /* Teal for persistent */
        }

        .note-item.expiring {
            border-left: 3px solid #ffa726; /* Orange for expiring soon */
        }

        .note-expiration {
            font-size: 0.7rem;
            color: #6c757d;
            font-style: italic;
            margin-top: 4px;
        }

        .persistence-select {
            font-size: 0.8rem;
            padding: 6px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
            min-width: 150px;
        }

        .compose-section {
            margin-bottom: 12px;
        }

        .compose-section label {
            display: block;
            font-size: 0.8rem;
            font-weight: 600;
            margin-bottom: 4px;
            color: var(--text-primary);
            transition: color 0.3s ease;
        }

        /* Settings Modal Styles */
        .settings-modal {
            max-width: 700px;
            width: 90%;
        }

        .settings-modal-message {
            display: none;
            padding: 12px 16px;
            margin-bottom: 16px;
            border-radius: 10px;
            background: rgba(39, 174, 96, 0.12);
            border: 1px solid rgba(39, 174, 96, 0.35);
            color: #1f7a52;
            font-weight: 600;
            font-size: 0.9rem;
        }

        .key-setup-prompt {
            display: none;
            flex-direction: column;
            gap: 12px;
            padding: 16px;
            margin-bottom: 24px;
            border-radius: 12px;
            background: rgba(231, 244, 255, 0.6);
            border: 1px solid rgba(25, 118, 210, 0.25);
        }

        .key-setup-prompt.compact {
            background: transparent;
            border: none;
            padding: 8px 0 0 0;
            margin-bottom: 16px;
        }

        .key-setup-prompt.compact .key-setup-actions {
            justify-content: flex-start;
        }

        .key-setup-question {
            font-weight: 600;
            color: #1976d2;
            font-size: 0.95rem;
        }

        .key-setup-actions {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .key-btn.key-choice {
            flex: 1 1 200px;
            justify-content: center;
            background: linear-gradient(135deg, #1976d2, #42a5f5);
            color: #ffffff;
        }

        .key-btn.key-choice:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 18px rgba(25, 118, 210, 0.35);
        }

        .key-hint {
            display: none;
            margin-top: 8px;
            font-size: 0.8rem;
            color: #1f5f3d;
            background: rgba(39, 174, 96, 0.12);
            border: 1px solid rgba(39, 174, 96, 0.25);
            padding: 10px 12px;
            border-radius: 10px;
            text-align: left;
        }

        .key-hint a {
            color: #1976d2;
            text-decoration: underline;
        }

        .settings-section {
            margin-bottom: 24px;
        }

        .verification-info {
            background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
            border: 1px solid #e9ecef;
            border-radius: 12px;
            padding: 16px;
        }

        .nip05-identifier {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 12px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            color: #2c3e50;
            word-break: break-all;
            margin-bottom: 12px;
        }

        .nip05-url {
            background: #f0f8ff;
            border: 1px solid #bbdefb;
            border-radius: 8px;
            padding: 12px;
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            color: #1976d2;
            word-break: break-all;
            margin-bottom: 12px;
        }

        .verification-actions {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
        }

        .verification-status {
            font-size: 0.8rem;
            font-style: italic;
            padding: 4px 0;
        }

        .filter-options {
            white-space: nowrap;
            flex: 0 0 auto;
        }

        .filter-toggle-label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 0.8rem;
            color: #6c757d;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .filter-toggle-label input[type="checkbox"] {
            display: none;
        }

        .filter-toggle-slider {
            position: relative;
            width: 40px;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            transition: all 0.2s ease;
            border: 1px solid #dee2e6;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .filter-toggle-slider::before {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 14px;
            height: 14px;
            background: #ffffff;
            border-radius: 50%;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .filter-toggle-label input[type="checkbox"]:checked + .filter-toggle-slider {
            background: var(--accent-color);
            border-color: var(--accent-color);
        }

        .filter-toggle-label input[type="checkbox"]:checked + .filter-toggle-slider::before {
            transform: translateX(20px);
        }

        .filter-toggle-text {
            font-size: 0.8rem;
            font-weight: 700;
            color: #ffffff;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
            z-index: 2;
            position: relative;
        }


        .settings-section label {
            display: block;
            color: #2c3e50;
            font-weight: 600;
            margin-bottom: 8px;
            font-family: 'Inter', sans-serif;
        }

        .profile-btn {
            background: #3498db;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 20px;
            cursor: pointer;
            font-family: 'Inter', sans-serif;
            font-size: 0.9rem;
            font-weight: 600;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 8px rgba(52, 152, 219, 0.3);
            margin-top: 12px;
        }

        .profile-btn:hover {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.4);
        }

        .settings-actions {
            display: flex;
            justify-content: flex-end;
            margin-top: 24px;
            padding-top: 20px;
            border-top: 2px solid #e9ecef;
        }

        .compose-section {
            margin-bottom: 20px;
        }

        .compose-section label {
            display: block;
            color: var(--text-primary);
            font-weight: 600;
            margin-bottom: 8px;
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            transition: color 0.3s ease;
        }

        .compose-section textarea,
        .compose-section input {
            width: 100%;
            padding: 16px 20px;
            border: 1px solid var(--border-color);
            border-radius: 12px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            font-size: 0.9rem;
            box-shadow: var(--shadow);
            transition: all 0.3s ease;
        }

        .compose-section textarea:focus,
        .compose-section input:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 4px rgba(88, 166, 255, 0.15), 0 8px 20px var(--shadow);
            transform: translateY(-1px);
        }

        .location-input-group,
        .key-input-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .location-input-group input,
        .key-input-group input {
            flex: 1;
        }

        .key-input-group input.readonly {
            background: rgba(240, 244, 248, 0.85);
            border: 1px dashed rgba(39, 174, 96, 0.4);
            cursor: not-allowed;
        }

        .location-btn, .key-btn {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            border: none;
            border-radius: 12px;
            padding: 12px 18px;
            cursor: pointer;
            font-family: 'Inter', sans-serif;
            font-size: 0.8rem;
            white-space: nowrap;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
        }

        .location-btn:hover, .key-btn:hover {
            background: linear-gradient(135deg, #2980b9 0%, #1f618d 100%);
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(52, 152, 219, 0.4);
        }

        .posting-relays-display {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 8px;
        }

        .posting-relay-item {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--accent-color);
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 500;
            color: var(--accent-color);
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
        }

        .posting-relay-item .relay-status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--accent-color);
        }

        .posting-relay-item .relay-name {
            font-weight: 600;
        }

        .posting-relay-item .relay-connected {
            background: var(--accent-color);
        }

        .posting-relay-item .relay-disconnected {
            background: #dc3545;
        }

        .compose-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }

        .post-btn, .cancel-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Inter', sans-serif;
            font-weight: 600;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .post-btn {
            background: var(--accent-color);
            color: white;
            box-shadow: 0 4px 15px rgba(39, 174, 96, 0.3);
        }

        .post-btn:hover {
            background: var(--accent-hover);
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(39, 174, 96, 0.4);
        }

        .cancel-btn {
            background: linear-gradient(135deg, #6c757d 0%, #5a6268 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(108, 117, 125, 0.3);
        }

        .cancel-btn:hover {
            background: linear-gradient(135deg, #5a6268 0%, #495057 100%);
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(108, 117, 125, 0.4);
        }

        /* Relay Manager Styles */
        .relay-modal {
            max-width: 700px;
            width: 90%;
        }

        .relay-section {
            margin-bottom: 25px;
        }

        .relay-section h4 {
            color: var(--accent-color);
            margin-bottom: 15px;
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
        }

        .add-relay-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .add-relay-group input {
            flex: 1;
            padding: 12px 16px;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            background: #ffffff;
            color: #2c3e50;
            font-family: 'Inter', sans-serif;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .add-btn {
            background: var(--accent-color);
            color: #ffffff;
            border: none;
            border-radius: 8px;
            padding: 12px 20px;
            cursor: pointer;
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            font-weight: 600;
            white-space: nowrap;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px var(--shadow);
        }

        .add-btn:hover {
            background: var(--accent-hover);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px var(--shadow-hover);
        }

        .relay-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .relay-item-manager {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px;
            margin-bottom: 12px;
            background: #ffffff;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            font-family: 'Inter', sans-serif;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        .relay-info {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1;
        }

        .relay-status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .relay-url {
            color: #2c3e50;
            font-size: 0.9rem;
        }

        .relay-actions {
            display: flex;
            gap: 5px;
        }

        .relay-delete {
            padding: 4px 8px;
            border: 1px solid;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8rem;
            font-family: 'Courier New', monospace;
            color: #ff6666;
            border-color: #ff6666;
            background: rgba(255, 102, 102, 0.1);
        }

        .relay-delete:hover {
            background: rgba(255, 102, 102, 0.2);
        }

        .post-toggle-label {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 30px;
            cursor: pointer;
        }

        .post-toggle-label input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .post-toggle-slider {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #e9ecef;
            border-radius: 30px;
            transition: all 0.3s ease;
            border: 2px solid #dee2e6;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .post-toggle-slider:before {
            content: '';
            position: absolute;
            height: 22px;
            width: 22px;
            left: 2px;
            bottom: 2px;
            background-color: #ffffff;
            border-radius: 50%;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .post-toggle-text {
            font-size: 0.7rem;
            font-weight: 600;
            color: #6c757d;
            font-family: 'Inter', sans-serif;
            z-index: 1;
            transition: all 0.3s ease;
        }

        .post-toggle-label input:checked + .post-toggle-slider {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
        }

        .post-toggle-label input:checked + .post-toggle-slider:before {
            transform: translateX(30px);
        }

        .post-toggle-label input:checked + .post-toggle-slider .post-toggle-text {
            color: #ffffff;
        }


        
        @media (max-width: 768px) {
            .main-container {
                flex-direction: column;
                height: 100vh;
                overflow: hidden;
            }

            
            .map-container {
                height: 5vh;
                min-height: 60px;
                order: 2;
                border-right: none;
                border-bottom: 1px solid var(--border-color);
                background: var(--map-bg);
            }
            
            .note-container {
                height: 95vh;
                order: 1;
                padding: 0;
                background: #f8f9fa;
                display: flex;
                flex-direction: column;
            }

            .header-top-row {
                padding: 4px 8px;
                margin-bottom: 0;
                border-bottom: 1px solid #e9ecef;
                flex-shrink: 0;
                align-items: center;
            }

            .header-title-group {
                flex: 1;
                min-width: 0;
                gap: 0;
            }

            .tripchat-links {
                flex-shrink: 0;
            }

            h1 {
                font-size: 0.9rem;
                margin: 0;
                line-height: 1.1;
            }

            .header-title-group p {
                font-size: 0.6rem !important;
                color: #6c757d !important;
                margin: 1px 0 2px 0 !important;
                line-height: 1.1 !important;
            }

            .tripchat-links {
                display: flex;
                gap: 4px;
                margin-top: 2px;
            }

            .settings-btn, .relay-manager-btn {
                padding: 3px 6px;
                font-size: 0.55rem;
                border-radius: 3px;
                min-width: 40px;
            }

            #noteContainer {
                flex: 1;
                padding: 8px;
                background: transparent;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }

            
            .note-item {
                padding: 12px;
                margin-bottom: 8px;
                border-radius: 8px;
                box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
                background: white;
            }
            
            .note-header {
                margin-bottom: 4px;
            }

            .note-content {
                font-size: 0.9rem;
                line-height: 1.5;
            }

            .note-username {
                font-size: 0.8rem;
                font-weight: 600;
                color: var(--accent-color); /* Default color for non-linked usernames */
            }

            .note-username a {
                color: #22c55e !important; /* Green for NIP-05 links */
                text-decoration: none !important;
            }

            .note-username a:hover {
                color: #16a34a !important; /* Darker green on hover */
                text-decoration: underline !important;
            }

            .note-username a:visited {
                color: #22c55e !important; /* Keep green even after visiting */
            }

            .note-time {
                font-size: 0.5rem;
                margin-left: auto;
            }

            /* Mobile filter - compact and efficient */

            .filter-row {
                flex-direction: row;
                gap: 12px;
                align-items: center;
                flex-wrap: nowrap;
            }

            .filter-input-group {
                flex: 1;
                min-width: 150px;
                max-width: 300px;
            }

            .geohash-input {
                width: 100px;
                max-width: 100px;
                min-width: 100px;
                font-size: 0.85rem;
                padding: 8px 10px;
            }

            .search-input {
                font-size: 0.85rem;
                padding: 8px 10px;
            }

            .filter-options {
                display: flex;
                align-items: center;
                gap: 8px;
                flex-shrink: 0;
            }

            .filter-toggle-label {
                font-size: 0.7rem;
                gap: 4px;
            }

            .filter-toggle-text {
                font-size: 0.7rem;
                color: #ffffff;
            }



            /* Mobile compose - always visible at bottom */
            .compose-form {
                padding: 8px 12px;
                margin: 0;
                border-radius: 0;
                background: white;
                border-top: 1px solid #e9ecef;
                flex-shrink: 0;
            }

            .compose-form textarea {
                min-height: 50px;
                font-size: 0.85rem;
                padding: 5px 8px;
            }

            .compose-form .post-btn {
                padding: 8px 16px;
                font-size: 0.8rem;
            }

            .compose-form .compose-actions {
                margin-top: 8px;
                padding-top: 8px;
            }
        }

        @media (max-width: 480px) {
            .map-container {
                height: 4vh;
                min-height: 50px;
                background: var(--map-bg);
            }

            .note-container {
                height: 96vh;
            }

            h1 {
                font-size: 0.8rem;
            }

            .header-top-row {
                padding: 3px 8px;
            }

            .header-title-group p {
                font-size: 0.55rem !important;
            }

            .settings-btn, .relay-manager-btn {
                padding: 2px 5px;
                font-size: 0.5rem;
                min-width: 35px;
            }

            .note-item {
                padding: 10px;
                margin-bottom: 6px;
            }

            .note-content {
                font-size: 0.85rem;
            }


            .filter-row {
                gap: 8px;
            }

            .filter-input-group {
                min-width: 120px;
                max-width: 250px;
            }

            .geohash-input {
                width: 80px;
                max-width: 80px;
                min-width: 80px;
                font-size: 0.8rem;
                padding: 6px 8px;
            }

            .search-input {
                font-size: 0.8rem;
                padding: 6px 8px;
            }

            .filter-toggle-label {
                font-size: 0.65rem;
            }

            .filter-toggle-text {
                font-size: 0.65rem;
                color: #ffffff;
            }



            .compose-form {
                padding: 6px 10px;
            }

            .compose-form textarea {
                min-height: 45px;
                font-size: 0.8rem;
                padding: 4px 6px;
            }

            .compose-form .post-btn {
                padding: 6px 12px;
                font-size: 0.75rem;
            }
        }

        @media (max-width: 360px) {
            .map-container {
                height: 3vh;
                min-height: 40px;
                background: var(--map-bg);
            }

            .note-container {
                height: 97vh;
            }

            h1 {
                font-size: 0.75rem;
            }

            .header-top-row {
                padding: 2px 6px;
            }

            .header-title-group p {
                font-size: 0.5rem !important;
            }

            .settings-btn, .relay-manager-btn {
                padding: 2px 4px;
                font-size: 0.45rem;
                min-width: 30px;
            }

            .note-item {
                padding: 8px;
                margin-bottom: 4px;
            }

            .note-content {
                font-size: 0.8rem;
            }

            .note-username {
                font-size: 0.75rem;
            }

            .note-time {
                font-size: 0.45rem;
            }


            .filter-row {
                gap: 6px;
            }

            .filter-input-group {
                min-width: 100px;
                max-width: 200px;
            }

            .geohash-input {
                width: 70px;
                max-width: 70px;
                min-width: 70px;
                font-size: 0.75rem;
                padding: 5px 6px;
            }

            .search-input {
                font-size: 0.75rem;
                padding: 5px 6px;
            }

            .filter-toggle-label {
                font-size: 0.6rem;
            }

            .filter-toggle-text {
                font-size: 0.6rem;
                color: #ffffff;
            }



            .compose-form {
                padding: 5px 8px;
            }

            .compose-form textarea {
                min-height: 40px;
                font-size: 0.75rem;
                padding: 3px 5px;
            }

            .compose-form .post-btn {
                padding: 5px 10px;
                font-size: 0.7rem;
            }
        }

        /* Force green for NIP-05 links - highest specificity */
        body .main-container .note-item .note-username a,
        body .main-container .note-item .note-username a:link,
        body .main-container .note-item .note-username a:visited,
        body .main-container .note-item .note-username a:active {
            color: #22c55e !important;
            text-decoration: none !important;
        }

        body .main-container .note-item .note-username a:hover {
            color: #16a34a !important;
            text-decoration: underline !important;
        }

        /* Additional specificity for all link states */
        .note-item .note-username a,
        .note-item .note-username a:link,
        .note-item .note-username a:visited,
        .note-item .note-username a:active {
            color: #22c55e !important;
            text-decoration: none !important;
        }

        .note-item .note-username a:hover {
            color: #16a34a !important;
            text-decoration: underline !important;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="map-container">
            <div id="map"></div>
        </div>
        <div class="note-container">
            <div class="container">
                <div class="header-top-row">
                    <div class="header-title-group">
                        <h1>TR<span style="text-transform: lowercase;">ipchat</span></h1>
                        <p style="font-size: 0.7rem; color: var(--text-muted); margin: -18px 0 0 0; font-family: 'JetBrains Mono', 'Fira Code', monospace; text-transform: lowercase;">nostr travel chat - connect with travelers worldwide</p>
                    </div>
                    
                    <!-- TRipchat Links -->
                    <div class="tripchat-links">
                        <button id="settingsBtn" class="settings-btn">üîë KEYS</button>
                        <button id="relayManagerBtn" class="relay-manager-btn">‚öôÔ∏è RELAYS</button>
                        <button id="darkModeToggle" class="dark-mode-toggle" title="Toggle dark mode">üåô</button>
                    </div>
                </div>
                
                <div id="noteContainer">
                    <div class="loading">Loading travel messages from Nostr relays...</div>
                </div>
                
                <!-- Compose Controls -->
                <div id="composeButtonContainer" style="display: none;">
                    <button id="composeBtn" class="compose-btn-bottom">‚úçÔ∏è COMPOSE</button>
                </div>
                <div id="composeFormContainer">
                    <div class="compose-form">
                        <div class="compose-form-body">
                            <div class="compose-section">
                                <textarea id="composeContent" placeholder="What's happening? Share your thoughts, travel updates, or location-specific info..." rows="3"></textarea>
                            </div>
                            <div class="compose-section" style="display: flex; align-items: center; gap: 8px;">
                                <label for="notePersistence" style="margin: 0; font-size: 0.8rem; color: var(--text-muted);">Note Duration:</label>
                                <select id="notePersistence" class="persistence-select">
                                    <option value="1h" selected>1 Hour</option>
                                    <option value="short">24 Hours</option>
                                    <option value="medium">7 Days</option>
                                    <option value="long">30 Days</option>
                                    <option value="permanent">Permanent</option>
                                </select>
                                <div style="font-size: 0.7rem; color: var(--text-muted); margin-left: auto;">
                                    Enter to post<br/>Shift+Enter new line
                                </div>
                            </div>
                            
                            <!-- Filter Row merged into compose form -->
                            <div class="filter-row">
                                <div class="filter-input-group">
                                    <input type="text" id="geohashFilter" placeholder="geohash" class="geohash-input" />
                                    <input type="text" id="searchFilter" placeholder="search filter e.g. #hashtags" class="search-input" />
                                </div>
                                <div class="filter-options">
                                    <label class="filter-toggle-label">
                                        <input type="checkbox" id="nip05Filter" />
                                        <span class="filter-toggle-slider">
                                            <span class="filter-toggle-text">‚úì</span>
                                        </span>
                                    </label>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
            </div>
        </div>
    </div>

    <!-- Live indicator -->
    <div id="liveIndicator" class="live-indicator" style="display: none;">
        üî¥ LIVE
    </div>

    <!-- Settings/Keys Modal -->
    <div id="settingsModal" class="modal-overlay" style="display: none;">
        <div class="modal-content settings-modal">
            <div class="modal-header">
                <h3 class="modal-title">üîë Key Management</h3>
                <button class="modal-close" onclick="document.getElementById('settingsModal').style.display='none'">&times;</button>
            </div>
            <div class="modal-body">
                <div id="settingsModalMessage" class="settings-modal-message"></div>
                <div id="keySetupPrompt" class="key-setup-prompt">
                    <div id="keySetupQuestion" class="key-setup-question">
                        Do you want to use an existing nsec or generate a new one?
                        <span style="display: block; font-weight: 400; font-size: 0.8rem; color: #3a5161; margin-top: 6px;">
                            An <strong>nsec</strong> is your Nostr private key. Keep it secret‚Äîanyone who gets it can post as you. Use the options below to import an existing one or create a fresh keypair.
                        </span>
                    </div>
                    <div class="key-setup-actions">
                        <button id="settingsAddKeyBtn" class="key-btn key-choice">‚ûï Use Existing nsec</button>
                        <button id="settingsGenerateKeyBtn" class="key-btn key-choice">üîë Generate New nsec</button>
                    </div>
                </div>
                <div class="settings-section">
                    <label>PRIVATE KEY:</label>
                    <div class="key-input-group">
                        <input type="text" id="settingsPrivateKey" placeholder="Enter your nsec private key or generate new" />
                    </div>
                    <div id="settingsPrivateKeyHint" class="key-hint"></div>
                </div>
                <div class="settings-section">
                    <label>PUBLIC KEY:</label>
                    <div class="key-input-group">
                        <input type="text" id="settingsPublicKey" placeholder="Your public key will appear here" readonly />
                    </div>
                    <button id="updateProfileBtn" type="button" class="profile-btn">üåê UPDATE TRUSTROOTS PROFILE</button>
                </div>
                <div class="settings-section">
                    <label>TRUSTROOTS USERNAME:</label>
                    <div class="key-input-group">
                        <input type="text" id="trustrootsUsername" placeholder="Enter your Trustroots username (e.g., john)" />
                </div>
                    <div id="usernameStatus" class="username-status" style="margin-top: 8px; font-size: 0.8rem; color: #6c757d; font-style: italic;"></div>
            </div>
                <div class="settings-section">
                    <label>NIP-05 VERIFICATION:</label>
                    <div class="verification-info">
                        <div id="nip05Identifier" class="nip05-identifier" style="margin-bottom: 8px; padding: 8px; background: #f8f9fa; border-radius: 8px; font-family: 'Courier New', monospace; font-size: 0.9rem; color: #2c3e50;"></div>
                        <div id="nip05Url" class="nip05-url" style="margin-bottom: 8px; padding: 8px; background: #f0f8ff; border-radius: 8px; font-family: 'Courier New', monospace; font-size: 0.8rem; color: #1976d2; word-break: break-all; border: 1px solid #bbdefb; display: none;"></div>
                        <div class="verification-actions">
                            <button id="verifyNip05Btn" class="key-btn">üîç VERIFY</button>
                            <button id="retryProfilePostBtn" class="key-btn" style="display: none;">üîÅ RETRY PROFILE POST</button>
                        </div>
                        <div id="verificationStatus" class="verification-status" style="margin-top: 8px; font-size: 0.8rem; font-style: italic;"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Relay Manager Modal -->
    <div id="relayManagerModal" class="modal-overlay" style="display: none;">
        <div class="modal-content relay-modal">
            <div class="modal-header">
                <h3 class="modal-title">‚öôÔ∏è Relay Manager</h3>
                <button class="modal-close" onclick="document.getElementById('relayManagerModal').style.display='none'">&times;</button>
            </div>
            <div class="modal-body">
                <div class="relay-section">
                    <h4>Add New Relay:</h4>
                    <div class="add-relay-group">
                        <input type="text" id="newRelayUrl" placeholder="wss://relay.example.com" />
                        <button id="addRelayBtn" class="add-btn">‚ûï ADD</button>
                    </div>
                </div>
                <div class="relay-section">
                    <h4>Current Relays:</h4>
                    <div id="relayList" class="relay-list">
                        <!-- Relays will be populated here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        class TRipchatVisualizer {
            constructor() {
                this.relays = [
                    'wss://relay.nomadwiki.org',
                    'wss://relay.trustroots.org'
                ];
                this.relayEnabled = {}; // Track which relays are enabled for reading
                this.postingRelays = {}; // Track which relays are enabled for posting
                
                // Note persistence options
                this.NOTE_PERSISTENCE_OPTIONS = {
                    EPHEMERAL: 'ephemeral',
                    SHORT_TERM: 'short',
                    MEDIUM_TERM: 'medium',
                    LONG_TERM: 'long',
                    PERMANENT: 'permanent'
                };
                this.notes = [];
                this.map = null;
                this.mapMarkers = [];
                this.relayStatus = {};
                this.websockets = {};
                this.subscriptionIds = {};
                this.totalEventsReceived = 0;
                this.searchFilter = '';
                this.geohashFilter = '';
                this.nip05Filter = false;
                // Filter states initialized
                this.initialLoadComplete = false;
                this.completedRelays = new Set(); // Track which relays have completed initial load
                this.geohashRectangles = [];
                this.userProfiles = {}; // Cache for user profiles
                this.profileCache = new Map(); // In-memory cache for profiles
                this.privateKey = null; // User's private key for posting
                this.shouldPreserveSettingsMessage = false; // Control modal message resets
                
                // Request queue system to limit concurrent REQ requests
                this.requestQueue = [];
                this.activeRequests = 0;
                this.maxConcurrentRequests = 1; // Limit to 1 concurrent request per relay
                this.requestDelay = 2000; // 2 second delay between requests
                this.updatingHash = false; // Flag to prevent circular hash updates
                this.userHasScrolled = false; // Track if user has manually scrolled
                this.datetimeClickHandlerSetup = false; // Flag to prevent duplicate click handlers
                this.init();
            }

            // Persistence preference methods
            savePersistencePreference(persistence) {
                localStorage.setItem('tripchat_note_persistence', persistence);
            }

            loadPersistencePreference() {
                return localStorage.getItem('tripchat_note_persistence') || '1h';
            }

            // Add expiration filtering
            filterExpiredNotes(notes) {
                return notes.filter(note => {
                    if (note.kind === 20000) return true; // Ephemeral notes handled by relay
                    
                    const expirationTag = note.tags?.find(tag => tag[0] === 'expires_at');
                    if (!expirationTag) return true; // No expiration = permanent
                    
                    const expiresAt = parseInt(expirationTag[1]);
                    const now = Math.floor(Date.now() / 1000);
                    
                    return now < expiresAt; // Show if not expired
                });
            }

            // Add expiration check
            isExpiringSoon(note, hoursThreshold = 24) {
                if (note.kind === 20000) return false;
                
                const expirationTag = note.tags?.find(tag => tag[0] === 'expires_at');
                if (!expirationTag) return false;
                
                const expiresAt = parseInt(expirationTag[1]);
                const now = Math.floor(Date.now() / 1000);
                const timeLeft = expiresAt - now;
                
                return timeLeft > 0 && timeLeft <= (hoursThreshold * 3600);
            }

            async init() {
                try {
                    this.initMap();
                    this.initializeRelayStatus();
                    this.setupFilterHandlers();
                    this.setupComposeHandlers();
                    this.setupSettingsHandlers();
                    this.setupRelayManagerHandlers();
                    this.setupScrollHandlers();
                    this.setupDatetimeClickHandlers(); // Set up click handlers early
                    this.loadFilterFromHash();
                    await this.connectToRelays();
                    
                    // Load saved keys from localStorage
                    this.loadKeysFromStorage();
                } catch (error) {
                    this.displayError('Failed to connect to relays: ' + error.message);
                }
            }

            // Get Trustroots circles data (fetched from actual Trustroots database)
            // Data source: MongoDB query: db.tribes.find({}, { name: 1, slug: 1, description: 1, category: 1, _id: 0 }).sort({ name: 1 })
            // Collection: trust-roots.tribes
            // Last updated: 2024-12-19
            getTrustrootsCircles() {
                return [
                    { slug: 'hitchhikers', name: 'Hitchhikers', description: 'Trustroots was started by hitchhikers for hitchhikers. Many people found out about Trustroots through Hitchwiki. Meet new friends while you are heading in the same direction.' },
                    { slug: 'dumpster-divers', name: 'Dumpster Divers', description: 'Love turning trash into treasure? This circle is for you! A circle for those finding value hidden in our waste bins.' },
                    { slug: 'families', name: 'Families', description: 'It\'s great to share hospitality with kids. If you\'re a small or bigger family, please join this circle.' },
                    { slug: 'musicians', name: 'Musicians', description: 'Love jamming with other musicians? This circle can be good way to find them.' },
                    { slug: 'buskers', name: 'Buskers', description: 'Whether its music, art, theatre or any other kind of performance, find other buskers and street performers in this circle.' },
                    { slug: 'veg', name: 'Veg', description: 'For health, for the animals or for the earth. Join this tribe if you\'re vegan or vegetarian.' },
                    { slug: 'hackers', name: 'Hackers', description: 'Not afraid of :(){ :|:& };: - join fellow hackers at this circle for ubergeeks.' },
                    { slug: 'lgbtq', name: 'LGBTQ', description: 'A circle for lesbian, gay, bi, trans, queer people and their allies.' },
                    { slug: 'ecoliving', name: 'Eco Living', description: 'Are you interested in living with less impact on our planet? Maybe you are already doing so and want to share and connect.' },
                    { slug: 'lindyhoppers', name: 'Lindy Hoppers', description: 'The Lindy hop swing dance community. Hey daddy-o! Dance on over and join your fellow lovers of Lindy Hop and Swing!' },
                    { slug: 'nomads', name: 'Nomads', description: 'Whether you find yourself in a place for a day, week, month or year, this is the circle for the vagabonds and wanderers who find home wherever their head may lie.' },
                    { slug: 'punks', name: 'Punks', description: 'This circle is so punk, we don¬¥t even have a definition. Are you punk? Join us!' },
                    { slug: 'cyclists', name: 'Cyclists', description: 'Legs of steel or maybe just some grand tour ambitions? Cyclists connect with this circle, before, during and after you hit the road.' },
                    { slug: 'foodsharing', name: 'Food Sharing', description: 'Foodsharing.de activists and members.' },
                    { slug: 'yoga', name: 'Yoga', description: 'For practitioners of yoga: meet your fellows in this circle for yogis and yoginis.' },
                    { slug: 'climbers', name: 'Climbers', description: 'Climbers & mountain lovers: come meet fellow climbers and share your favorite spots to climb in this circle for climbers.' },
                    { slug: 'hikers', name: 'Hikers', description: 'For outdoorsy people who love hiking in nature. Would you like to find hosts who can recomend the best local hikes?' },
                    { slug: 'sailors', name: 'Sailors', description: 'For sailors and seafarers. Landlubbers beware! These waters are for sailors and seafarers...' },
                    { slug: 'artists', name: 'Artists', description: 'Creators & Creatives: love to talk about your latest project? Want a host or guest who can connect with you creatively?' },
                    { slug: 'rainbow-gathering', name: 'Rainbow Gathering', description: 'Join this circle if you feel part of the Rainbow Family. It\'s great to camp in nature with hippies. Food circle, now!' },
                    { slug: 'slackline', name: 'Slackline', description: 'Joining this circle is as easy as falling off a 4cm piece of rope...' },
                    { slug: 'spirituals', name: 'Spirituals', description: 'Ever spend time wondering if there is something more to life? This circle is for you no matter what you believe.' },
                    { slug: 'dancers', name: 'Dancers', description: 'Dancing for fun, dancing as a release, dancing as a connection with others... whatever gets your booty shaking is fine with us.' },
                    { slug: 'acroyoga', name: 'Acro Yoga', description: 'Practitioners of acroyoga: like your yoga with a partner or two? Or maybe even upside down?' },
                    { slug: 'jugglers', name: 'Jugglers', description: 'Juggling community: bring your juggling balls, bowling pins, swords and torches! If you are a juggler or have an interest in juggling this is the community for you.' },
                    { slug: 'vanlife', name: 'Van Life', description: 'For folks hitting the nomadic road in their vans, camper vans, motorhomes, buses or what have you!' },
                    { slug: 'trustroots-volunteers', name: 'Trustroots Volunteers', description: 'Join this circle if you want to help grow Trustroots ‚Äî or if you are already helping.' },
                    { slug: 'winemakers', name: 'Winemakers', description: 'The soil, the sun, the grape, the casting, it all influences the taste when creating wine.' },
                    { slug: 'squatters', name: 'Squatters', description: 'The land belongs to those who work it, and a house to those who live in it. N\'est-ce pas?' },
                    { slug: 'surfers', name: 'Surfers', description: 'Vitamin SEA is all we need. Do you feel at home in the water with a board: this is the place for you.' },
                    { slug: 'skateboarders', name: 'Skateboarders', description: 'The streets are your playground. Whether you prefer a skateboard, a longboard or cruiser, join this rolling community.' },
                    { slug: 'pilgrims', name: 'Pilgrims', description: 'For those on spiritual journeys and pilgrimages.' },
                    { slug: 'photographers', name: 'Photographers', description: 'Worth more than a thousand words in a Circle description.' },
                    { slug: 'naturists', name: 'Naturists', description: 'Feel better in your birthday suit? A circle for those practising, advocating and defending personal and social nudity.' },
                    { slug: 'motorcyclists', name: 'Motorcyclists', description: 'For motorcycle enthusiasts and riders.' },
                    { slug: 'feminists', name: 'Feminists', description: 'A feminist is anyone who recognizes the equality and full humanity of women and men.' },
                    { slug: 'circus', name: 'Circus', description: 'Are you rolling through life on one wheel regularly? Do you love swinging on a trapeze? Is walking on a thin rope as normal to you as walking on flat surfaces?' },
                    { slug: 'cooking', name: 'Cooking', description: 'From bon vivant to utter gluttony, as long as you make it yourself or together it\'s all good!' },
                    { slug: 'burners', name: 'Burners', description: 'Burning man community.' },
                    { slug: 'beer-brewers', name: 'Beer Brewers', description: 'No need to be a monk these days, just an enthusiast for this craft. Find you fellow brewers here to exchange recipes.' },
                    { slug: 'anarchists', name: 'Anarchists', description: 'In an anarchist society people wouldn\'t feel as though there was power because everyone would have equal footing.' },
                    { slug: 'gardeners-farmers', name: 'Gardeners & Farmers', description: 'Regardless of whether you have a small urban balcony garden or enough land to live completely off-grid, this is the place for you!' },
                    { slug: 'scuba-divers', name: 'Scuba Divers', description: 'If you love spending more time underwater than above land exploring amazing worlds, then this circle may be good for you.' },
                    { slug: 'ravers', name: 'Ravers', description: 'Love dancing your ass off to beats in underground and secret locations? Come join and find out where the party is at around the world.' },
                    { slug: 'zero-wasters', name: 'Zero Wasters', description: 'Interested in reducing the waste going to landfill and incineration? Connect here with people acting individually and collectively towards a waste free world.' },
                    { slug: 'activists', name: 'Activists', description: 'Power to the people! No oceans, no life! Make love not war! Join this circle to find your fellow activists.' },
                    { slug: 'runners', name: 'Runners', description: 'Anywhere you travel, your running shoes come with? The more miles the better? You even travel for big competitions?' },
                    { slug: 'filmmakers', name: 'Filmmakers', description: 'Aaaand action! Holding a camera, being in front of it, working on the tech side of things, traveling to find the best settings.' }
                ];
            }


            initMap() {
                this.map = L.map('map').setView([20, 0], 2);
                
                // Initialize with light theme, will be updated by setTheme
                this.updateMapTheme();
                
                this.styleMap();
                
                // Map initialized
            }

            styleMap() {
                const style = document.createElement('style');
                style.textContent = `
                    .custom-map-tiles {
                        /* Clean, light map tiles - no filters needed for CartoDB Positron */
                    }
                    .leaflet-container {
                        background: #f8f9fa;
                    }
                    .leaflet-control-zoom a {
                        background: #ffffff;
                        color: #2c3e50;
                        border: 1px solid #e9ecef;
                        font-family: 'Inter', sans-serif;
                        font-weight: 600;
                        width: 32px;
                        height: 32px;
                        line-height: 32px;
                        text-align: center;
                        font-size: 16px;
                        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
                        transition: all 0.3s ease;
                    }
                    .leaflet-control-zoom a:hover {
                        background: var(--accent-color);
                        color: #ffffff;
                        border-color: var(--accent-color);
                        transform: translateY(-1px);
                        box-shadow: 0 4px 12px var(--shadow-hover);
                    }
                    .leaflet-control-zoom {
                        border: 1px solid #e9ecef;
                        border-radius: 8px;
                        background: #ffffff;
                        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
                    }
                    .leaflet-control-zoom a:first-child {
                        border-bottom: 1px solid #e9ecef;
                        border-radius: 8px 8px 0 0;
                    }
                    .leaflet-control-zoom a:last-child {
                        border-radius: 0 0 8px 8px;
                    }
                    .leaflet-popup-content-wrapper {
                        background: #ffffff;
                        border-radius: 12px;
                        border: 1px solid #e9ecef;
                        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
                        color: #2c3e50;
                        font-family: 'Inter', sans-serif;
                    }
                    .leaflet-popup-tip {
                        background: #ffffff;
                        border: 1px solid #e9ecef;
                    }
                    .leaflet-popup-content {
                        color: #2c3e50;
                        font-family: 'Inter', sans-serif;
                        margin: 16px;
                    }
                    .leaflet-popup-content .note-title {
                        color: var(--accent-color);
                        font-weight: 700;
                        font-size: 1rem;
                        margin-bottom: 8px;
                    }
                    .leaflet-popup-content .popup-content {
                        color: #2c3e50;
                        line-height: 1.5;
                        margin-bottom: 8px;
                    }
                    .leaflet-popup-content .popup-time {
                        color: #6c757d;
                        font-size: 0.9rem;
                        font-style: italic;
                    }
            .leaflet-popup-content .popup-location {
                        color: var(--accent-color);
                        font-weight: 600;
                        font-size: 0.9rem;
                        margin-top: 8px;
                    }
                    .leaflet-popup-close-button {
                        color: #6c757d;
                        font-size: 18px;
                    font-weight: bold;
                        padding: 8px;
                    }
                    .leaflet-popup-close-button:hover {
                        color: #dc3545;
                    }
                    .tripchat-marker {
                        transition: all 0.3s ease;
                        animation: pulse 2s infinite;
                    }
                    .tripchat-marker:hover {
                        transform: scale(1.05);
                        fillColor: 'var(--accent-hover)';
                        box-shadow: 0 2px 8px var(--shadow-hover);
                        animation: none;
                    }
                    @keyframes pulse {
                        0% {
                            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
                        }
                        50% {
                            box-shadow: 0 2px 8px var(--shadow-hover);
                        }
                        100% {
                            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
                        }
                    }
                    .geohash-rectangle {
                        transition: all 0.3s ease;
                    }
                    .geohash-highlight {
                        transition: all 0.3s ease;
                        animation: pulse 2s infinite;
                    }
                    @keyframes pulse {
                        0% { opacity: 0.8; }
                        50% { opacity: 0.4; }
                        100% { opacity: 0.8; }
                    }
                `;
                document.head.appendChild(style);
            }

            setupFilterHandlers() {
                const searchFilter = document.getElementById('searchFilter');
                const geohashFilter = document.getElementById('geohashFilter');
                const nip05Filter = document.getElementById('nip05Filter');

                searchFilter.addEventListener('input', (e) => {
                    this.searchFilter = e.target.value.trim().toLowerCase();
                    this.updateHash();
                    this.displayActivities(this.notes);
                    this.plotActivitiesOnMap(this.notes);
                });

                geohashFilter.addEventListener('input', (e) => {
                    this.geohashFilter = e.target.value.trim().toLowerCase();
                    this.updateHash();
                    this.displayActivities(this.notes);
                    this.plotActivitiesOnMap(this.notes);
                    
                    // If filtering by a specific geohash, show its rectangle
                    if (this.geohashFilter && this.isGeohash(this.geohashFilter)) {
                        this.highlightGeohashArea(this.geohashFilter);
                    }
                });


                nip05Filter.addEventListener('change', (e) => {
                    this.nip05Filter = e.target.checked;
                    this.updateHash();
                    this.displayActivities(this.notes);
                    this.plotActivitiesOnMap(this.notes);
                });




                // Listen for hash changes (when user manually changes URL)
                window.addEventListener('hashchange', () => {
                    // Only process hash changes if we're not programmatically updating the hash
                    if (!this.updatingHash) {
                        this.loadFilterFromHash();
                        this.plotActivitiesOnMap(this.notes);
                        
                        // If filtering by a specific geohash, show its rectangle
                        if (this.geohashFilter && this.isGeohash(this.geohashFilter)) {
                            this.highlightGeohashArea(this.geohashFilter);
                        }
                    }
                });
            }


            setTheme(theme) {
                document.documentElement.setAttribute('data-theme', theme);
                const darkModeToggle = document.getElementById('darkModeToggle');
                if (darkModeToggle) {
                    darkModeToggle.textContent = theme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
                }
                this.updateMapTheme();
            }

            updateMapTheme() {
                if (!this.map) return;
                
                // Remove existing tile layer
                this.map.eachLayer((layer) => {
                    if (layer instanceof L.TileLayer) {
                        this.map.removeLayer(layer);
                    }
                });
                
                const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
                
                if (isDark) {
                    // Dark theme map
                    L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                        attribution: '¬© OpenStreetMap contributors, ¬© CARTO',
                        className: 'custom-map-tiles',
                        subdomains: 'abcd',
                        maxZoom: 19
                    }).addTo(this.map);
                } else {
                    // Light theme map
                    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
                        attribution: '¬© OpenStreetMap contributors, ¬© CARTO',
                        className: 'custom-map-tiles',
                        subdomains: 'abcd',
                        maxZoom: 19
                    }).addTo(this.map);
                }
            }

            setupComposeHandlers() {
                const composeBtn = document.getElementById('composeBtn');

                // Initialize the compose form since it's always visible

                // Compose button is now hidden since form is always visible
                // composeBtn.addEventListener('click', () => { ... });

                // Set default persistence preference
                const persistenceSelect = document.getElementById('notePersistence');
                if (persistenceSelect) {
                    const savedPreference = this.loadPersistencePreference();
                    console.log('Loading persistence preference:', savedPreference);
                    persistenceSelect.value = savedPreference;
                    console.log('Set persistence select value to:', persistenceSelect.value);
                    
                    // Save preference when changed
                    persistenceSelect.addEventListener('change', (e) => {
                        console.log('Persistence changed to:', e.target.value);
                        this.savePersistencePreference(e.target.value);
                    });
                }

                // Dark mode toggle
                const darkModeToggle = document.getElementById('darkModeToggle');
                if (darkModeToggle) {
                    // Load saved theme
                    const savedTheme = localStorage.getItem('theme') || 'light';
                    this.setTheme(savedTheme);
                    
                    darkModeToggle.addEventListener('click', () => {
                        const currentTheme = document.documentElement.getAttribute('data-theme');
                        const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
                        this.setTheme(newTheme);
                        localStorage.setItem('theme', newTheme);
                    });
                }


                // Add Enter and Shift+Enter functionality to textarea
                const composeContent = document.getElementById('composeContent');
                if (composeContent) {
                    composeContent.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' && !e.shiftKey) {
                            // Enter sends the note
                            e.preventDefault();
                            this.postNote();
                        }
                        // Shift+Enter allows multiline content (default behavior)
                    });
                }

                // Note: Modal click handler removed since we're using inline compose form
            }

            setupSettingsHandlers() {
                const settingsBtn = document.getElementById('settingsBtn');
                const settingsModal = document.getElementById('settingsModal');
                const settingsGenerateKeyBtn = document.getElementById('settingsGenerateKeyBtn');
                const updateProfileBtn = document.getElementById('updateProfileBtn');
                const settingsPrivateKey = document.getElementById('settingsPrivateKey');
                const settingsPublicKey = document.getElementById('settingsPublicKey');
                const settingsPrivateKeyHint = document.getElementById('settingsPrivateKeyHint');
                const trustrootsUsername = document.getElementById('trustrootsUsername');
                const usernameStatus = document.getElementById('usernameStatus');
                const nip05Identifier = document.getElementById('nip05Identifier');
                const nip05Url = document.getElementById('nip05Url');
                const verifyNip05Btn = document.getElementById('verifyNip05Btn');
                const retryProfilePostBtn = document.getElementById('retryProfilePostBtn');
                const verificationStatus = document.getElementById('verificationStatus');

                // Update username status display
                const updateUsernameStatus = () => {
                    const savedUsername = localStorage.getItem('tripchat_trustroots_username');
                    
                    if (savedUsername) {
                        usernameStatus.textContent = `‚úì Username saved: ${savedUsername}`;
                        usernameStatus.style.color = 'var(--accent-color)';
                    } else {
                        usernameStatus.textContent = 'No username saved yet';
                        usernameStatus.style.color = '#6c757d';
                    }
                };

                // Update NIP-05 identifier display
                const updateNip05Display = () => {
                    const savedUsername = localStorage.getItem('tripchat_trustroots_username');
                    const npub = localStorage.getItem('tripchat_npub');
                    
                    if (savedUsername && npub) {
                        const identifier = `${savedUsername}@trustroots.org`;
                        nip05Identifier.textContent = identifier;
                        nip05Identifier.style.display = 'block';
                        nip05Url.textContent = '';
                        nip05Url.style.display = 'none';
                    } else {
                        nip05Identifier.textContent = 'Enter username and generate keys first';
                        nip05Identifier.style.display = 'block';
                        nip05Url.textContent = '';
                        nip05Url.style.display = 'none';
                    }
                };

                settingsBtn.addEventListener('click', () => {
                    // Load current keys into settings modal
                    const nsecKey = localStorage.getItem('tripchat_nsec');
                    const npubKey = localStorage.getItem('tripchat_npub');
                    const savedUsername = localStorage.getItem('tripchat_trustroots_username');
                    
                    if (nsecKey) {
                        settingsPrivateKey.value = nsecKey;
                    }
                    if (npubKey) {
                        settingsPublicKey.value = npubKey;
                    }
                    if (settingsPrivateKeyHint) {
                        settingsPrivateKeyHint.style.display = 'none';
                        settingsPrivateKeyHint.innerHTML = '';
                    }
                    if (savedUsername) {
                        trustrootsUsername.value = savedUsername;
                    }
                    
                    // Update displays after a short delay to ensure DOM is ready
                    setTimeout(() => {
                        updateUsernameStatus();
                        updateNip05Display();
                        this.highlightKeyInputs();
                        this.toggleKeyButtonsVisibility();
                    }, 100);

                    if (!this.shouldPreserveSettingsMessage) {
                        this.setSettingsModalMessage('');
                    }

                    settingsModal.style.display = 'flex';
                    this.shouldPreserveSettingsMessage = false;
                });

                // Close modal when clicking outside
                settingsModal.addEventListener('click', (e) => {
                    if (e.target === settingsModal) {
                        settingsModal.style.display = 'none';
                        this.setSettingsModalMessage('');
                    }
                });

                settingsGenerateKeyBtn.addEventListener('click', async () => {
                    try {
                        const { nsecKey, npubKey } = await this.generateKeyPair();
                        settingsPrivateKey.value = nsecKey;
                        settingsPublicKey.value = npubKey;
                        
                        // Save to localStorage
                        localStorage.setItem('tripchat_nsec', nsecKey);
                        localStorage.setItem('tripchat_npub', npubKey);
                        
                        // Set class property for immediate use
                        this.privateKey = nsecKey;
                        
                        if (settingsPrivateKeyHint) {
                            settingsPrivateKeyHint.innerHTML = 'Store this nsec safely in your password manager. We recommend <a href="https://bitwarden.com/" target="_blank" rel="noopener noreferrer">Bitwarden</a> if you don\'t have one yet.';
                            settingsPrivateKeyHint.style.display = 'block';
                        }
                        this.highlightKeyInputs();
                        this.toggleKeyButtonsVisibility();
                    } catch (error) {
                        console.error('Error generating key:', error);
                        alert('Error generating keys. Please try again.');
                    }
                });

                settingsAddKeyBtn.addEventListener('click', async () => {
                    const nsecInput = settingsPrivateKey.value.trim();
                    if (!nsecInput) {
                        alert('Please enter your nsec private key first.');
                        return;
                    }
                    
                    try {
                        // Convert nsec to hex and derive npub
                        const privateKeyHex = this.nsecToHex(nsecInput);
                        const npubKey = this.deriveNpubFromPrivateKey(privateKeyHex);
                        
                        // Update the public key field
                        settingsPublicKey.value = npubKey;
                        
                        // Save to localStorage
                        localStorage.setItem('tripchat_nsec', nsecInput);
                        localStorage.setItem('tripchat_npub', npubKey);
                        
                        // Set class property for immediate use
                        this.privateKey = nsecInput;
                        
                        alert('Private key added successfully! Public key has been derived and saved.');
                        if (settingsPrivateKeyHint) {
                            settingsPrivateKeyHint.style.display = 'none';
                            settingsPrivateKeyHint.innerHTML = '';
                        }
                        this.highlightKeyInputs();
                        this.toggleKeyButtonsVisibility();
                    } catch (error) {
                        console.error('Error processing private key:', error);
                        alert('Invalid private key format. Please check your nsec key.');
                    }
                });

                updateProfileBtn.addEventListener('click', async (event) => {
                    event.preventDefault();
                    const npub = settingsPublicKey.value.trim();
                    if (npub) {
                        try {
                            await navigator.clipboard.writeText(npub);
                            alert('Your public key has been copied to the clipboard. Please paste this npub into the Nostr field on Trustroots.');
                        } catch (clipboardError) {
                            console.warn('Failed to copy public key to clipboard:', clipboardError);
                            alert('Could not copy the public key automatically. Please copy it manually before updating Trustroots and paste it into the Nostr field.');
                        }
                    }
                    window.open('https://www.trustroots.org/profile/edit/networks', '_blank');
                });

                // Trustroots username handlers
                // Verify NIP-05 identifier
                const verifyNip05 = async () => {
                    const savedUsername = localStorage.getItem('tripchat_trustroots_username');
                    const npub = localStorage.getItem('tripchat_npub');
                    
                    if (!savedUsername || !npub) {
                        verificationStatus.textContent = 'Please enter username and generate keys first';
                        verificationStatus.style.color = '#dc3545';
                        return;
                    }

                    verificationStatus.textContent = 'Verifying...';
                    verificationStatus.style.color = '#6c757d';
                    console.log('üîç Starting NIP-05 verification', { savedUsername, npub });

                    try {
                        const identifier = `${savedUsername}@trustroots.org`;
                        const verificationUrl = `https://trustroots.org/.well-known/nostr.json?name=${savedUsername}`;
                        console.log('üåê Fetching verification URL:', verificationUrl);
                        
                        const response = await fetch(verificationUrl);
                        console.log('üì• Received response status:', response.status);
                        const data = await response.json();
                        console.log('üìÑ Parsed verification data:', data);

                        if (data.names && data.names[savedUsername]) {
                            const hexPubkey = data.names[savedUsername];
                            console.log('‚úÖ Trustroots returned pubkey:', hexPubkey);
                            
                            // Convert hex to npub for comparison
                            let expectedNpub;
                            try {
                                if (typeof window.nostrTools !== 'undefined') {
                                    expectedNpub = window.nostrTools.nip19.npubEncode(hexPubkey);
                                } else {
                                    // Fallback conversion using the class method
                                    expectedNpub = window.tripchatVisualizer.hexToNpub(hexPubkey);
                                }
                            } catch (conversionError) {
                                console.error('Error converting hex to npub:', conversionError);
                                expectedNpub = null;
                            }
                            
                            if (expectedNpub && expectedNpub === npub) {
                                console.log('üéâ NIP-05 verification matched npub');
                                verificationStatus.textContent = '‚úì NIP-05 verification successful!';
                                verificationStatus.style.color = 'var(--accent-color)';
                                
                                // Post kind 0 profile event to Nostr after successful verification
                                verificationStatus.textContent = '‚úì NIP-05 verified! Posting profile to Nostr...';
                                try {
                                    console.log('üìù Posting profile to Nostr...');
                                    const profilePosted = await this.postProfileToNostr(savedUsername, npub);
                                    if (profilePosted) {
                                        console.log('üöÄ Profile posted to at least one relay');
                                        verificationStatus.textContent = '‚úì NIP-05 verified & profile posted to Nostr!';
                                        verificationStatus.style.color = 'var(--accent-color)';
                                        this.toggleKeyButtonsVisibility();
                                    } else {
                                        console.warn('‚ö†Ô∏è Profile post returned false');
                                        verificationStatus.textContent = '‚úì NIP-05 verified, but failed to post profile to Nostr';
                                        verificationStatus.style.color = '#f39c12';
                                    }
                                } catch (error) {
                                    console.error('Error posting profile:', error);
                                    verificationStatus.textContent = '‚úì NIP-05 verified, but failed to post profile to Nostr';
                                    verificationStatus.style.color = '#f39c12';
                                }
                            } else {
                                console.warn('‚ùå NIP-05 pubkey mismatch', { expectedNpub, npub });
                                verificationStatus.textContent = `‚úó NIP-05 verification failed. Expected: ${expectedNpub}, Got: ${npub}`;
                                verificationStatus.style.color = '#dc3545';
                                this.toggleKeyButtonsVisibility();
                            }
                        } else {
                            console.warn('‚ö†Ô∏è Username not found in Trustroots data', data);
                            verificationStatus.textContent = '‚úó NIP-05 verification failed. Username not found in Trustroots data.';
                            verificationStatus.style.color = '#dc3545';
                            this.toggleKeyButtonsVisibility();
                        }
                    } catch (error) {
                        console.error('NIP-05 verification error:', error);
                        verificationStatus.textContent = '‚úó Verification failed. Check your internet connection.';
                        verificationStatus.style.color = '#dc3545';
                        this.toggleKeyButtonsVisibility();
                    }
                    this.toggleKeyButtonsVisibility();
                };

                retryProfilePostBtn.addEventListener('click', async () => {
                    const savedUsername = localStorage.getItem('tripchat_trustroots_username');
                    const npub = localStorage.getItem('tripchat_npub');
                    if (!savedUsername || !npub) {
                        alert('Please ensure you have generated keys and saved your Trustroots username first.');
                        return;
                    }

                    console.log('üîÅ Manual retry requested for profile post', { savedUsername, npub });
                    verificationStatus.textContent = 'Retrying profile post...';
                    verificationStatus.style.color = '#6c757d';

                    try {
                        const profilePosted = await this.postProfileToNostr(savedUsername, npub);
                        if (profilePosted) {
                            console.log('‚úÖ Manual retry succeeded');
                            verificationStatus.textContent = '‚úì Profile posted to Nostr!';
                            verificationStatus.style.color = 'var(--accent-color)';
                        } else {
                            console.warn('‚ö†Ô∏è Manual retry reported failure');
                            verificationStatus.textContent = '‚úó Failed to post profile. Please try again later or confirm relay connectivity.';
                            verificationStatus.style.color = '#dc3545';
                        }
                    } catch (error) {
                        console.error('‚ùå Error during manual profile post retry:', error);
                        verificationStatus.textContent = '‚úó Error posting profile. Check console for details.';
                        verificationStatus.style.color = '#dc3545';
                    }
                    this.toggleKeyButtonsVisibility();
                });

                // Event listeners
                verifyNip05Btn.addEventListener('click', verifyNip05);

                // Auto-save username when typing (with debounce)
                let usernameTimeout;
                trustrootsUsername.addEventListener('input', () => {
                    clearTimeout(usernameTimeout);
                    usernameTimeout = setTimeout(() => {
                        const username = trustrootsUsername.value.trim();
                        if (username) {
                            localStorage.setItem('tripchat_trustroots_username', username);
                            updateUsernameStatus();
                            updateNip05Display();
                        }
                    }, 500); // 500ms delay
                });

                const handleManualUsernameSave = () => {
                    const username = trustrootsUsername.value.trim();
                    if (username) {
                        localStorage.setItem('tripchat_trustroots_username', username);
                        updateUsernameStatus();
                        updateNip05Display();
                        alert(`Trustroots username "${username}" saved successfully!`);
                    } else {
                        alert('Please enter a valid Trustroots username.');
                    }
                };

                // Allow saving with Enter key
                trustrootsUsername.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        handleManualUsernameSave();
                    }
                });
            }

            setSettingsModalMessage(message) {
                const messageElement = document.getElementById('settingsModalMessage');
                if (!messageElement) {
                    console.warn('Settings modal message element not found.');
                    return;
                }

                if (message) {
                    messageElement.textContent = message;
                    messageElement.style.display = 'block';
                } else {
                    messageElement.textContent = '';
                    messageElement.style.display = 'none';
                }
            }

            enableAutoSelect(input) {
                if (!input) {
                    return;
                }

                if (input.dataset.autoselectInitialized === 'true') {
                    return;
                }

                input.addEventListener('focus', () => {
                    // Delay selection to ensure focus styling applies first
                    setTimeout(() => {
                        if (document.activeElement === input) {
                            input.select();
                        }
                    }, 0);
                });
                input.dataset.autoselectInitialized = 'true';
            }

            highlightKeyInputs() {
                const privateKeyInput = document.getElementById('settingsPrivateKey');
                const publicKeyInput = document.getElementById('settingsPublicKey');

                this.enableAutoSelect(privateKeyInput);
                this.enableAutoSelect(publicKeyInput);

                if (privateKeyInput) {
                    privateKeyInput.focus();
                    if (privateKeyInput.value) {
                        privateKeyInput.select();
                    }
                }
            }

            updateKeySetupPrompt() {
                const prompt = document.getElementById('keySetupPrompt');
                const question = document.getElementById('keySetupQuestion');
                const verificationStatus = document.getElementById('verificationStatus');

                if (!prompt) {
                    return;
                }

                const verificationText = verificationStatus?.textContent || '';
                const isVerified = verificationText.includes('‚úì NIP-05 verified');

                if (isVerified) {
                    prompt.style.display = 'none';
                    return;
                }

                const privateKeyValue = document.getElementById('settingsPrivateKey')?.value.trim();
                const publicKeyValue = document.getElementById('settingsPublicKey')?.value.trim();
                const hasKeys = !!privateKeyValue && !!publicKeyValue;

                prompt.style.display = 'flex';
                if (hasKeys) {
                    prompt.classList.add('compact');
                } else {
                    prompt.classList.remove('compact');
                }
                if (question) {
                    question.style.display = hasKeys ? 'none' : 'block';
                }
            }

            toggleKeyButtonsVisibility() {
                const generateBtn = document.getElementById('settingsGenerateKeyBtn');
                const addExistingBtn = document.getElementById('settingsAddKeyBtn');
                const verificationStatus = document.getElementById('verificationStatus');
                const prompt = document.getElementById('keySetupPrompt');
                const updateProfileBtn = document.getElementById('updateProfileBtn');
                const trustrootsUsername = document.getElementById('trustrootsUsername');
                const verifyNip05Btn = document.getElementById('verifyNip05Btn');
                const retryProfilePostBtn = document.getElementById('retryProfilePostBtn');

                if (!generateBtn || !addExistingBtn || !verificationStatus) {
                    return;
                }

                const verificationText = verificationStatus.textContent || '';
                const isVerified = verificationText.includes('‚úì NIP-05 verified');
                const isVerificationAttempted = verificationText.length > 0;

                if (isVerified) {
                    generateBtn.style.display = 'none';
                    addExistingBtn.style.display = 'none';
                    if (prompt) {
                        prompt.style.display = 'none';
                    }
                    if (updateProfileBtn) {
                        updateProfileBtn.style.display = 'none';
                    }
                    if (trustrootsUsername) {
                        trustrootsUsername.setAttribute('readonly', 'readonly');
                        trustrootsUsername.classList.add('readonly');
                    }
                    if (verifyNip05Btn) {
                    verifyNip05Btn.style.display = 'none';
                }
                if (retryProfilePostBtn) {
                    retryProfilePostBtn.style.display = 'none';
                }
                    if (retryProfilePostBtn) {
                        retryProfilePostBtn.style.display = 'none';
                    }
                } else {
                    generateBtn.style.display = '';
                    addExistingBtn.style.display = '';
                    if (prompt) {
                        prompt.style.display = 'flex';
                    }
                    if (updateProfileBtn) {
                        updateProfileBtn.style.display = '';
                    }
                    if (trustrootsUsername) {
                        trustrootsUsername.removeAttribute('readonly');
                        trustrootsUsername.classList.remove('readonly');
                    }
                    if (verifyNip05Btn) {
                        verifyNip05Btn.style.display = isVerificationAttempted ? 'none' : '';
                    }
                    if (retryProfilePostBtn) {
                        retryProfilePostBtn.style.display = isVerificationAttempted ? '' : 'none';
                    }
                    this.updateKeySetupPrompt();
                }
            }

            openKeysDialog(message = '') {
                const finalMessage = message || "Let's help you set up some keys so you can start posting.";
                this.shouldPreserveSettingsMessage = true;

                const afterOpen = () => {
                    this.setSettingsModalMessage(finalMessage);
                    this.highlightKeyInputs();
                    this.updateKeySetupPrompt();
                    this.toggleKeyButtonsVisibility();
                    this.shouldPreserveSettingsMessage = false;
                };

                const settingsBtn = document.getElementById('settingsBtn');
                if (settingsBtn) {
                    settingsBtn.click();
                    setTimeout(afterOpen, 60);
                    return;
                }

                const settingsModal = document.getElementById('settingsModal');
                if (settingsModal) {
                    settingsModal.style.display = 'flex';
                    setTimeout(afterOpen, 10);
                } else {
                    console.warn('Settings modal not found when attempting to open keys dialog.');
                    this.shouldPreserveSettingsMessage = false;
                }
            }

            setupRelayManagerHandlers() {
                const relayManagerBtn = document.getElementById('relayManagerBtn');
                const relayManagerModal = document.getElementById('relayManagerModal');
                const addRelayBtn = document.getElementById('addRelayBtn');
                const newRelayUrl = document.getElementById('newRelayUrl');

                relayManagerBtn.addEventListener('click', () => {
                    relayManagerModal.style.display = 'flex';
                    this.updateRelayList();
                });

                addRelayBtn.addEventListener('click', () => {
                    const url = newRelayUrl.value.trim();
                    if (url && url.startsWith('wss://')) {
                        this.addRelay(url);
                        newRelayUrl.value = '';
                        this.updateRelayList();
                    } else {
                        alert('Please enter a valid WebSocket URL (wss://...)');
                    }
                });

                // Close modal when clicking outside
                relayManagerModal.addEventListener('click', (e) => {
                    if (e.target === relayManagerModal) {
                        relayManagerModal.style.display = 'none';
                    }
                });
            }


            setupGeohashTagClickHandlers() {
                document.querySelectorAll('.geohash-tag').forEach(tagElement => {
                    tagElement.addEventListener('click', (e) => {
                        const geohash = e.target.dataset.geohash;
                        if (geohash) {
                            this.geohashFilter = geohash;
                            document.getElementById('geohashFilter').value = geohash;
                            this.updateHash();
                            this.displayActivities(this.notes);
                            this.plotActivitiesOnMap(this.notes);
                            if (this.isGeohash(this.geohashFilter)) {
                                this.highlightGeohashArea(this.geohashFilter);
                            }
                        }
                    });
                });
            }

            setupDatetimeClickHandlers() {
                // Use event delegation to handle clicks on dynamically added elements
                // Only set up once to avoid duplicate listeners
                if (this.datetimeClickHandlerSetup) {
                    return;
                }
                
                const noteContainer = document.getElementById('noteContainer');
                if (noteContainer) {
                    noteContainer.addEventListener('click', (e) => {
                        // Check if the clicked element or its parent has the note-time class
                        const timeElement = e.target.closest('.note-time');
                        if (timeElement) {
                            const noteId = timeElement.dataset.noteId;
                            if (noteId) {
                                const note = this.notes.find(a => a.id === noteId);
                                if (note) {
                                    this.showNoteDetailsModal(note);
                                }
                            }
                        }
                    });
                    this.datetimeClickHandlerSetup = true;
                }
            }

            setupHashtagClickHandlers() {
                document.querySelectorAll('.hashtag-link').forEach(link => {
                    link.addEventListener('click', (e) => {
                        e.preventDefault();
                        const circleSlug = link.dataset.circle;
                        const hashtag = link.dataset.hashtag;
                        
                        // Check if the hashtag is actually a geohash
                        if (this.isGeohash(hashtag)) {
                            // Update geohash filter
                            this.geohashFilter = hashtag;
                            const geohashFilterInput = document.getElementById('geohashFilter');
                            if (geohashFilterInput) {
                                geohashFilterInput.value = hashtag;
                            }
                            
                            // Update display and hash
                            this.updateHash();
                            this.displayActivities(this.notes);
                            this.plotActivitiesOnMap(this.notes);
                            
                            // Highlight the geohash area on map
                            if (this.isGeohash(this.geohashFilter)) {
                                this.highlightGeohashArea(this.geohashFilter);
                            }
                            
                            // Added geohash to filter
                        } else {
                            // Add hashtag to the search filter, replacing any existing hashtag
                            const currentFilter = this.searchFilter || '';
                            const hashtagText = `#${hashtag}`;
                            let newFilter = currentFilter;
                            
                            // Check if there's already a hashtag in the filter
                            const hashtagRegex = /#\w+/g;
                            const existingHashtags = currentFilter.match(hashtagRegex);
                            
                            if (existingHashtags && existingHashtags.length > 0) {
                                // Replace the first hashtag with the new one
                                newFilter = currentFilter.replace(hashtagRegex, hashtagText);
                            } else if (currentFilter) {
                                // Add space and hashtag if there's already content but no hashtag
                                newFilter = `${currentFilter} ${hashtagText}`;
                            } else {
                                // Just add the hashtag if filter is empty
                                newFilter = hashtagText;
                            }
                            
                            // Update the search filter
                            this.searchFilter = newFilter;
                            const searchFilterInput = document.getElementById('searchFilter');
                            if (searchFilterInput) {
                                searchFilterInput.value = newFilter;
                            }
                            
                            // Update display and hash
                            this.updateHash();
                            this.displayActivities(this.notes);
                            this.plotActivitiesOnMap(this.notes);
                            
                            // Added hashtag to search filter
                        }
                    });
                });
            }

            setupScrollHandlers() {
                const noteContainer = document.getElementById('noteContainer');
                if (noteContainer) {
                    noteContainer.addEventListener('scroll', () => {
                        // Check if user is near the bottom (within 100px)
                        const isNearBottom = noteContainer.scrollTop + noteContainer.clientHeight >= noteContainer.scrollHeight - 100;
                        
                        if (isNearBottom) {
                            // User is at or near bottom, allow auto-scroll
                            this.userHasScrolled = false;
                        } else {
                            // User has scrolled up, disable auto-scroll
                            this.userHasScrolled = true;
                        }
                    });
                }
            }

            scrollToBottom() {
                // Only auto-scroll if user hasn't manually scrolled up
                if (!this.userHasScrolled) {
                    const noteContainer = document.getElementById('noteContainer');
                    if (noteContainer) {
                        noteContainer.scrollTop = noteContainer.scrollHeight;
                    }
                }
            }



            // NIP-05 Profile Caching Methods
            getCachedProfile(pubkey) {
                try {
                    const cached = localStorage.getItem(`tripchat_profile_${pubkey}`);
                    if (cached) {
                        const profile = JSON.parse(cached);
                        const now = Date.now();
                        // Cache for 1 hour
                        if (now - profile.cachedAt < 3600000) {
                            return profile.data;
                        } else {
                            localStorage.removeItem(`tripchat_profile_${pubkey}`);
                        }
                    }
                } catch (e) {
                    console.warn('Error reading cached profile:', e);
                }
                return null;
            }

            setCachedProfile(pubkey, profile) {
                try {
                    const cacheData = {
                        data: profile,
                        cachedAt: Date.now()
                    };
                    localStorage.setItem(`tripchat_profile_${pubkey}`, JSON.stringify(cacheData));
                } catch (e) {
                    console.warn('Error caching profile:', e);
                }
            }

            // Preload profiles for visible notes to show green links faster
            async preloadVisibleProfiles() {
                const visibleNotes = this.notes.slice(0, 20); // Only preload first 20 notes
                const profilePromises = visibleNotes.map(note => {
                    if (note.pubkey && !this.userProfiles[note.pubkey]) {
                        return this.fetchUserProfile(note.pubkey);
                    }
                    return Promise.resolve();
                });
                
                await Promise.allSettled(profilePromises);
                // Re-render to show any newly loaded profiles
                this.displayActivities(this.notes);
            }

            async fetchUserProfile(pubkey) {
                // Check in-memory cache first
                if (this.userProfiles[pubkey]) {
                    return this.userProfiles[pubkey];
                }

                // Check localStorage cache
                const cachedProfile = this.getCachedProfile(pubkey);
                if (cachedProfile) {
                    this.userProfiles[pubkey] = cachedProfile;
                    this.profileCache.set(pubkey, cachedProfile);
                    return cachedProfile;
                }

                try {
                    // Try to fetch from the first available relay
                for (const relayUrl of this.relays) {
                    if (this.websockets[relayUrl] && this.websockets[relayUrl].readyState === WebSocket.OPEN) {
                            const profile = await this.requestUserProfile(relayUrl, pubkey);
                            if (profile) {
                                // Cache profile in both memory and localStorage
                                this.userProfiles[pubkey] = profile;
                                this.profileCache.set(pubkey, profile);
                                this.setCachedProfile(pubkey, profile);
                                // Re-render notes to show the new username
                                this.displayActivities(this.notes);
                                return profile;
                            }
                        }
                    }
                } catch (error) {
                    console.warn('Error fetching user profile for', pubkey, ':', error);
                }

                // Fallback: create a basic profile with shortened pubkey
                const shortPubkey = pubkey.substring(0, 8) + '...';
                const fallbackProfile = { name: shortPubkey, pubkey: pubkey };
                this.userProfiles[pubkey] = fallbackProfile;
                this.profileCache.set(pubkey, fallbackProfile);
                // Don't cache fallback profiles in localStorage
                return fallbackProfile;
            }

            // Request queue management methods
            async queueRequest(relayUrl, requestFunction) {
                return new Promise((resolve, reject) => {
                    this.requestQueue.push({
                        relayUrl,
                        requestFunction,
                        resolve,
                        reject
                    });
                    this.processRequestQueue();
                });
            }

            async processRequestQueue() {
                if (this.activeRequests >= this.maxConcurrentRequests || this.requestQueue.length === 0) {
                    return;
                }

                const request = this.requestQueue.shift();
                if (!request) return;

                this.activeRequests++;
                
                try {
                    // Add delay between requests to avoid overwhelming the relay
                    await new Promise(resolve => setTimeout(resolve, this.requestDelay));
                    
                    const result = await request.requestFunction();
                    request.resolve(result);
                } catch (error) {
                    request.reject(error);
                } finally {
                    this.activeRequests--;
                    // Process next request in queue
                    setTimeout(() => this.processRequestQueue(), 100);
                }
            }

            requestUserProfile(relayUrl, pubkey) {
                return this.queueRequest(relayUrl, () => {
                    return new Promise((resolve) => {
                        const subscriptionId = "profile-" + Math.random().toString(36).substr(2, 9);
                        const filters = {
                            "kinds": [0], // Metadata events
                            "authors": [pubkey],
                            "limit": 1
                        };
                        
                        const subscription = ["REQ", subscriptionId, filters];
                        
                        const timeout = setTimeout(() => {
                            // Close the subscription
                            if (this.websockets[relayUrl]) {
                                this.websockets[relayUrl].send(JSON.stringify(["CLOSE", subscriptionId]));
                            }
                            resolve(null);
                        }, 3000); // 3 second timeout
                        
                        const handleMessage = (event) => {
                            try {
                                const data = JSON.parse(event.data);
                                if (Array.isArray(data)) {
                                    const [messageType, subId, eventData] = data;
                                    
                                    if (messageType === 'EVENT' && subId === subscriptionId && eventData.kind === 0) {
                                        clearTimeout(timeout);
                                        this.websockets[relayUrl].removeEventListener('message', handleMessage);
                                        
                                        // Close the subscription
                                        this.websockets[relayUrl].send(JSON.stringify(["CLOSE", subscriptionId]));
                                        
                                        try {
                                            const metadata = JSON.parse(eventData.content);
                                            const profile = {
                                                name: metadata.name || metadata.display_name || pubkey.substring(0, 8) + '...',
                                                pubkey: pubkey,
                                                picture: metadata.picture,
                                                about: metadata.about,
                                                nip05: metadata.nip05 // Add NIP-05 field
                                            };
                                            // Profile fetched successfully
                                            resolve(profile);
                                        } catch (e) {
                                            resolve({ name: pubkey.substring(0, 8) + '...', pubkey: pubkey });
                                        }
                                    } else if (messageType === 'EOSE' && subId === subscriptionId) {
                                        clearTimeout(timeout);
                                        this.websockets[relayUrl].removeEventListener('message', handleMessage);
                                        
                                        // Close the subscription
                                        this.websockets[relayUrl].send(JSON.stringify(["CLOSE", subscriptionId]));
                                        
                                        resolve(null);
                                    }
                                }
                            } catch (e) {
                                // Ignore parsing errors
                            }
                        };
                        
                        this.websockets[relayUrl].addEventListener('message', handleMessage);
                        this.websockets[relayUrl].send(JSON.stringify(subscription));
                    });
                });
            }

            updateHash() {
                this.updatingHash = true; // Prevent circular hash updates
                
                const url = new URL(window.location);
                let hashParts = [];
                
                // Handle search filter - if it's a simple hashtag, use direct format
                if (this.searchFilter) {
                    // Check if it's just a hashtag (starts with #)
                    if (this.searchFilter.startsWith('#')) {
                        // Remove the # prefix since we'll add it when constructing the hash
                        hashParts.push(this.searchFilter.substring(1));
                    } else {
                        // For other search terms, use parameter format
                        hashParts.push(`search=${encodeURIComponent(this.searchFilter)}`);
                    }
                }
                
                // Handle geohash filter
                if (this.geohashFilter) {
                    hashParts.push(`geohash=${this.geohashFilter}`);
                }
                
                // Handle NIP-05 filter
                if (this.nip05Filter) {
                    hashParts.push('nip05=true');
                }
                
                // Update the hash
                if (hashParts.length > 0) {
                    url.hash = `#${hashParts.join('&')}`;
                } else {
                    url.hash = '';
                }
                window.history.replaceState(null, '', url);
                
                this.updatingHash = false; // Reset flag
            }

            loadFilterFromHash() {
                const hash = window.location.hash;
                console.log('Loading filter from hash:', hash);
                if (hash && hash.startsWith('#')) {
                    const hashContent = hash.substring(1); // Remove the # symbol
                    
                    // Check if it's a simple hashtag or hashtag with parameters
                    if (!hashContent.includes('=')) {
                        // Direct hashtag format: hitchhiking or hitchhiking&geohash=u1&nip05=true
                        const parts = hashContent.split('&');
                        const hashtag = parts[0]; // hitchhiking
                        
                        // Set the hashtag as search filter (add # prefix)
                        this.searchFilter = '#' + hashtag.toLowerCase();
                        console.log('Set search filter to:', this.searchFilter);
                        const searchFilterInput = document.getElementById('searchFilter');
                        if (searchFilterInput) {
                            searchFilterInput.value = '#' + hashtag;
                            console.log('Updated search filter input to:', '#' + hashtag);
                        }
                        
                        // Parse additional parameters
                        for (let i = 1; i < parts.length; i++) {
                            const [key, value] = parts[i].split('=');
                            if (key === 'geohash') {
                                this.geohashFilter = value.toLowerCase();
                                const geohashFilterInput = document.getElementById('geohashFilter');
                                if (geohashFilterInput) {
                                    geohashFilterInput.value = value;
                                }
                            } else if (key === 'nip05' && value === 'true') {
                                this.nip05Filter = true;
                                const nip05FilterInput = document.getElementById('nip05Filter');
                                if (nip05FilterInput) {
                                    nip05FilterInput.checked = true;
                                }
                            }
                        }
                    } else {
                        // Try to parse as URL parameters (legacy format)
                        try {
                            const params = new URLSearchParams(hashContent);
                            const search = params.get('search');
                            const geohash = params.get('geohash');
                            const nip05 = params.get('nip05');
                            
                            if (search) {
                                this.searchFilter = search.toLowerCase();
                                const searchFilterInput = document.getElementById('searchFilter');
                                if (searchFilterInput) {
                                    searchFilterInput.value = search;
                                }
                            }
                            
                            if (geohash) {
                                this.geohashFilter = geohash.toLowerCase();
                                const geohashFilterInput = document.getElementById('geohashFilter');
                                if (geohashFilterInput) {
                                    geohashFilterInput.value = geohash;
                                }
                            }
                            
                            if (nip05 === 'true') {
                                this.nip05Filter = true;
                                const nip05FilterInput = document.getElementById('nip05Filter');
                                if (nip05FilterInput) {
                                    nip05FilterInput.checked = true;
                                }
                            } else {
                                this.nip05Filter = false;
                                const nip05FilterInput = document.getElementById('nip05Filter');
                                if (nip05FilterInput) {
                                    nip05FilterInput.checked = false;
                                }
                            }
                        } catch (e) {
                            // Invalid hash format - ignore
                        }
                    }
                } else {
                    // No hash parameters - ensure filters are in default state
                    this.nip05Filter = false;
                    const nip05FilterInput = document.getElementById('nip05Filter');
                    if (nip05FilterInput) {
                        nip05FilterInput.checked = false;
                    }
                }
                
                // Update display after loading filters
                this.displayActivities();
                // Filter state loaded from hash
            }

            getFilteredActivities() {
                let filtered = this.notes;
                
                // Apply geohash filter (only when geohash filter is active)
                if (this.geohashFilter) {
                    const beforeCount = filtered.length;
                    const geohashTerm = this.geohashFilter.toLowerCase();
                    filtered = filtered.filter(note => {
                        // Check if note has matching geohash
                        const hasMatchingGeohash = note.tags && note.tags.some(tag => 
                            tag[0] === 'g' && 
                            tag[1] && 
                            tag[1].toLowerCase().includes(geohashTerm)
                        );
                        
                        // Show note if it has matching geohash
                        return hasMatchingGeohash;
                    });
                    // Geohash filter applied
                }
                
                // Apply search filter (hashtags, content, usernames)
                if (this.searchFilter) {
                    const beforeCount = filtered.length;
                    const searchTerm = this.searchFilter.toLowerCase();
                    filtered = filtered.filter(note => {
                        // Search in hashtag tags
                        const hasHashtagMatch = note.tags && note.tags.some(tag => 
                            tag[0] === 't' && 
                            tag[1] && 
                            tag[1].toLowerCase().includes(searchTerm)
                        );
                        
                        // Search in note content
                        const hasContentMatch = note.content && 
                            note.content.toLowerCase().includes(searchTerm);
                        
                        // Search in username (if we have profile data)
                        const profile = this.userProfiles[note.pubkey];
                        const hasUsernameMatch = profile && profile.name && 
                            profile.name.toLowerCase().includes(searchTerm);
                        
                        // Search in geohash tags
                        const hasGeohashMatch = note.tags && note.tags.some(tag => 
                            tag[0] === 'g' && 
                            tag[1] && 
                            tag[1].toLowerCase().includes(searchTerm)
                        );
                        
                        return hasHashtagMatch || hasContentMatch || hasUsernameMatch || hasGeohashMatch;
                    });
                    // Search filter applied
                }
                
                // Apply NIP-05 verification filter
                if (this.nip05Filter) {
                    const beforeCount = filtered.length;
                    filtered = filtered.filter(note => {
                        if (!note.tags) return false;
                        
                        return note.tags.some(tag => 
                            tag[0] === 'nip05' && 
                            tag[1] && 
                            tag[1].endsWith('@trustroots.org')
                        );
                    });
                    // NIP-05 filter applied
                }
                return filtered;
            }





            async connectToRelays() {
                const noteContainer = document.getElementById('noteContainer');
                noteContainer.innerHTML = '<div class="loading">Connecting to TRipchat Nostr relays...</div>';

                // Starting connection to relays

                for (const relayUrl of this.relays) {
                    this.connectToRelay(relayUrl);
                }
                
                // Set a timeout to show connection status
                setTimeout(() => {
                    this.updateConnectionStatus();
                }, 5000);
            }

            updateConnectionStatus() {
                const noteContainer = document.getElementById('noteContainer');
                const connectedRelays = Object.values(this.relayStatus).filter(status => status.status === 'connected').length;
                const totalRelays = this.relays.length;
                
                if (connectedRelays === 0) {
                    noteContainer.innerHTML = '<div class="loading">‚ùå Failed to connect to any relays. Check console for errors.</div>';
                } else if (connectedRelays < totalRelays) {
                    noteContainer.innerHTML = `<div class="loading">‚ö†Ô∏è Connected to ${connectedRelays}/${totalRelays} relays. Events received: ${this.totalEventsReceived}, Notes: ${this.notes.length}</div>`;
                } else {
                    noteContainer.innerHTML = `<div class="loading">‚úÖ Connected to all relays. Events received: ${this.totalEventsReceived}, Notes: ${this.notes.length}</div>`;
                }
                
                // If we have notes, display them
                if (this.notes.length > 0) {
                    this.displayActivities(this.notes);
                    // Preload profiles for faster green link display
                    this.preloadVisibleProfiles();
                }
            }

            connectToRelay(relayUrl) {
                this.updateRelayStatus(relayUrl, 'connecting');

                try {
                    const ws = new WebSocket(relayUrl);
                    this.websockets[relayUrl] = ws;
                    
                    const subscriptionId = "tripchat-note-" + Math.random().toString(36).substr(2, 9);
                    this.subscriptionIds[relayUrl] = subscriptionId;

                    ws.onopen = () => {
                        this.updateRelayStatus(relayUrl, 'connected');
                        
                        // Subscribe to TRipchat-specific event kinds
                        const filters = {
                            "kinds": [1, 0], // Text notes + profiles
                            "limit": 50,
                            "since": Math.floor(Date.now() / 1000) - (30 * 24 * 60 * 60) // Last 30 days
                        };
                        
                        const subscription = [
                            "REQ",
                            subscriptionId,
                            filters
                        ];
                        
                        ws.send(JSON.stringify(subscription));
                        
                        // Update connection status
                        this.updateConnectionStatus();
                    };

                    ws.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            // Received data from relay
                            
                            if (Array.isArray(data)) {
                                const [messageType, subId, eventData] = data;
                                
                                if (messageType === 'EVENT' && eventData && (subId === subscriptionId || subId.startsWith('tripchat-live-'))) {
                                    this.totalEventsReceived++;
                                    const noteAge = Math.floor((Date.now() / 1000) - eventData.created_at);
                                    const ageHours = Math.floor(noteAge / 3600);
                                    const ageDays = Math.floor(ageHours / 24);
                                    // Received event
                                    
                                    // Check for geohash tags in events
                                    
                                    // Check if this is TRipchat note
                                    if (this.isTRipchatNote(eventData)) {
                                        this.addNewNote(eventData);
                                        this.updateRelayStatus(relayUrl, 'connected', this.notes.length);
                                        this.updateConnectionStatus();
                                    }
                } else if (messageType === 'EOSE' && subId === subscriptionId) {
                    this.updateRelayStatus(relayUrl, 'connected', this.notes.length);
                    this.updateConnectionStatus();
                    
                    // Start live subscription for new notes
                    this.startLiveSubscription(relayUrl);
                    
                    // Track completed relays for initial load
                    this.completedRelays.add(relayUrl);
                    this.checkAllRelaysCompleted();
                    
                    // Show load more button after initial load
                    if (!this.initialLoadComplete) {
                        this.initialLoadComplete = true;
                    }
                } else if (messageType === 'NOTICE') {
                                    // Notice from relay
                                }
                            }
                        } catch (e) {
                            console.warn('Error parsing message from', relayUrl, ':', e);
                        }
                    };

                    ws.onerror = (error) => {
                        console.error(`Error connecting to ${relayUrl}:`, error);
                        this.updateRelayStatus(relayUrl, 'disconnected');
                        this.updateConnectionStatus();
                    };

                    ws.onclose = () => {
                        this.updateRelayStatus(relayUrl, 'disconnected');
                        
                        setTimeout(() => {
                            this.connectToRelay(relayUrl);
                        }, 5000);
                    };
                } catch (error) {
                    console.error(`Failed to connect to ${relayUrl}:`, error);
                    this.updateRelayStatus(relayUrl, 'disconnected');
                }
            }

            isTRipchatNote(event) {
                // Accept Kind 1 events (text notes)
                if (event.kind === 1) {
                    return true;
                }
                
                // Check if it has location-related content
                const content = event.content || '';
                const hasLocationKeywords = /travel|trip|location|geohash|trustroots|hitchhiking/i.test(content);
                if (hasLocationKeywords) {
                    return true;
                }
                
                return false;
            }

            startLiveSubscription(relayUrl) {
                // Subscribe to new notes in real-time
                const liveSubscriptionId = "tripchat-live-" + Math.random().toString(36).substr(2, 9);
                const liveFilters = {
                    "kinds": [1], // Only text notes for live updates
                    "since": Math.floor(Date.now() / 1000) // Only new notes from now
                };
                
                const liveSubscription = [
                    "REQ",
                    liveSubscriptionId,
                    liveFilters
                ];
                
                // Starting live subscription
                
                if (this.websockets[relayUrl]) {
                    this.websockets[relayUrl].send(JSON.stringify(liveSubscription));
                }
            }

            checkAllRelaysCompleted() {
                // Check if all enabled relays have completed their initial load
                const enabledRelays = this.relays.filter(relay => this.relayEnabled[relay] !== false);
                // Check relay completion status
                
                if (this.completedRelays.size >= enabledRelays.length) {
                    // Auto-scroll to bottom after all notes have loaded
                    setTimeout(() => {
                        this.scrollToBottom();
                        // Focus on compose content after loading
                        const composeContent = document.getElementById('composeContent');
                        if (composeContent) {
                            composeContent.focus();
                        }
                    }, 200); // Shorter delay since displayActivities already has a 100ms delay
                }
            }

            addNewNote(note) {
                // Check if note already exists
                if (this.notes.find(a => a.id === note.id)) {
                    // Note already exists, skipping
                    return;
                }

                // Ensure created_at is a number
                if (typeof note.created_at !== 'number') {
                    console.warn(`Note ${note.id} has invalid created_at:`, note.created_at);
                    note.created_at = Math.floor(Date.now() / 1000);
                }

                // Adding note
                
                this.notes.push(note);
                this.notes.sort((a, b) => a.created_at - b.created_at);
                
                // Note added to collection
                
                if (this.notes.length > 200) {
                    this.notes = this.notes.slice(0, 200);
                }

                // Fetch user profile if we don't have it (only for recent notes to avoid spam)
                if (note.pubkey && !this.userProfiles[note.pubkey] && this.notes.length <= 20) {
                    this.fetchUserProfile(note.pubkey);
                }

                // Show live indicator
                const liveIndicator = document.getElementById('liveIndicator');
                if (liveIndicator) {
                    liveIndicator.style.display = 'block';
                    setTimeout(() => {
                        liveIndicator.style.display = 'none';
                    }, 3000);
                }

                this.displayActivities(this.notes);
                this.plotActivitiesOnMap(this.notes);
                
                // Add visual effect to the new note
                setTimeout(() => {
                    const noteElement = document.querySelector(`[data-note-id="${note.id}"]`);
                    if (noteElement) {
                        noteElement.classList.add('note-new');
                        setTimeout(() => {
                            noteElement.classList.remove('note-new');
                        }, 500);
                    }
                }, 100);
                
            }

            displayActivities(notes) {
                const noteContainer = document.getElementById('noteContainer');
                const filteredActivities = this.getFilteredActivities();
                const nonExpiredActivities = this.filterExpiredNotes(filteredActivities);
                
                if (nonExpiredActivities.length === 0) {
                    if (this.searchFilter || this.geohashFilter) {
                        const filterText = this.geohashFilter ? `geohash "${this.geohashFilter}"` : `search "${this.searchFilter}"`;
                        noteContainer.innerHTML = `<div class="loading">No notes found for ${filterText}. Try a different search term or clear the filter.</div>`;
                    } else {
                        noteContainer.innerHTML = '<div class="loading">No TRipchat note found. Check the browser console for debug information.</div>';
                    }
                    return;
                }

                const loadingDiv = noteContainer.querySelector('.loading');
                if (loadingDiv) {
                    loadingDiv.remove();
                }

                const sortedActivities = [...nonExpiredActivities].sort((a, b) => a.created_at - b.created_at);
                const limitedActivities = sortedActivities.slice(0, 50); // Limit to 50 notes (oldest first)
                noteContainer.innerHTML = '';

                limitedActivities.forEach(note => {
                    const noteDiv = document.createElement('div');
                    
                    // Add persistence classes
                    const isExpiring = this.isExpiringSoon(note);
                    noteDiv.className = `note-item persistent ${isExpiring ? 'expiring' : ''}`;
                    noteDiv.setAttribute('data-note-id', note.id);
                    
                    try {
                        const timestamp = new Date(note.created_at * 1000);
                        const timeString = this.formatTime(timestamp);
                        const relativeTime = this.getRelativeTime(timestamp);
                        
                        const renderedHtml = this.renderNote(note, timeString, relativeTime);
                        
                        if (renderedHtml && typeof renderedHtml === 'string' && renderedHtml.trim().length > 0) {
                            noteDiv.innerHTML = renderedHtml;
                        } else {
                            noteDiv.innerHTML = this.renderFallbackNote(note, timeString, relativeTime);
                        }
                        
                        // Expiration info is now combined with timestamp in renderNote
                    } catch (error) {
                        console.error('Error rendering note:', error, note);
                        noteDiv.innerHTML = this.renderFallbackNote(note, timeString, relativeTime);
                    }
                    
                    noteContainer.appendChild(noteDiv);
                });
                
                // Set up click handlers for geohash tags
                this.setupGeohashTagClickHandlers();
                
                // Scroll to bottom to show latest messages (with delay to ensure DOM is rendered)
                setTimeout(() => {
                    this.scrollToBottom();
                }, 100);
                
                // Set up click handlers for hashtag links
                this.setupHashtagClickHandlers();
                
            }

            renderNote(note, timeString, relativeTime) {
                const content = this.escapeHtml(note.content || '');
                const processedContent = content.replace(/\n/g, '<br>');
                
                // Extract geohash tags
                const geohashTags = [];
                if (note.tags) {
                    note.tags.forEach(tag => {
                        if (tag[0] === 'g' && tag[1]) {
                            geohashTags.push(tag[1]);
                        }
                    });
                }
                
                const geohashHtml = geohashTags.length > 0 ? `
                    <div style="margin: 8px 0; text-align: right;">
                        ${geohashTags.map(geohash => `<span class="geohash-tag" data-geohash="${geohash}">üìç ${geohash}</span>`).join('')}
                    </div>
                ` : '';
                
                const noteType = this.getNoteType(note);
                
                // Get username from profile cache with discriminator
                const profile = this.userProfiles[note.pubkey];
                // Rendering note with profile data
                const username = this.formatUsernameWithDiscriminator(profile, note.pubkey);
                
                // Process hashtags to make them clickable
                let contentHtml = this.processHashtags(processedContent);
                
                // Get expiration info for combined timestamp
                let expirationText = '';
                const expirationTag = note.tags?.find(tag => tag[0] === 'expires_at');
                if (expirationTag) {
                    const expiresAt = parseInt(expirationTag[1]);
                    const now = Math.floor(Date.now() / 1000);
                    const timeLeft = expiresAt - now;
                    
                    if (timeLeft > 0) {
                        const hoursLeft = Math.floor(timeLeft / 3600);
                        const minutesLeft = Math.floor(timeLeft / 60);
                        
                        if (hoursLeft >= 1) {
                            expirationText = ` ‚Ä¢ expires in ${hoursLeft}h`;
                        } else if (minutesLeft >= 1) {
                            expirationText = ` ‚Ä¢ expires in ${minutesLeft}m`;
                        } else {
                            expirationText = ` ‚Ä¢ expires in <1m`;
                        }
                    }
                }

                return `
                    <div class="note-header">
                        <span class="note-username" style="font-weight: 600; font-size: 0.75rem;">${username}</span>
                    </div>
                    <div class="note-time" title="Click to view raw Nostr data: ${timeString}" data-note-id="${note.id}" style="font-size: 0.5rem; color: var(--text-muted); text-align: right; line-height: 1.2; margin-bottom: 4px;">
                        <div>${relativeTime}</div>
                        ${expirationText ? `<div style="font-size: 0.45rem; margin-top: 1px;">${expirationText.replace(' ‚Ä¢ ', '')}</div>` : ''}
                    </div>
                    <div class="note-content">${contentHtml}</div>
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 8px;">
                        <div style="display: flex; gap: 8px;">
                            ${geohashTags.map(geohash => `<span class="geohash-tag" data-geohash="${geohash}" style="background: #e9ecef; color: #6c757d; padding: 2px 6px; border-radius: 4px; font-size: 0.7rem;">üìç ${geohash}</span>`).join('')}
                        </div>
                    </div>
                `;
            }

            getNoteType(note) {
                // All notes are Kind 1 (text notes)
                return '';
            }

            processHashtags(content) {
                // Create a mapping of hashtags to circle slugs
                const hashtagToCircleMap = {
                    'hitchhiking': 'hitchhikers',
                    'hitchhikers': 'hitchhikers',
                    'hitchwiki': 'hitchhikers',
                    'dumpster': 'dumpster-divers',
                    'dumpsterdiving': 'dumpster-divers',
                    'family': 'families',
                    'families': 'families',
                    'kids': 'families',
                    'music': 'musicians',
                    'musicians': 'musicians',
                    'busking': 'buskers',
                    'buskers': 'buskers',
                    'vegan': 'veg',
                    'vegetarian': 'veg',
                    'veg': 'veg',
                    'hacker': 'hackers',
                    'hackers': 'hackers',
                    'coding': 'hackers',
                    'lgbtq': 'lgbtq',
                    'lgbt': 'lgbtq',
                    'eco': 'ecoliving',
                    'ecoliving': 'ecoliving',
                    'sustainable': 'ecoliving',
                    'lindy': 'lindyhoppers',
                    'lindyhop': 'lindyhoppers',
                    'swing': 'lindyhoppers',
                    'dance': 'lindyhoppers',
                    'nomad': 'nomads',
                    'nomads': 'nomads',
                    'travel': 'nomads',
                    'punk': 'punks',
                    'punks': 'punks',
                    'cycling': 'cyclists',
                    'cyclists': 'cyclists',
                    'bike': 'cyclists',
                    'foodsharing': 'foodsharing',
                    'foodsharing': 'foodsharing',
                    'yoga': 'yoga',
                    'climbing': 'climbers',
                    'climbers': 'climbers',
                    'hiking': 'hikers',
                    'hikers': 'hikers',
                    'sailing': 'sailors',
                    'sailors': 'sailors',
                    'art': 'artists',
                    'artists': 'artists',
                    'creative': 'artists'
                };

                // Replace hashtags with clickable links
                return content.replace(/#([a-zA-Z0-9_]+)/g, (match, hashtag) => {
                    const circleSlug = hashtagToCircleMap[hashtag.toLowerCase()];
                    if (circleSlug) {
                        return `<a href="#" class="hashtag-link" data-circle="${circleSlug}" data-hashtag="${hashtag}">#${hashtag}</a>`;
                    } else {
                        return `<a href="#" class="hashtag-link" data-hashtag="${hashtag}">#${hashtag}</a>`;
                    }
                });
            }

            renderFallbackNote(note, timeString, relativeTime) {
                const profile = this.userProfiles[note.pubkey];
                const username = this.formatUsernameWithDiscriminator(profile, note.pubkey);
                
                // Process hashtags in fallback note content
                const content = this.escapeHtml(note.content || 'No content');
                const processedContent = this.processHashtags(content);
                
                return `
                    <div class="note-header">
                        <span class="note-username" style="font-weight: 600; font-size: 0.75rem;">${username}</span>
                    </div>
                    <div class="note-time" title="Click to view raw Nostr data: ${timeString}" data-note-id="${note.id}" style="font-size: 0.5rem; color: var(--text-muted); text-align: right; margin-bottom: 4px;">${relativeTime}</div>
                    <div class="note-content">${processedContent}</div>
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 8px;">
                        <div style="display: flex; gap: 8px;">
                            <span style="background: #e9ecef; color: #6c757d; padding: 2px 6px; border-radius: 4px; font-size: 0.7rem;">Kind ${note.kind || 'Unknown'}</span>
                        </div>
                    </div>
                `;
            }


            formatTime(date) {
                return date.toLocaleString('en-CA', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: false
                });
            }

            getRelativeTime(date) {
                const now = new Date();
                const diffInSeconds = Math.floor((now - date) / 1000);
                
                if (diffInSeconds < 60) return 'just now';
                if (diffInSeconds < 3600) return `${Math.floor(diffInSeconds / 60)}m ago`;
                if (diffInSeconds < 86400) return `${Math.floor(diffInSeconds / 3600)}h ago`;
                if (diffInSeconds < 2592000) return `${Math.floor(diffInSeconds / 86400)}d ago`;
                
                return date.toLocaleDateString();
            }

            extractGeoLocation(note) {
                let lat = null;
                let lng = null;
                let location = null;
                
                if (note.tags) {
                    for (const tag of note.tags) {
                        if (tag[0] === 'g' && tag[1]) {
                            const coordMatch = tag[1].match(/^(-?\d+\.?\d*),(-?\d+\.?\d*)$/);
                            if (coordMatch) {
                                lat = parseFloat(coordMatch[1]);
                                lng = parseFloat(coordMatch[2]);
                                location = `Coordinates: ${tag[1]}`;
                                break;
                            }
                            
                            if (this.isGeohash(tag[1])) {
                                const coords = this.geohashToLatLng(tag[1]);
                                if (coords) {
                                    lat = coords.lat;
                                    lng = coords.lng;
                                    location = `Geohash: ${tag[1]}`;
                                    break;
                                }
                            }
                        }
                    }
                }
                
                if (lat && lng && lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180) {
                    return { lat, lng, location: location || `${lat.toFixed(4)}, ${lng.toFixed(4)}` };
                }
                
                return null;
            }

            isGeohash(str) {
                return /^[0-9b-hj-km-np-z]+$/.test(str) && str.length >= 1 && str.length <= 12;
            }

            geohashToLatLng(geohash) {
                try {
                    const base32 = "0123456789bcdefghjkmnpqrstuvwxyz";
                    let isEven = true;
                    let lat = [-90, 90];
                    let lng = [-180, 180];
                    
                    for (let i = 0; i < geohash.length; i++) {
                        const char = geohash[i];
                        const bits = base32.indexOf(char);
                        
                        for (let j = 4; j >= 0; j--) {
                            const bit = (bits >> j) & 1;
                            
                            if (isEven) {
                                const mid = (lng[0] + lng[1]) / 2;
                                if (bit) {
                                    lng[0] = mid;
                                } else {
                                    lng[1] = mid;
                                }
                            } else {
                                const mid = (lat[0] + lat[1]) / 2;
                                if (bit) {
                                    lat[0] = mid;
                                } else {
                                    lat[1] = mid;
                                }
                            }
                            
                            isEven = !isEven;
                        }
                    }
                    
                    return {
                        lat: (lat[0] + lat[1]) / 2,
                        lng: (lng[0] + lng[1]) / 2
                    };
                } catch (e) {
                    console.warn('Error decoding geohash:', geohash, e);
                    return null;
                }
            }

            geohashToBounds(geohash) {
                try {
                    const base32 = "0123456789bcdefghjkmnpqrstuvwxyz";
                    let isEven = true;
                    let lat = [-90, 90];
                    let lng = [-180, 180];
                    
                    for (let i = 0; i < geohash.length; i++) {
                        const char = geohash[i];
                        const bits = base32.indexOf(char);
                        
                        for (let j = 4; j >= 0; j--) {
                            const bit = (bits >> j) & 1;
                            
                            if (isEven) {
                                const mid = (lng[0] + lng[1]) / 2;
                                if (bit) {
                                    lng[0] = mid;
                                } else {
                                    lng[1] = mid;
                                }
                            } else {
                                const mid = (lat[0] + lat[1]) / 2;
                                if (bit) {
                                    lat[0] = mid;
                                } else {
                                    lat[1] = mid;
                                }
                            }
                            
                            isEven = !isEven;
                        }
                    }
                    
                    return {
                        north: lat[1],
                        south: lat[0],
                        east: lng[1],
                        west: lng[0]
                    };
                } catch (e) {
                    console.warn('Error calculating geohash bounds:', geohash, e);
                    return null;
                }
            }

            plotActivitiesOnMap(notes) {
                this.mapMarkers.forEach(marker => this.map.removeLayer(marker));
                this.mapMarkers = [];
                
                // Clear existing geohash rectangles
                this.geohashRectangles.forEach(rect => this.map.removeLayer(rect));
                this.geohashRectangles = [];
                
                const geoActivities = [];
                const filteredActivities = this.getFilteredActivities();
                
                // Collect unique geohashes from filtered notes
                const uniqueGeohashes = new Set();
                
                filteredActivities.forEach(note => {
                    const geo = this.extractGeoLocation(note);
                    if (geo) {
                        geoActivities.push({ note, geo });
                        // Found geo note
                        
                        // Extract geohash from tags
                        if (note.tags) {
                            note.tags.forEach(tag => {
                                if (tag[0] === 'g' && tag[1] && this.isGeohash(tag[1])) {
                                    uniqueGeohashes.add(tag[1]);
                                }
                            });
                        }
                    }
                });
                
                // Processed geo-location data
                
                // Plot geohash rectangles
                this.plotGeohashRectangles(Array.from(uniqueGeohashes));
                
                if (geoActivities.length === 0) {
                    return;
                }
                
                geoActivities.forEach(({ note, geo }, index) => {
                    const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
                    const marker = L.circleMarker([geo.lat, geo.lng], {
                        radius: 8,
                        fillColor: isDark ? '#58a6ff' : '#27ae60',
                        color: '#ffffff',
                        weight: 2,
                        opacity: 1,
                        fillOpacity: 0.8,
                        className: 'tripchat-marker'
                    });
                    
                    const noteType = this.getNoteType(note);
                    const profile = this.userProfiles[note.pubkey];
                    const username = this.formatUsernameWithDiscriminator(profile, note.pubkey);
                    
                    // Extract geohash from note tags for clickable link
                    let geohashLink = '';
                    if (note.tags) {
                        const geohashTag = note.tags.find(tag => tag[0] === 'g' && tag[1] && this.isGeohash(tag[1]));
                        if (geohashTag) {
                            geohashLink = `<div class="popup-location" style="cursor: pointer; color: #8B5CF6; font-weight: 600;" onclick="window.tripchatVisualizer.filterByGeohash('${geohashTag[1]}')">üìç #${geohashTag[1]}</div>`;
                        }
                    }
                    
                    if (!geohashLink) {
                        geohashLink = `<div class="popup-location">üìç ${geo.location}</div>`;
                    }
                    
                    const popupContent = `
                        <div class="map-popup">
                            <div class="note-title">@${username}</div>
                            <div class="popup-content">${this.processHashtags(this.escapeHtml(note.content?.substring(0, 100) || 'No content'))}${note.content?.length > 100 ? '...' : ''}</div>
                            <div class="popup-time">${this.getRelativeTime(new Date(note.created_at * 1000))}</div>
                            ${geohashLink}
                        </div>
                    `;
                    
                    marker.bindPopup(popupContent);
                    marker.addTo(this.map);
                    this.mapMarkers.push(marker);
                });
                
                // Plotted geo-located notes on map
            }

            plotGeohashRectangles(geohashes) {
                const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
                geohashes.forEach(geohash => {
                    const bounds = this.geohashToBounds(geohash);
                    if (bounds) {
                        const rectangle = L.rectangle([
                            [bounds.south, bounds.west],
                            [bounds.north, bounds.east]
                        ], {
                            color: isDark ? '#58a6ff' : '#27ae60',
                            fillColor: isDark ? '#58a6ff' : '#27ae60',
                            fillOpacity: 0.1,
                            weight: 2,
                            opacity: 0.6,
                            className: 'geohash-rectangle'
                        });
                        
                        // Add popup with geohash info
                        const popupContent = `
                            <div class="map-popup">
                                <div class="note-title">Geohash Area</div>
                                <div class="popup-content"><strong>${geohash}</strong></div>
                                <div class="popup-location">
                                    Bounds: ${bounds.south.toFixed(4)}, ${bounds.west.toFixed(4)} to ${bounds.north.toFixed(4)}, ${bounds.east.toFixed(4)}
                                </div>
                            </div>
                        `;
                        
                        rectangle.bindPopup(popupContent);
                        rectangle.addTo(this.map);
                        this.geohashRectangles.push(rectangle);
                        
                        // Plotted geohash rectangle
                    }
                });
            }

            highlightGeohashArea(geohash) {
                // Clear existing geohash rectangles
                this.geohashRectangles.forEach(rect => this.map.removeLayer(rect));
                this.geohashRectangles = [];
                
                const bounds = this.geohashToBounds(geohash);
                if (bounds) {
                    const rectangle = L.rectangle([
                        [bounds.south, bounds.west],
                        [bounds.north, bounds.east]
                    ], {
                        color: '#3498db',
                        fillColor: '#3498db',
                        fillOpacity: 0.2,
                        weight: 3,
                        opacity: 0.8,
                        className: 'geohash-highlight'
                    });
                    
                    // Add popup with geohash info
                    const popupContent = `
                        <div class="map-popup">
                            <div class="note-title">Filtered Geohash Area</div>
                            <div class="popup-content"><strong>${geohash}</strong></div>
                            <div class="popup-location">
                                Bounds: ${bounds.south.toFixed(4)}, ${bounds.west.toFixed(4)} to ${bounds.north.toFixed(4)}, ${bounds.east.toFixed(4)}
                            </div>
                        </div>
                    `;
                    
                    rectangle.bindPopup(popupContent);
                    rectangle.addTo(this.map);
                    this.geohashRectangles.push(rectangle);
                    
                    // Fit map to the geohash area
                    this.map.fitBounds([
                        [bounds.south, bounds.west],
                        [bounds.north, bounds.east]
                    ], { padding: [20, 20] });
                    
                    console.log(`Highlighted geohash area for ${geohash}:`, bounds);
                }
            }

            zoomToShowAllActivities() {
                // Clear any highlighted geohash rectangles
                this.geohashRectangles.forEach(rect => this.map.removeLayer(rect));
                this.geohashRectangles = [];
                
                // Get all notes with geo data
                const geoActivities = [];
                this.notes.forEach(note => {
                    const geo = this.extractGeoLocation(note);
                    if (geo) {
                        geoActivities.push([geo.lat, geo.lng]);
                    }
                });
                
                if (geoActivities.length > 0) {
                    // Create a group of all markers to get bounds
                    const group = new L.featureGroup();
                    geoActivities.forEach(coord => {
                        group.addLayer(L.marker(coord));
                    });
                    
                    // Fit the map to show all notes
                    this.map.fitBounds(group.getBounds().pad(0.1), { 
                        padding: [20, 20],
                        maxZoom: 10 // Don't zoom in too much when showing all notes
                    });
                    
                    console.log(`Zoomed to show all ${geoActivities.length} notes`);
                } else {
                    // If no geo notes, zoom to world view
                    this.map.setView([0, 0], 2);
                    console.log('No geo notes found, zoomed to world view');
                }
            }

            zoomToGlobal() {
                // Clear any highlighted geohash rectangles
                this.geohashRectangles.forEach(rect => this.map.removeLayer(rect));
                this.geohashRectangles = [];
                
                // Always zoom to global view regardless of notes
                if (this.map) {
                    // Use a small delay to ensure map is ready
                    setTimeout(() => {
                        this.map.setView([0, 0], 1);
                        console.log('Zoomed to global view - center: [0, 0], zoom: 1');
                    }, 100);
                } else {
                    console.error('Map not initialized when trying to zoom to global');
                }
            }

            filterByGeohash(geohash) {
                // Set the filter
                this.searchFilter = geohash.toLowerCase();
                const searchFilterInput = document.getElementById('searchFilter');
                if (searchFilterInput) {
                    searchFilterInput.value = geohash;
                }
                
                // Update URL hash
                this.updateHash();
                
                // Update display and map
                this.displayActivities(this.notes);
                this.plotActivitiesOnMap(this.notes);
                
                // Highlight the geohash area on map
                if (this.isGeohash(this.geohashFilter)) {
                    this.highlightGeohashArea(this.geohashFilter);
                }
                
                
                console.log(`Filtered by geohash: ${geohash}`);
            }

            // Compose functionality
            clearComposeForm() {
                document.getElementById('composeContent').value = '';
            }

            // Save keys to localStorage
            saveKeysToStorage(nsecKey, npubKey, privateKeyHex) {
                try {
                    localStorage.setItem('tripchat_nsec', nsecKey);
                    localStorage.setItem('tripchat_npub', npubKey);
                    localStorage.setItem('tripchat_private_key', privateKeyHex);
                    console.log('Keys saved to localStorage');
                } catch (error) {
                    console.error('Failed to save keys to localStorage:', error);
                }
            }

            // Load keys from localStorage
            loadKeysFromStorage() {
                try {
                    const nsecKey = localStorage.getItem('tripchat_nsec');
                    const npubKey = localStorage.getItem('tripchat_npub');
                    const privateKeyHex = localStorage.getItem('tripchat_private_key');
                    
                    // Check if we have nsec/npub keys (preferred)
                    if (nsecKey && npubKey) {
                        // Load keys into settings modal if elements exist
                        const settingsPrivateKey = document.getElementById('settingsPrivateKey');
                        const settingsPublicKey = document.getElementById('settingsPublicKey');
                        
                        if (settingsPrivateKey) {
                            settingsPrivateKey.value = nsecKey;
                        }
                        if (settingsPublicKey) {
                            settingsPublicKey.value = npubKey;
                        }
                        
                        // Use nsec key directly for signing
                        this.privateKey = nsecKey;
                        console.log('Keys loaded from localStorage (nsec/npub format)');
                        return true;
                    }
                    // Fallback to hex format
                    else if (nsecKey && npubKey && privateKeyHex) {
                        // Load keys into settings modal if elements exist
                        const settingsPrivateKey = document.getElementById('settingsPrivateKey');
                        const settingsPublicKey = document.getElementById('settingsPublicKey');
                        
                        if (settingsPrivateKey) {
                            settingsPrivateKey.value = nsecKey;
                        }
                        if (settingsPublicKey) {
                            settingsPublicKey.value = npubKey;
                        }
                        
                        this.privateKey = privateKeyHex;
                        console.log('Keys loaded from localStorage (hex format)');
                        return true;
                    }
                } catch (error) {
                    console.error('Failed to load keys from localStorage:', error);
                }
                return false;
            }

            // Clear keys from localStorage
            clearKeysFromStorage() {
                try {
                    localStorage.removeItem('tripchat_nsec');
                    localStorage.removeItem('tripchat_npub');
                    localStorage.removeItem('tripchat_private_key');
                    console.log('Keys cleared from localStorage');

                    const settingsPrivateKey = document.getElementById('settingsPrivateKey');
                    const settingsPublicKey = document.getElementById('settingsPublicKey');
                    if (settingsPrivateKey) {
                        settingsPrivateKey.value = '';
                    }
                    if (settingsPublicKey) {
                        settingsPublicKey.value = '';
                    }

                    const settingsPrivateKeyHint = document.getElementById('settingsPrivateKeyHint');
                    if (settingsPrivateKeyHint) {
                        settingsPrivateKeyHint.style.display = 'none';
                        settingsPrivateKeyHint.innerHTML = '';
                    }

                    const verificationStatus = document.getElementById('verificationStatus');
                    if (verificationStatus) {
                        verificationStatus.textContent = 'Add or generate keys to verify your Trustroots username.';
                        verificationStatus.style.color = '#6c757d';
                    }

                    this.updateKeySetupPrompt();
                    this.toggleKeyButtonsVisibility();
                    this.highlightKeyInputs();
                } catch (error) {
                    console.error('Failed to clear keys from localStorage:', error);
                }
            }


            async getCurrentLocation() {
                if (!navigator.geolocation) {
                    alert('Geolocation is not supported by this browser.');
                    return;
                }

                try {
                    const position = await new Promise((resolve, reject) => {
                        navigator.geolocation.getCurrentPosition(resolve, reject);
                    });

                    const lat = position.coords.latitude;
                    const lng = position.coords.longitude;
                    const geohash = ngeohash.encode(lat, lng, 6); // 6 character precision
                    
                    document.getElementById('composeLocation').value = geohash;
                    console.log(`Location detected: ${lat}, ${lng} -> ${geohash}`);
                } catch (error) {
                    console.error('Error getting location:', error);
                    alert('Could not get your location. Please enter it manually.');
                }
            }


            generateFallbackKey() {
                // Simple fallback key generation using crypto.getRandomValues
                const array = new Uint8Array(32);
                crypto.getRandomValues(array);
                return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
            }

            generateKeyPair() {
                try {
                    // Check if nostr-tools is available
                    if (typeof window.nostrTools === 'undefined') {
                        throw new Error('nostr-tools library not loaded');
                    }

                    // Generate a new private key using nostr-tools
                    const privateKey = window.nostrTools.generatePrivateKey();
                    const publicKey = window.nostrTools.getPublicKey(privateKey);
                    
                    // Convert to nsec and npub formats
                    const nsecKey = window.nostrTools.nip19.nsecEncode(privateKey);
                    const npubKey = window.nostrTools.nip19.npubEncode(publicKey);
                    
                    return { nsecKey, npubKey };
                } catch (error) {
                    console.error('Error generating key pair:', error);
                    // Fallback to simple key generation
                    try {
                        const privateKeyHex = this.generateFallbackKey();
                        const nsecKey = this.hexToNsec(privateKeyHex);
                        const npubKey = this.deriveNpubFromPrivateKey(privateKeyHex);
                        return { nsecKey, npubKey };
                    } catch (fallbackError) {
                        console.error('Fallback key generation failed:', fallbackError);
                        throw new Error('Failed to generate keys. Please try again.');
                    }
                }
            }

            // Derive hex public key from private key
            deriveHexPubkeyFromPrivateKey(privateKey) {
                if (typeof window.nostrTools !== 'undefined') {
                    try {
                        // Convert nsec to hex if needed
                        let hexPrivateKey = privateKey;
                        if (privateKey.startsWith('nsec')) {
                            hexPrivateKey = window.nostrTools.nip19.nsecDecode(privateKey);
                        }
                        
                        // Get public key from private key
                        const publicKey = window.nostrTools.getPublicKey(hexPrivateKey);
                        return publicKey;
                    } catch (error) {
                        console.error('Error deriving hex public key:', error);
                        // Fallback to simple hash
                        return this.simpleHash(privateKey).substring(0, 64);
                    }
                } else {
                    // Fallback method
                    return this.simpleHash(privateKey).substring(0, 64);
                }
            }

            deriveNpubFromPrivateKey(privateKeyHex) {
                try {
                    // Check if nostr-tools is available
                    if (typeof window.nostrTools !== 'undefined') {
                        const publicKey = window.nostrTools.getPublicKey(privateKeyHex);
                        return window.nostrTools.nip19.npubEncode(publicKey);
                    } else {
                        // Fallback: simple npub generation
                        return this.generateNpubFallback(privateKeyHex);
                    }
                } catch (error) {
                    console.error('Error deriving npub:', error);
                    // Fallback to simple method
                    return this.generateNpubFallback(privateKeyHex);
                }
            }

            async updateTrustrootsProfile(npub) {
                try {
                    // Based on nostroots project research, try Trustroots API endpoints
                    const endpoints = [
                        'https://trustroots.org/api/v1/users/me',
                        'https://trustroots.org/api/users/me',
                        'https://trustroots.org/api/profile',
                        'https://trustroots.org/api/user/profile',
                        'https://api.trustroots.org/v1/users/me',
                        'https://api.trustroots.org/users/me'
                    ];

                    // Get saved username if available
                    const savedUsername = localStorage.getItem('tripchat_trustroots_username');
                    
                    const profileData = {
                        publicKey: npub,
                        nostr: npub,
                        npub: npub,
                        nostrPublicKey: npub,
                        // Include other common profile fields
                        updatedAt: new Date().toISOString(),
                        source: 'tripchat'
                    };
                    
                    // Add username if available
                    if (savedUsername) {
                        profileData.username = savedUsername;
                        profileData.displayName = savedUsername;
                    }

                    // Try each endpoint
                    for (const endpoint of endpoints) {
                        try {
                            console.log(`Trying to update profile via ${endpoint}`);
                            
                            const response = await fetch(endpoint, {
                                method: 'PUT',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'Accept': 'application/json',
                                    // Add common authentication headers
                                    'X-Requested-With': 'XMLHttpRequest'
                                },
                                body: JSON.stringify(profileData),
                                mode: 'cors'
                            });

                            if (response.ok) {
                                console.log(`Successfully updated profile via ${endpoint}`);
                                return true;
                            } else if (response.status === 401) {
                                console.log(`Authentication required for ${endpoint}`);
                                // Continue to next endpoint
                            } else if (response.status === 404) {
                                console.log(`Endpoint not found: ${endpoint}`);
                                // Continue to next endpoint
                            } else {
                                console.log(`Failed to update via ${endpoint}: ${response.status}`);
                            }
                        } catch (endpointError) {
                            console.log(`Error with endpoint ${endpoint}:`, endpointError.message);
                            // Continue to next endpoint
                        }
                    }

                    // If all endpoints failed, try a POST request as fallback
                    for (const endpoint of endpoints) {
                        try {
                            const response = await fetch(endpoint, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'Accept': 'application/json',
                                    'X-Requested-With': 'XMLHttpRequest'
                                },
                                body: JSON.stringify(profileData),
                                mode: 'cors'
                            });

                            if (response.ok) {
                                console.log(`Successfully updated profile via POST to ${endpoint}`);
                                return true;
                            }
                        } catch (postError) {
                            console.log(`POST failed for ${endpoint}:`, postError.message);
                        }
                    }

                    console.log('All Trustroots API endpoints failed');
                    
                    // Fallback: Open Trustroots profile edit page for manual update
                    // This is similar to what the nostroots project does
                    const profileEditUrl = savedUsername ? 
                        `https://trustroots.org/${savedUsername}/edit/networks` : 
                        'https://trustroots.org/profile/edit/networks';
                    
                    const usernameInfo = savedUsername ? `\nYour Trustroots username: ${savedUsername}` : '';
                    const confirmManual = confirm(
                        'Automatic profile update failed. Would you like to open your Trustroots profile edit page to manually add your npub?\n\n' +
                        `Your npub: ${npub}${usernameInfo}\n\n` +
                        'Click OK to open the profile edit page, then paste your npub in the appropriate field.'
                    );
                    
                    if (confirmManual) {
                        window.open(profileEditUrl, '_blank');
                        return false; // Indicate manual update needed
                    }
                    
                    return false;

                } catch (error) {
                    console.error('Error updating Trustroots profile:', error);
                    return false;
                }
            }

            // Convert hex private key to nsec format
            hexToNsec(hexKey) {
                // Remove '0x' prefix if present
                const cleanHex = hexKey.replace(/^0x/, '');
                
                // Convert hex to bytes
                const bytes = new Uint8Array(cleanHex.length / 2);
                for (let i = 0; i < cleanHex.length; i += 2) {
                    bytes[i / 2] = parseInt(cleanHex.substr(i, 2), 16);
                }
                
                // Use a simple base32-like encoding for now
                // This is not proper bech32 but will work for display purposes
                const base32Chars = 'abcdefghijklmnopqrstuvwxyz234567';
                let result = 'nsec1';
                
                for (let i = 0; i < bytes.length; i += 5) {
                    let value = 0;
                    for (let j = 0; j < 5 && i + j < bytes.length; j++) {
                        value = (value << 8) | bytes[i + j];
                    }
                    
                    for (let k = 0; k < 8; k++) {
                        result += base32Chars[(value >> (35 - k * 5)) & 31];
                    }
                }
                
                return result;
            }

            // Convert nsec format back to hex
            nsecToHex(nsecKey) {
                try {
                    // Use nostr-tools if available
                    if (typeof window.nostrTools !== 'undefined') {
                        // Use nip19 for bech32 decoding
                        const decoded = window.nostrTools.nip19.decode(nsecKey);
                        if (decoded.type === 'nsec') {
                            return decoded.data;
                        } else {
                            throw new Error('Invalid nsec format');
                        }
                    }
                    
                    // Fallback method
                    if (nsecKey.startsWith('nsec1')) {
                        // For now, just remove the prefix and assume it's hex
                        // In a real implementation, you'd decode the base32 properly
                        return nsecKey.substring(5);
                    } else if (nsecKey.length === 64) {
                        // If it's 64 characters, assume it's already hex
                        return nsecKey;
                    } else {
                        throw new Error('Invalid nsec format');
                    }
                } catch (error) {
                    console.error('Error converting nsec to hex:', error);
                    throw new Error('Invalid nsec format');
                }
            }

            // Generate npub from private key
            async generateNpub(privateKeyHex) {
                try {
                    // Use nostr-tools if available
                    if (typeof window.nostrTools !== 'undefined') {
                        const publicKey = window.nostrTools.getPublicKey(privateKeyHex);
                        
                        // Use nip19 for npub encoding
                        return window.nostrTools.nip19.npubEncode(publicKey);
                    }
                    
                    // Fallback method
                    console.log('nostr-tools not available, using fallback method');
                    return this.generateNpubFallback(privateKeyHex);
                } catch (error) {
                    console.error('Error generating npub:', error);
                    console.log('Falling back to simple method');
                    return this.generateNpubFallback(privateKeyHex);
                }
            }

            // Fallback npub generation (simplified)
            generateNpubFallback(privateKeyHex) {
                // Create a deterministic but fake public key from the private key
                // This is not cryptographically correct but looks realistic
                const hash = this.simpleHash(privateKeyHex);
                const publicKeyHex = hash.substring(0, 64);
                return this.hexToNpub(publicKeyHex);
            }

            // Simple hash function for generating fake public keys
            simpleHash(input) {
                let hash = '';
                for (let i = 0; i < input.length; i++) {
                    const char = input.charCodeAt(i);
                    hash += ((char * 31) % 16).toString(16);
                }
                // Pad to 64 characters
                while (hash.length < 64) {
                    hash += ((hash.length * 7) % 16).toString(16);
                }
                return hash.substring(0, 64);
            }

            // Generate a short discriminator from pubkey
            generateDiscriminator(pubkey) {
                if (!pubkey) return '';
                
                // Take the last 4 characters of the pubkey and convert to a shorter format
                const lastFour = pubkey.slice(-4);
                
                // Convert hex to a more readable format (0-9, a-f -> 0-9, a-z)
                let discriminator = '';
                for (let i = 0; i < lastFour.length; i += 2) {
                    const hexPair = lastFour.substr(i, 2);
                    const num = parseInt(hexPair, 16);
                    // Map to a smaller character set (0-9, a-z)
                    discriminator += (num % 36).toString(36);
                }
                
                return discriminator;
            }

            // Format username with discriminator
            // Discriminators (#p6, #a1, etc.) are used by some Nostr clients to handle username conflicts
            // NIP-05 names are prioritized as they are cryptographically verified and more stable
            formatUsernameWithDiscriminator(profile, pubkey) {
                let username;
                
                // Priority 1: Use NIP-05 name if available (most trustworthy)
                if (profile && profile.nip05) {
                    const isTrustrootsVerified = profile.nip05.endsWith('@trustroots.org');
                    const isHitchwikiVerified = profile.nip05.endsWith('@hitchwiki.org');
                    const fullNpub = this.hexToNpub(pubkey);
                    
                    if (isTrustrootsVerified) {
                        const usernamePart = profile.nip05.split('@')[0];
                        username = `<a href="https://trustroots.org/profile/${usernamePart}" target="_blank" rel="noopener noreferrer" title="${fullNpub}">@${profile.nip05} üü¢</a>`;
                    } else if (isHitchwikiVerified) {
                        const usernamePart = profile.nip05.split('@')[0];
                        const hitchwikiUrl = profile.website && profile.website.includes('hitchwiki.org') 
                            ? profile.website 
                            : `https://hitchwiki.org/en/User:${usernamePart}`;
                        username = `<a href="${hitchwikiUrl}" target="_blank" rel="noopener noreferrer" title="${fullNpub}">@${profile.nip05} üü¢</a>`;
                    } else if (profile.nip05.includes('@')) {
                        username = `<span title="${fullNpub}">@${profile.nip05} üîµ</span>`;
                    } else {
                        // Fallback to profile name if NIP-05 exists but is malformed
                        username = profile.name || 'Unknown';
                    }
                }
                // Priority 2: Use profile name with discriminator if no NIP-05
                else if (profile && profile.name) {
                    // Check if the name already has a discriminator
                    if (profile.name.includes('#')) {
                        username = profile.name;
                    } else {
                        // Add discriminator if it doesn't exist
                        const discriminator = this.generateDiscriminator(pubkey);
                        username = `${profile.name}#${discriminator}`;
                    }
                }
                // Priority 3: Fallback to npub
                else {
                    // Show first 10 characters of npub without @
                    username = pubkey ? this.hexToNpub(pubkey).substring(0, 10) : 'Unknown';
                }
                
                return username;
            }

            // Convert hex public key to npub format
            hexToNpub(hexKey) {
                try {
                    // Use nostr-tools if available
                    if (typeof window.nostrTools !== 'undefined' && window.nostrTools.nip19 && window.nostrTools.nip19.npubEncode) {
                        return window.nostrTools.nip19.npubEncode(hexKey);
                    }
                    
                    // Fallback: create a proper-looking npub format
                    const cleanHex = hexKey.replace(/^0x/, '');
                    
                    // Create a more realistic npub format
                    // This is not cryptographically correct but looks like a real npub
                    const base32Chars = 'abcdefghijklmnopqrstuvwxyz234567';
                    let result = 'npub1';
                    
                    // Convert hex to bytes
                    const bytes = [];
                    for (let i = 0; i < cleanHex.length; i += 2) {
                        bytes.push(parseInt(cleanHex.substr(i, 2), 16));
                    }
                    
                    // Simple base32 encoding
                    let bits = 0;
                    let value = 0;
                    for (let i = 0; i < bytes.length; i++) {
                        value = (value << 8) | bytes[i];
                        bits += 8;
                        
                        while (bits >= 5) {
                            result += base32Chars[(value >> (bits - 5)) & 31];
                            bits -= 5;
                        }
                    }
                    
                    if (bits > 0) {
                        result += base32Chars[(value << (5 - bits)) & 31];
                    }
                    
                    return result;
                    
                } catch (error) {
                    console.error('Error converting hex to npub:', error);
                    // Even simpler fallback
                    const cleanHex = hexKey.replace(/^0x/, '');
                    return `npub1${cleanHex.substring(0, 8)}...${cleanHex.substring(cleanHex.length - 8)}`;
                }
            }


            async postNote() {
                console.log('üöÄ Starting postNote process...');
                
                const content = document.getElementById('composeContent').value.trim();
                const geohash = document.getElementById('geohashFilter').value.trim();
                const privateKeyInput = localStorage.getItem('tripchat_nsec');
                const publicKeyInput = localStorage.getItem('tripchat_npub');

                console.log('üìù Post data:', { 
                    content: content.substring(0, 50) + (content.length > 50 ? '...' : ''),
                    geohash: geohash || 'none',
                    hasPrivateKey: !!privateKeyInput,
                    hasPublicKey: !!publicKeyInput
                });

                if (!content) {
                    console.log('‚ùå No content provided');
                    alert('Please enter a message.');
                    return;
                }

                // Extract hashtags from searchFilter and add them to content
                let finalContent = content;
                if (this.searchFilter) {
                    console.log('üîç Processing search filter for hashtags:', this.searchFilter);
                    const hashtagRegex = /#\w+/g;
                    const hashtags = this.searchFilter.match(hashtagRegex);
                    if (hashtags && hashtags.length > 0) {
                        console.log('üè∑Ô∏è Found hashtags in search filter:', hashtags);
                        // Add hashtags to content if they're not already there
                        const existingHashtags = content.match(hashtagRegex) || [];
                        const newHashtags = hashtags.filter(tag => !existingHashtags.includes(tag));
                        if (newHashtags.length > 0) {
                            finalContent = content + ' ' + newHashtags.join(' ');
                            console.log(`‚úÖ Added hashtags from search filter: ${newHashtags.join(' ')}`);
                        } else {
                            console.log('‚ÑπÔ∏è All hashtags already present in content');
                        }
                    }
                }

                // Geohash is optional - allow global posting
                // if (!geohash) {
                //     alert('Please enter a location (geohash).');
                //     return;
                // }

                if (!privateKeyInput || !publicKeyInput) {
                    console.log('‚ùå Missing keys for posting', {
                        hasPrivateKey: !!privateKeyInput,
                        hasPublicKey: !!publicKeyInput
                    });
                    this.openKeysDialog("Let's help you set up some keys before you post your note.");
                    return;
                }

                try {
                    console.log('üîê Processing private key...');
                    // Convert nsec to hex if needed
                    if (privateKeyInput.startsWith('nsec')) {
                        this.privateKey = this.nsecToHex(privateKeyInput);
                        console.log('üîë Converted nsec to hex private key');
                    } else {
                        this.privateKey = privateKeyInput;
                        console.log('üîë Using hex private key directly');
                    }
                    
                    // Get current persistence selection
                    const currentPersistence = document.getElementById('notePersistence')?.value;
                    console.log('‚è∞ Persistence setting:', currentPersistence);
                    
                    console.log('üì¶ Creating event with:', {
                        content: finalContent.substring(0, 50) + (finalContent.length > 50 ? '...' : ''),
                        geohash: geohash || 'none',
                        persistence: currentPersistence
                    });
                    
                    const event = await this.createBitchatEvent(finalContent, geohash, currentPersistence);
                    console.log('‚úÖ Event created successfully:', event.id);
                    
                    console.log('üì° Publishing event to relays...');
                    await this.publishEvent(event);
                    console.log('‚úÖ Event published successfully');
                    
                    // Auto-scroll to show the new post
                    console.log('üìú Auto-scrolling to show new post...');
                    setTimeout(() => {
                        this.scrollToBottom();
                    }, 500);
                    
                    // Clear the compose form after successful post
                    console.log('üßπ Clearing compose form...');
                    this.clearComposeForm();
                    console.log('üéâ Post completed successfully!');
                } catch (error) {
                    console.error('‚ùå Error posting note:', error);
                    console.error('Error details:', {
                        message: error.message,
                        stack: error.stack,
                        name: error.name
                    });
                    alert('Error posting note: ' + error.message);
                }
            }

            async createBitchatEvent(content, geohash, persistence = '1h') {
                if (!this.privateKey) {
                    throw new Error('No private key available');
                }

                const persistenceElement = document.getElementById('notePersistence');
                const persistenceOption = persistence || (persistenceElement ? persistenceElement.value : '1h');
                
                console.log('Creating Kind 1 event with persistence option:', persistenceOption);
                console.log('Selected persistence element value:', persistenceElement ? persistenceElement.value : 'element not found');
                console.log('Available options:', persistenceElement ? Array.from(persistenceElement.options).map(opt => `${opt.value}: ${opt.text}`) : 'element not found');
                
                // Always create Kind 1 events with expiration
                return this.createPersistentEvent(content, geohash, persistenceOption);
            }

            // New method for ephemeral events (current behavior)
            async createEphemeralEvent(content, geohash) {
                if (!this.privateKey) {
                    throw new Error('No private key available');
                }

                try {
                    // Get npub for NIP-05 verification
                    const npub = this.deriveNpubFromPrivateKey(this.privateKey);
                    
                    // Check for NIP-05 verification with caching
                    const savedUsername = localStorage.getItem('tripchat_trustroots_username');
                    let nip05Verified = false;
                    
                    if (savedUsername) {
                        // Check cache first
                        const cacheKey = `nip05_${savedUsername}`;
                        const cached = localStorage.getItem(cacheKey);
                        const cacheTime = localStorage.getItem(`${cacheKey}_time`);
                        const now = Date.now();
                        
                        // Use cache if less than 5 minutes old
                        if (cached && cacheTime && (now - parseInt(cacheTime)) < 300000) {
                            nip05Verified = cached === 'true';
                        } else {
                            try {
                                const verificationUrl = `https://trustroots.org/.well-known/nostr.json?name=${savedUsername}`;
                                const response = await fetch(verificationUrl, {
                                    method: 'GET',
                                    headers: {
                                        'Accept': 'application/json',
                                        'Cache-Control': 'no-cache'
                                    }
                                });
                                
                                if (response.ok) {
                                    const data = await response.json();
                                    
                                    if (data.names && data.names[savedUsername]) {
                                        const hexPubkey = data.names[savedUsername];
                                        let expectedNpub;
                                        
                                        if (typeof window.nostrTools !== 'undefined') {
                                            expectedNpub = window.nostrTools.nip19.npubEncode(hexPubkey);
                                        } else {
                                            expectedNpub = this.hexToNpub(hexPubkey);
                                        }
                                        
                                        nip05Verified = (expectedNpub === npub);
                                        
                                        // Cache the result
                                        localStorage.setItem(cacheKey, nip05Verified.toString());
                                        localStorage.setItem(`${cacheKey}_time`, now.toString());
                                    }
                                }
                            } catch (error) {
                                console.log('NIP-05 verification failed:', error);
                                // Use cached result if available, even if expired
                                if (cached) {
                                    nip05Verified = cached === 'true';
                                }
                            }
                        }
                    }
                    
                    // Use nostr-tools if available
                    if (typeof window.nostrTools !== 'undefined') {
                        const event = {
                            kind: 20000, // Ephemeral event for location channels
                            content: content,
                            tags: [
                                ['d', 'bitchat-location'], // Distinguishes from other location events
                                ['p', npub] // Add public key tag
                            ],
                            created_at: Math.floor(Date.now() / 1000)
                        };
                        
                        // Add geohash tag only if geohash is provided
                        if (geohash && geohash.trim()) {
                            event.tags.push(['g', geohash]);
                        }
                        
                        // Add NIP-05 verification tag if verified
                        if (nip05Verified) {
                            event.tags.push(['nip05', `${savedUsername}@trustroots.org`]);
                        }

                        console.log('üè∑Ô∏è Event tags (main):', event.tags);
                        
                        // Sign the event using nostr-tools
                        const signedEvent = window.nostrTools.finishEvent(event, this.privateKey);
                        return signedEvent;
                    }
                    
                    // Fallback method
                    console.log('nostr-tools not available, using fallback method');
                    const event = {
                        kind: 20000, // Ephemeral event for location channels
                        content: content,
                        tags: [
                            ['d', 'bitchat-location'], // Distinguishes from other location events
                            ['p', npub] // Add public key tag
                        ],
                        pubkey: this.generateFakePublicKey(this.privateKey),
                        created_at: Math.floor(Date.now() / 1000),
                        id: this.generateFakeEventId(content, geohash || 'global'),
                        sig: this.generateFakeSignature(this.privateKey, content)
                    };
                    
                    // Add geohash tag only if geohash is provided
                    if (geohash && geohash.trim()) {
                        event.tags.push(['g', geohash]);
                    }
                    
                    // Add NIP-05 verification tag if verified
                    if (nip05Verified) {
                        event.tags.push(['nip05', `${savedUsername}@trustroots.org`]);
                    }

                    console.log('üè∑Ô∏è Event tags (ephemeral):', event.tags);
                    return event;
                } catch (error) {
                    console.error('Error creating ephemeral event:', error);
                    throw new Error('Failed to create ephemeral event: ' + error.message);
                }
            }

            // New method for persistent events
            async createPersistentEvent(content, geohash, persistence) {
                if (!this.privateKey) {
                    throw new Error('No private key available');
                }

                console.log('createPersistentEvent called with persistence:', persistence);

                try {
                    const expirationHours = {
                        '1h': 1,
                        'short': 24,
                        'medium': 168, // 7 days
                        'long': 720, // 30 days
                        'permanent': null
                    };
                    
                    console.log('expirationHours mapping:', expirationHours);
                    console.log('Looking up persistence in mapping:', persistence, '->', expirationHours[persistence]);
                    
                    // Test the mapping
                    console.log('Test: "short" should map to 24 hours:', expirationHours['short']);
                    console.log('Test: "1h" should map to 1 hour:', expirationHours['1h']);
                    
                    // Get npub for NIP-05 verification
                    const npub = this.deriveNpubFromPrivateKey(this.privateKey);
                    
                    // Check for NIP-05 verification with caching
                    const savedUsername = localStorage.getItem('tripchat_trustroots_username');
                    let nip05Verified = false;
                    
                    if (savedUsername) {
                        // Check cache first
                        const cacheKey = `nip05_${savedUsername}`;
                        const cached = localStorage.getItem(cacheKey);
                        const cacheTime = localStorage.getItem(`${cacheKey}_time`);
                        const now = Date.now();
                        
                        // Use cache if less than 5 minutes old
                        if (cached && cacheTime && (now - parseInt(cacheTime)) < 300000) {
                            nip05Verified = cached === 'true';
                        } else {
                            try {
                                const verificationUrl = `https://trustroots.org/.well-known/nostr.json?name=${savedUsername}`;
                                const response = await fetch(verificationUrl, {
                                    method: 'GET',
                                    headers: {
                                        'Accept': 'application/json',
                                        'Cache-Control': 'no-cache'
                                    }
                                });
                                
                                if (response.ok) {
                                    const data = await response.json();
                                    
                                    if (data.names && data.names[savedUsername]) {
                                        const hexPubkey = data.names[savedUsername];
                                        let expectedNpub;
                                        
                                        if (typeof window.nostrTools !== 'undefined') {
                                            expectedNpub = window.nostrTools.nip19.npubEncode(hexPubkey);
                                        } else {
                                            expectedNpub = this.hexToNpub(hexPubkey);
                                        }
                                        
                                        nip05Verified = (expectedNpub === npub);
                                        
                                        // Cache the result
                                        localStorage.setItem(cacheKey, nip05Verified.toString());
                                        localStorage.setItem(`${cacheKey}_time`, now.toString());
                                    }
                                }
                            } catch (error) {
                                console.log('NIP-05 verification failed:', error);
                                // Use cached result if available, even if expired
                                if (cached) {
                                    nip05Verified = cached === 'true';
                                }
                            }
                        }
                    }
                    
                    // Use nostr-tools if available
                    if (typeof window.nostrTools !== 'undefined') {
                        // Get hex public key from private key
                        const hexPubkey = this.deriveHexPubkeyFromPrivateKey(this.privateKey);
                        
                        const event = {
                            kind: 1, // Standard text notes
                            pubkey: hexPubkey,
                            content: content,
                            tags: [
                                ['p', npub] // Add public key tag
                            ],
                            created_at: Math.floor(Date.now() / 1000)
                        };
                        
                        console.log('Creating Kind 1 event:', event);
                        
                        // Add geohash tag only if geohash is provided
                        if (geohash && geohash.trim()) {
                            event.tags.push(['g', geohash]);
                        }
                        
                        // Add expiration if not permanent
                        if (expirationHours[persistence]) {
                            const expiresAt = Math.floor(Date.now() / 1000) + (expirationHours[persistence] * 3600);
                            console.log(`Setting expiration: ${persistence} = ${expirationHours[persistence]} hours, expires_at: ${expiresAt}`);
                            event.tags.push(['expires_at', expiresAt.toString()]);
                            event.tags.push(['expiration', `${expirationHours[persistence]}h`]);
                        } else {
                            console.log(`No expiration set for persistence: ${persistence}`);
                        }
                        
                        // Add NIP-05 verification tag if verified
                        if (nip05Verified) {
                            event.tags.push(['nip05', `${savedUsername}@trustroots.org`]);
                        }

                        // Sign the event using nostr-tools
                        const signedEvent = window.nostrTools.finishEvent(event, this.privateKey);
                        return signedEvent;
                    }
                    
                    // Fallback method
                    console.log('nostr-tools not available, using fallback method');
                    const event = {
                        kind: 1, // Standard text notes
                        pubkey: this.generateFakePublicKey(this.privateKey),
                        content: content,
                        tags: [
                            ['p', npub] // Add public key tag
                        ],
                        created_at: Math.floor(Date.now() / 1000),
                        id: this.generateFakeEventId(content, geohash || 'global'),
                        sig: this.generateFakeSignature(this.privateKey, content)
                    };
                    
                    console.log('Creating Kind 1 event (fallback):', event);
                    
                    // Add geohash tag only if geohash is provided
                    if (geohash && geohash.trim()) {
                        event.tags.push(['g', geohash]);
                    }
                    
                    // Add expiration if not permanent
                    if (expirationHours[persistence]) {
                        const expiresAt = Math.floor(Date.now() / 1000) + (expirationHours[persistence] * 3600);
                        console.log(`Setting expiration (fallback): ${persistence} = ${expirationHours[persistence]} hours, expires_at: ${expiresAt}`);
                        event.tags.push(['expires_at', expiresAt.toString()]);
                        event.tags.push(['expiration', `${expirationHours[persistence]}h`]);
                    } else {
                        console.log(`No expiration set for persistence (fallback): ${persistence}`);
                    }
                    
                    // Add NIP-05 verification tag if verified
                    if (nip05Verified) {
                        event.tags.push(['nip05', `${savedUsername}@trustroots.org`]);
                    }

                    console.log('üè∑Ô∏è Event tags (persistent):', event.tags);
                    return event;
                } catch (error) {
                    console.error('Error creating persistent event:', error);
                    throw new Error('Failed to create persistent event: ' + error.message);
                }
            }

            // Generate a fake public key from private key
            generateFakePublicKey(privateKeyHex) {
                const hash = this.simpleHash(privateKeyHex);
                return hash.substring(0, 64);
            }

            // Generate a fake event ID
            generateFakeEventId(content, geohash) {
                const input = content + (geohash || 'profile') + Date.now();
                const hash = this.simpleHash(input);
                return hash.substring(0, 64);
            }

            // Generate a fake signature
            generateFakeSignature(privateKeyHex, content) {
                const input = privateKeyHex + content + Date.now();
                const hash = this.simpleHash(input);
                return hash.substring(0, 128); // Longer for signature
            }

            // Create and post kind 0 profile event
            async postProfileToNostr(username, npub) {
                try {
                    // Load private key from localStorage if not already loaded
                    if (!this.privateKey) {
                        const nsecKey = localStorage.getItem('tripchat_nsec');
                        if (!nsecKey) {
                            throw new Error('No private key available for signing');
                        }
                        this.privateKey = nsecKey;
                    }

                    // Create profile content
                    const profileContent = {
                        name: username,
                        about: `Traveler on Trustroots - ${username}`,
                        website: `https://trustroots.org/people/${username}`,
                        nip05: `${username}@trustroots.org`,
                        lud16: `${username}@trustroots.org`,
                        // Trustroots-specific fields
                        trustroots_username: username,
                        trustroots_profile: `https://trustroots.org/people/${username}`,
                        travel_preferences: "Hospitality exchange, hitchhiking, sustainable travel",
                        created_at: new Date().toISOString()
                    };

                    // Use nostr-tools if available
                    if (typeof window.nostrTools !== 'undefined') {
                        // Convert nsec to hex if needed
                        let privateKeyForSigning = this.privateKey;
                        if (this.privateKey.startsWith('nsec')) {
                            privateKeyForSigning = this.nsecToHex(this.privateKey);
                        }
                        const publicKeyHex = this.deriveHexPubkeyFromPrivateKey(privateKeyForSigning);
                        
                        const event = {
                            kind: 0, // Metadata event
                            pubkey: publicKeyHex,
                            content: JSON.stringify(profileContent),
                            tags: [
                                ['nip05', `${username}@trustroots.org`],
                                ['L', 'org.trustroots'],
                                ['l', username, 'org.trustroots']
                            ],
                            created_at: Math.floor(Date.now() / 1000)
                        };

                        const signedEvent = window.nostrTools.finishEvent(event, privateKeyForSigning);
                        signedEvent.pubkey = publicKeyHex;
                        console.log('üßæ Prepared profile event (nostr-tools path):', signedEvent);
                        
                        // Post to all enabled relays
                        const postingRelays = Object.keys(this.postingRelays).filter(url => this.postingRelays[url]);
                        console.log('üì® Posting profile to relays:', postingRelays);
                        const postPromises = postingRelays.map(relayUrl => this.postEventToRelay(relayUrl, signedEvent));
                        
                        const results = await Promise.allSettled(postPromises);
                        const successful = results.filter(r => r.status === 'fulfilled').length;
                        
                        console.log(`Profile posted to ${successful}/${postingRelays.length} relays`);
                        return successful > 0;
                    } else {
                        // Fallback method
                        console.log('nostr-tools not available, using fallback profile creation');
                        
                        // Convert nsec to hex if needed for fallback methods
                        let privateKeyForFallback = this.privateKey;
                        if (this.privateKey.startsWith('nsec')) {
                            privateKeyForFallback = this.nsecToHex(this.privateKey);
                        }
                        const publicKeyHex = this.deriveHexPubkeyFromPrivateKey(privateKeyForFallback);
                        
                        const event = {
                            kind: 0,
                            content: JSON.stringify(profileContent),
                            tags: [
                                ['nip05', `${username}@trustroots.org`],
                                ['L', 'org.trustroots'],
                                ['l', username, 'org.trustroots']
                            ],
                            pubkey: publicKeyHex,
                            created_at: Math.floor(Date.now() / 1000),
                            id: this.generateFakeEventId(JSON.stringify(profileContent), 'profile'),
                            sig: this.generateFakeSignature(privateKeyForFallback, JSON.stringify(profileContent))
                        };
                        console.log('üßæ Prepared profile event (fallback path):', event);
                        
                        // Post to all enabled relays
                        const postingRelays = Object.keys(this.postingRelays).filter(url => this.postingRelays[url]);
                        console.log('üì® Posting profile to relays (fallback):', postingRelays);
                        const postPromises = postingRelays.map(relayUrl => this.postEventToRelay(relayUrl, event));
                        
                        const results = await Promise.allSettled(postPromises);
                        const successful = results.filter(r => r.status === 'fulfilled').length;
                        
                        console.log(`Profile posted to ${successful}/${postingRelays.length} relays`);
                        return successful > 0;
                    }
                } catch (error) {
                    console.error('Error posting profile to Nostr:', error);
                    return false;
                }
            }

            // Post event to a specific relay
            async postEventToRelay(relayUrl, event) {
                return new Promise((resolve, reject) => {
                    if (!this.websockets[relayUrl] || this.websockets[relayUrl].readyState !== WebSocket.OPEN) {
                        reject(new Error(`Relay ${relayUrl} not connected`));
                        return;
                    }

                    const message = JSON.stringify(["EVENT", event]);
                    
                    const handleMessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            if (Array.isArray(data) && data.length >= 2) {
                                const [messageType, eventId, success, message] = data;
                                
                                if (messageType === 'OK' && eventId === event.id) {
                                    this.websockets[relayUrl].removeEventListener('message', handleMessage);
                                    if (success) {
                                        resolve(true);
                                    } else {
                                        reject(new Error(message || 'Event rejected by relay'));
                                    }
                                }
                            }
                        } catch (error) {
                            // Ignore parsing errors for other messages
                        }
                    };

                    this.websockets[relayUrl].addEventListener('message', handleMessage);
                    this.websockets[relayUrl].send(message);

                    // Timeout after 10 seconds
                    setTimeout(() => {
                        this.websockets[relayUrl].removeEventListener('message', handleMessage);
                        reject(new Error('Timeout posting to relay'));
                    }, 10000);
                });
            }

            async publishEvent(event) {
                console.log('üì° Starting event publication...');
                const postingRelays = this.relays.filter(relay => this.postingRelays[relay]);
                console.log('üåê Available posting relays:', postingRelays);
                
                if (postingRelays.length === 0) {
                    console.error('‚ùå No posting relays available');
                    throw new Error('No posting relays available');
                }

                const publishPromises = postingRelays.map(relayUrl => {
                    return new Promise((resolve, reject) => {
                        console.log(`üîó Attempting to publish to ${relayUrl}...`);
                        
                        if (!this.websockets[relayUrl] || this.websockets[relayUrl].readyState !== WebSocket.OPEN) {
                            console.error(`‚ùå Relay ${relayUrl} is not connected (state: ${this.websockets[relayUrl]?.readyState})`);
                            reject(new Error(`Relay ${relayUrl} is not connected`));
                            return;
                        }

                        const message = ["EVENT", event];
                        console.log(`üì§ Sending event to ${relayUrl}:`, {
                            eventId: event.id,
                            kind: event.kind,
                            contentLength: event.content?.length || 0
                        });
                        
                        try {
                            this.websockets[relayUrl].send(JSON.stringify(message));
                            console.log(`‚úÖ Successfully published event to ${relayUrl}`);
                            resolve();
                        } catch (error) {
                            console.error(`‚ùå Failed to publish to ${relayUrl}:`, error);
                            reject(error);
                        }
                    });
                });

                console.log('‚è≥ Waiting for all relay responses...');
                const results = await Promise.allSettled(publishPromises);
                
                const successful = results.filter(r => r.status === 'fulfilled').length;
                const failed = results.filter(r => r.status === 'rejected').length;
                
                console.log(`üìä Publication results: ${successful} successful, ${failed} failed`);
                
                if (failed > 0) {
                    console.warn('‚ö†Ô∏è Some relays failed to publish the event');
                    results.forEach((result, index) => {
                        if (result.status === 'rejected') {
                            console.error(`‚ùå ${postingRelays[index]}: ${result.reason}`);
                        }
                    });
                }
            }

            // Relay management functionality
            addRelay(url) {
                if (!this.relays.includes(url)) {
                    this.relays.push(url);
                    this.relayEnabled[url] = true;
                    this.postingRelays[url] = false; // New relays disabled for posting by default
                    this.relayStatus[url] = {
                        status: 'disconnected',
                        notesCount: 0,
                        lastSeen: null,
                        connectionTime: null
                    };
                    
                    // Save settings to localStorage
                    this.saveRelaySettings();
                    
                    // Connect to the new relay
                    this.connectToRelay(url);
                    console.log(`Added new relay: ${url}`);
                }
            }

            removeRelay(url) {
                const index = this.relays.indexOf(url);
                if (index > -1) {
                    this.relays.splice(index, 1);
                    delete this.relayEnabled[url];
                    delete this.postingRelays[url];
                    delete this.relayStatus[url];
                    
                    // Close WebSocket connection
                    if (this.websockets[url]) {
                        this.websockets[url].close();
                        delete this.websockets[url];
                    }
                    
                    // Save settings to localStorage
                    this.saveRelaySettings();
                    
                    // Update the relay list display
                    this.updateRelayList();
                    
                    console.log(`Removed relay: ${url}`);
                }
            }

            togglePostingRelay(url) {
                this.postingRelays[url] = !this.postingRelays[url];
                // Save settings to localStorage
                this.saveRelaySettings();
                // Update the display if compose modal is open
                this.updatePostingRelaysDisplay();
            }

            updatePostingRelaysDisplay() {
                const display = document.getElementById('postingRelaysDisplay');
                if (!display) return;

                const postingRelays = this.relays.filter(relay => this.postingRelays[relay]);
                
                if (postingRelays.length === 0) {
                    display.innerHTML = '<div class="posting-relay-item" style="background: #f8d7da; border-color: #dc3545; color: #dc3545;">‚ö†Ô∏è No posting relays enabled</div>';
                    return;
                }

                display.innerHTML = postingRelays.map(relayUrl => {
                    const relayName = relayUrl.replace('wss://', '').replace('.org', '').replace('.io', '').replace('.lol', '').replace('.social', '');
                    const status = this.relayStatus[relayUrl]?.status || 'disconnected';
                    const statusClass = status === 'connected' ? 'relay-connected' : 'relay-disconnected';
                    
                    return `
                        <div class="posting-relay-item">
                            <div class="relay-status-dot ${statusClass}"></div>
                            <span class="relay-name">${relayName}</span>
                        </div>
                    `;
                }).join('');
            }


            updateRelayList() {
                const relayList = document.getElementById('relayList');
                relayList.innerHTML = '';

                this.relays.forEach(relayUrl => {
                    const relayItem = document.createElement('div');
                    relayItem.className = 'relay-item-manager';
                    
                    const status = this.relayStatus[relayUrl]?.status || 'disconnected';
                    const isEnabled = this.relayEnabled[relayUrl];
                    const isPostingEnabled = this.postingRelays[relayUrl];
                    
                    relayItem.innerHTML = `
                        <div class="relay-info">
                            <div class="relay-status-dot relay-${status}"></div>
                            <div class="relay-url">${relayUrl}</div>
                        </div>
                        <div class="relay-controls">
                            <label class="post-toggle-label">
                                <input type="checkbox" ${isPostingEnabled ? 'checked' : ''} 
                                       onchange="window.tripchatVisualizer.togglePostingRelay('${relayUrl}')">
                                <span class="post-toggle-slider">
                                    <span class="post-toggle-text">Post</span>
                                </span>
                            </label>
                            <button class="relay-delete" data-relay-url="${relayUrl}">
                                DELETE
                            </button>
                        </div>
                    `;
                    
                    relayList.appendChild(relayItem);
                });

                // Add event listeners for delete buttons
                this.setupRelayDeleteHandlers();
            }

            setupRelayDeleteHandlers() {
                document.querySelectorAll('.relay-delete').forEach(button => {
                    button.addEventListener('click', (e) => {
                        const relayUrl = e.target.dataset.relayUrl;
                        if (relayUrl) {
                            this.removeRelay(relayUrl);
                        }
                    });
                });
            }

            showNoteDetailsModal(note) {
                // Create modal overlay
                const modalOverlay = document.createElement('div');
                modalOverlay.className = 'modal-overlay';
                modalOverlay.onclick = (e) => {
                    if (e.target === modalOverlay) {
                        document.body.removeChild(modalOverlay);
                    }
                };

                // Get user profile
                const profile = this.userProfiles[note.pubkey];
                const username = this.formatUsernameWithDiscriminator(profile, note.pubkey);
                

                // Format timestamp
                const timestamp = new Date(note.created_at * 1000);
                const timeString = timestamp.toLocaleString('en-CA', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: false
                });

                // Extract geohash tags
                const geohashTags = [];
                if (note.tags) {
                    note.tags.forEach(tag => {
                        if (tag[0] === 'g' && tag[1]) {
                            geohashTags.push(tag[1]);
                        }
                    });
                }

                // Create modal content
                const modalContent = document.createElement('div');
                modalContent.className = 'modal-content';
                modalContent.innerHTML = `
                    <div class="modal-header">
                        <h2 class="modal-title">Nostr Note Details</h2>
                        <button class="modal-close" onclick="document.body.removeChild(this.closest('.modal-overlay'))">&times;</button>
                    </div>
                    
                    <div class="modal-section">
                        <div class="modal-section-title">Content</div>
                        <div class="modal-content-text">${this.processHashtags(this.escapeHtml(note.content || 'No content'))}</div>
                    </div>
                    
                    <div class="modal-section">
                        <div class="modal-section-title">Author</div>
                        <div class="modal-field">
                            <div class="modal-field-label">Username</div>
                            <div class="modal-field-value">@${username}</div>
                        </div>
                        <div class="modal-field">
                            <div class="modal-field-label">Public Key (npub)</div>
                            <div class="modal-field-value">${note.pubkey ? this.hexToNpub(note.pubkey) : 'Unknown'}</div>
                        </div>
                    </div>
                    
                    <div class="modal-section">
                        <div class="modal-section-title">Event Details</div>
                        <div class="modal-field">
                            <div class="modal-field-label">Event ID</div>
                            <div class="modal-field-value">${note.id || 'Unknown'}</div>
                        </div>
                        <div class="modal-field">
                            <div class="modal-field-label">Kind</div>
                            <div class="modal-field-value">${note.kind || 'Unknown'}</div>
                        </div>
                        <div class="modal-field">
                            <div class="modal-field-label">Created At</div>
                            <div class="modal-field-value">${timeString}</div>
                        </div>
                    </div>
                    
                    ${geohashTags.length > 0 ? `
                    <div class="modal-section">
                        <div class="modal-section-title">Location Tags</div>
                        <div class="modal-tags">
                            ${geohashTags.map(geohash => `<span class="modal-tag">üìç ${geohash}</span>`).join('')}
                        </div>
                    </div>
                    ` : ''}
                    
                    ${note.tags && note.tags.length > 0 ? `
                    <div class="modal-section">
                        <div class="modal-section-title">All Tags</div>
                        <div class="modal-field">
                            <div class="modal-field-value">${JSON.stringify(note.tags, null, 2)}</div>
                        </div>
                    </div>
                    ` : ''}
                    
                    <div class="modal-section">
                        <div class="modal-section-title">Raw Nostr Event Data</div>
                        <div class="modal-field">
                            <div class="modal-field-value">
                                <pre style="background: var(--bg-tertiary); padding: 12px; border-radius: 4px; overflow-x: auto; font-size: 0.8rem; font-family: 'JetBrains Mono', 'Fira Code', monospace;">${JSON.stringify(note, null, 2)}</pre>
                            </div>
                        </div>
                    </div>
                `;

                modalOverlay.appendChild(modalContent);
                document.body.appendChild(modalOverlay);
                
                // Set up hashtag click handlers for the modal content
                this.setupHashtagClickHandlers();
            }

            displayError(message) {
                const noteContainer = document.getElementById('noteContainer');
                noteContainer.innerHTML = `<div class="error">${message}</div>`;
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            initializeRelayStatus() {
                this.relays.forEach(relayUrl => {
                    this.relayStatus[relayUrl] = {
                        status: 'disconnected',
                        notesCount: 0,
                        lastSeen: null,
                        connectionTime: null
                    };
                    this.relayEnabled[relayUrl] = true; // All relays enabled for reading by default
                    
                    // Only hitchwiki and trustroots enabled for posting by default
                    this.postingRelays[relayUrl] = relayUrl.includes('hitchwiki.org') || relayUrl.includes('trustroots.org');
                });
                
                // Load saved relay settings from localStorage
                this.loadRelaySettings();
            }

            // Save relay settings to localStorage
            saveRelaySettings() {
                try {
                    const settings = {
                        relays: this.relays,
                        postingRelays: this.postingRelays,
                        relayEnabled: this.relayEnabled
                    };
                    localStorage.setItem('tripchat_relay_settings', JSON.stringify(settings));
                    console.log('Relay settings saved to localStorage');
                } catch (error) {
                    console.error('Failed to save relay settings to localStorage:', error);
                }
            }

            // Load relay settings from localStorage
            loadRelaySettings() {
                try {
                    const saved = localStorage.getItem('tripchat_relay_settings');
                    if (saved) {
                        const settings = JSON.parse(saved);
                        
                        // Restore relay list if available
                        if (settings.relays && Array.isArray(settings.relays)) {
                            this.relays = settings.relays;
                        }
                        
                        // Restore posting relay settings
                        if (settings.postingRelays) {
                            Object.keys(settings.postingRelays).forEach(relayUrl => {
                                if (this.postingRelays.hasOwnProperty(relayUrl)) {
                                    this.postingRelays[relayUrl] = settings.postingRelays[relayUrl];
                                }
                            });
                        }
                        
                        // Restore relay enabled settings
                        if (settings.relayEnabled) {
                            Object.keys(settings.relayEnabled).forEach(relayUrl => {
                                if (this.relayEnabled.hasOwnProperty(relayUrl)) {
                                    this.relayEnabled[relayUrl] = settings.relayEnabled[relayUrl];
                                }
                            });
                        }
                        
                        console.log('Relay settings loaded from localStorage');
                    }
                } catch (error) {
                    console.error('Failed to load relay settings from localStorage:', error);
                }
            }

            updateRelayStatus(relayUrl, status, notesCount = null) {
                if (this.relayStatus[relayUrl]) {
                    this.relayStatus[relayUrl].status = status;
                    this.relayStatus[relayUrl].lastSeen = new Date();
                    
                    if (status === 'connected' && !this.relayStatus[relayUrl].connectionTime) {
                        this.relayStatus[relayUrl].connectionTime = new Date();
                        console.log(`Set connection time for ${relayUrl}:`, this.relayStatus[relayUrl].connectionTime);
                    }
                    
                    if (notesCount !== null) {
                        this.relayStatus[relayUrl].notesCount = notesCount;
                    }
                }
            }
        }

        // Initialize the app when the page loads
        window.tripchatVisualizer = new TRipchatVisualizer();
        
        // Update last modified time
        function updateLastModified() {
            const lastModifiedElement = document.getElementById('lastModified');
            if (lastModifiedElement) {
                const lastModified = new Date(document.lastModified);
                const year = lastModified.getFullYear().toString();
                const month = (lastModified.getMonth() + 1).toString().padStart(2, '0');
                const day = lastModified.getDate().toString().padStart(2, '0');
                const hours = lastModified.getHours().toString().padStart(2, '0');
                const minutes = lastModified.getMinutes().toString().padStart(2, '0');
                const timeString = `${year}-${month}-${day} ${hours}:${minutes}`;
                lastModifiedElement.textContent = timeString;
            }
        }
        updateLastModified();
    </script>

    <!-- GitHub link with last modified time -->
    <div class="app-footer">
        <a href="https://github.com/guaka/TRipchat" target="_blank" rel="noopener noreferrer" id="githubLink">Updated: <span id="lastModified"></span></a>
    </div>
</body>
</html>
