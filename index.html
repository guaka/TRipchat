<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="script-src 'self' 'unsafe-inline' https://unpkg.com https://cdn.jsdelivr.net https://cdn.skypack.dev; connect-src 'self' wss: https:;">
    <title>TRipch.at - nostr travel chat</title>
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16.png">
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="alternate icon" href="favicon.ico">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.8/dist/purify.min.js"></script>
    <script type="module">
        import * as nostrTools from 'https://unpkg.com/nostr-tools@2.17.0/lib/esm/index.js';
        window.nostrTools = nostrTools;
    </script>
    <style>
        * {
            box-sizing: border-box;
        }

        /* Global button styling for consistency */
        button {
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        /* Touch-friendly improvements */
        @media (hover: none) and (pointer: coarse) {
            button:hover {
                transform: none;
            }
            
            .note-item:hover {
                background: #ffffff;
                border-left: none;
                padding-left: 12px;
            }
            
            
            .compose-form:hover {
                transform: none;
            }
        }
        
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700;800&family=Fira+Code:wght@300;400;500;600;700&family=Inter:wght@300;400;500;600;700&display=swap');
        
        :root {
            /* Light theme colors */
            --bg-primary: #f8f9fa;
            --bg-secondary: #ffffff;
            --bg-tertiary: #f1f3f4;
            --text-primary: #2c3e50;
            --text-secondary: #6c757d;
            --text-muted: #888;
            --border-color: #e9ecef;
            --accent-color: #27ae60;
            --accent-hover: #229954;
            --shadow: rgba(0, 0, 0, 0.1);
            --shadow-hover: rgba(0, 0, 0, 0.15);
            --map-bg: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
        }

        [data-theme="dark"] {
            /* Dark theme colors */
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --text-primary: #f0f6fc;
            --text-secondary: #8b949e;
            --text-muted: #6e7681;
            --border-color: #30363d;
            --accent-color: #58a6ff;
            --accent-hover: #4a9eff;
            --shadow: rgba(0, 0, 0, 0.3);
            --shadow-hover: rgba(0, 0, 0, 0.4);
            --map-bg: linear-gradient(135deg, #0d1117 0%, #161b22 100%);
        }
        
        body {
            font-family: 'JetBrains Mono', 'Fira Code', 'Space Grotesk', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;
            margin: 0;
            padding: 0;
            background: var(--bg-primary);
            min-height: 100vh;
            overflow: hidden;
            font-weight: 400;
            letter-spacing: 0.02em;
            color: var(--text-primary);
            line-height: 1.5;
            font-size: 14px;
            transition: background-color 0.3s ease, color 0.3s ease;
            font-feature-settings: 'liga' 1, 'calt' 1;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        
        /* Dark mode toggle button */
        .dark-mode-toggle {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 50%;
            padding: 10px;
            cursor: pointer;
            font-size: 1.3rem;
            transition: all 0.3s ease;
            margin-left: 8px;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px var(--shadow);
        }

        .dark-mode-toggle:hover {
            background: var(--accent-color);
            color: white;
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 6px 20px var(--shadow-hover);
        }

        .main-container {
            display: flex;
            height: 100vh;
            box-shadow: 0 0 20px var(--shadow);
            background: var(--bg-secondary);
            transition: background-color 0.3s ease;
        }
        
        .map-container {
            flex: 1;
            background: var(--map-bg);
            position: relative;
            border-right: 1px solid var(--border-color);
            box-shadow: 4px 0 20px var(--shadow);
            backdrop-filter: blur(10px);
            transition: flex 0.3s ease, opacity 0.3s ease, height 0.3s ease, background 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
            overflow: hidden;
        }

        .map-container.hidden {
            flex: 0;
            height: 0;
            opacity: 0;
            border-right: none;
            box-shadow: none;
        }
        
        #map {
            width: 100%;
            height: 100%;
            background: var(--map-bg);
            transition: background 0.3s ease;
        }
        
        .note-container {
            flex: 1;
            overflow-y: auto;
            max-height: 100vh;
            background: #f8f9fa;
            -webkit-overflow-scrolling: touch;
            scroll-behavior: smooth;
        }
        
        .container {
            max-width: none;
            margin: 0;
            height: 100%;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        
        h1 {
            color: var(--accent-color);
            font-size: 1.8rem;
            font-weight: 800;
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            margin: 0;
            letter-spacing: 0.05em;
            text-transform: none;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            font-feature-settings: 'liga' 1, 'calt' 1;
            transition: color 0.3s ease;
        }
        
        .note-item {
            background: var(--bg-secondary);
            border: none;
            border-radius: 0;
            padding: 12px 16px;
            margin-bottom: 0;
            transition: all 0.3s ease;
            position: relative;
            overflow: visible;
            font-family: 'Inter', sans-serif;
            box-shadow: none;
            backdrop-filter: none;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: flex-start;
            gap: 12px;
        }

        .note-delete-btn {
            position: absolute;
            top: 4px;
            right: 4px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 2px 6px;
            font-size: 0.5rem;
            cursor: pointer;
            opacity: 0.4;
            transition: all 0.2s ease;
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            z-index: 10;
        }

        .note-delete-btn:hover {
            opacity: 0.9;
            background: #c82333;
            transform: scale(1.02);
        }

        .note-delete-btn:disabled {
            opacity: 0.3;
            background: #adb5bd;
            cursor: not-allowed;
            transform: none;
        }

        .note-delete-btn.deleting {
            background: #ffc107;
            color: #000;
            animation: pulse 1s infinite;
        }

        .note-delete-btn.deleted {
            background: #22c55e;
            color: #000;
            animation: none;
        }

        .note-reply-btn {
            background: #3498db;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 2px 6px;
            font-size: 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .note-reply-btn:hover {
            opacity: 0.9;
            background: #2980b9;
            transform: scale(1.02);
        }

        .note-pm-btn {
            background: #9b59b6;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 2px 6px;
            font-size: 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-left: 4px;
        }

        .note-pm-btn:hover {
            opacity: 0.9;
            background: #8e44ad;
            transform: scale(1.02);
        }

        /* PM Modal uses messages-modal styles, with PM-specific overrides */
        .pm-modal {
            display: none;
        }
        
        .pm-modal.show {
            display: block;
        }
        .pm-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            max-height: 60vh;
            background: var(--bg-primary);
        }

        .pm-message {
            margin-bottom: 15px;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 0.9rem;
            line-height: 1.4;
            max-width: 80%;
        }

        .pm-message.sent {
            background: var(--accent-color);
            color: white;
            margin-left: auto;
            text-align: right;
        }

        .pm-message.received {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            margin-right: auto;
        }

        .pm-message-time {
            font-size: 0.7rem;
            opacity: 0.7;
            margin-top: 4px;
        }

        .pm-input-group {
            display: flex;
            gap: 10px;
            padding: 20px;
            border-top: 1px solid var(--border-color);
            background: var(--bg-secondary);
        }

        .pm-input {
            flex: 1;
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--bg-primary);
            color: var(--text-primary);
            font-family: inherit;
            font-size: 0.9rem;
            resize: vertical;
            min-height: 44px;
            max-height: 120px;
        }

        .pm-input:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 2px rgba(39, 174, 96, 0.2);
        }

        .pm-send-btn {
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 20px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s ease;
            align-self: flex-end;
            min-width: 80px;
        }

        .pm-send-btn:hover {
            background: var(--accent-hover);
            transform: translateY(-1px);
        }

        .pm-send-btn:disabled {
            background: var(--text-muted);
            cursor: not-allowed;
            transform: none;
        }

        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }

        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOutRight {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }

        @keyframes floatIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .note-item:hover {
            background: var(--bg-tertiary);
        }
        
        
        .note-header {
            margin-bottom: 2px;
            flex-shrink: 0;
        }
        
        .note-type {
            font-weight: 600;
            font-family: 'Inter', sans-serif;
            color: #27ae60;
            font-size: 0.75rem;
            background: rgba(39, 174, 96, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            letter-spacing: 0.5px;
            text-transform: uppercase;
        }
        
        .note-time {
            color: var(--text-muted);
            font-size: 0.5rem;
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            font-weight: 400;
            margin: 0;
            margin-left: auto;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: right;
            line-height: 1.2;
        }

        .note-time:hover {
            color: var(--accent-color);
            text-decoration: underline;
        }
        
        .note-time::after {
            content: " 🔍";
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.4rem;
        }
        
        .note-time:hover::after {
            opacity: 1;
        }
        
        
        .note-content {
            line-height: 1.6;
            color: var(--text-primary);
            font-size: 0.85rem;
            word-wrap: break-word;
            font-weight: 400;
            margin: 0;
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            flex: 1;
            transition: color 0.3s ease;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            font-feature-settings: 'liga' 1, 'calt' 1;
            letter-spacing: 0.01em;
        }

        /* Markdown styling */
        .note-content h1, .note-content h2, .note-content h3 {
            margin: 12px 0 8px 0;
            font-weight: 600;
            color: var(--text-primary);
            font-family: 'Inter', sans-serif;
        }

        .note-content h1 { font-size: 1.2rem; }
        .note-content h2 { font-size: 1.1rem; }
        .note-content h3 { font-size: 1.0rem; }

        .note-content strong {
            font-weight: 600;
            color: var(--text-primary);
        }

        .note-content em {
            font-style: italic;
            color: var(--text-muted);
        }

        .note-content code {
            background: #f1f3f4;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            font-size: 0.85rem;
            color: #d63384;
        }

        .note-content del {
            text-decoration: line-through;
            color: var(--text-muted);
        }

        .note-content ul, .note-content ol {
            margin: 8px 0;
            padding-left: 20px;
        }

        .note-content li {
            margin: 4px 0;
        }

        .note-content blockquote {
            margin: 8px 0;
            padding: 8px 12px;
            border-left: 3px solid var(--accent-color);
            background: rgba(88, 166, 255, 0.05);
            font-style: italic;
            color: var(--text-muted);
        }

        .hashtag-link {
            color: var(--accent-color);
            text-decoration: none;
            font-weight: 500;
            padding: 2px 4px;
            border-radius: 4px;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .hashtag-link:hover {
            background-color: var(--accent-color);
            color: white;
            text-decoration: none;
        }

        .hashtag-link[data-circle] {
            background-color: rgba(88, 166, 255, 0.1);
            border: 1px solid var(--accent-color);
        }

        .hashtag-link[data-circle]:hover {
            background-color: var(--accent-color);
            color: white;
        }

        #noteContainer {
            flex: 1;
            min-height: 0;
            overflow-y: auto;
            padding: 0;
            background: var(--bg-secondary);
            border: none;
            border-radius: 0;
            scroll-behavior: smooth;
            transition: all 0.3s ease;
        }
        
        .loading {
            text-align: center;
            color: #bdc3c7;
            font-style: italic;
            font-size: 1rem;
            padding: 40px 20px;
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            border-radius: 16px;
            border: 1px solid #34495e;
            font-family: 'Inter', sans-serif;
            font-weight: 500;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            position: relative;
            overflow: hidden;
        }

        .loading::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(39, 174, 96, 0.1), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% {
                left: -100%;
            }
            100% {
                left: 100%;
            }
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--accent-color);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent-hover);
        }
        
        .error {
            color: #DC2626;
            background: rgba(220, 38, 38, 0.1);
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
            border: 1px solid rgba(220, 38, 38, 0.2);
            text-align: center;
        }
        


        .relay-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 4px 0;
            padding: 4px 0;
            font-size: 0.85rem;
        }

        .relay-status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .relay-connected {
            background: #10B981;
            box-shadow: 0 0 6px rgba(16, 185, 129, 0.5);
        }

        .relay-connecting {
            background: #F59E0B;
            animation: pulse 2s infinite;
        }

        .relay-disconnected {
            background: #22c55e;
        }

        .relay-name {
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            color: #2c3e50;
        }

        
        .map-marker {
            background: linear-gradient(135deg, #8B5CF6, #F59E0B);
            color: white;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
            border: 3px solid white;
            box-shadow: 0 6px 20px rgba(139, 92, 246, 0.4);
            transition: all 0.3s ease;
            cursor: pointer;
            z-index: 1000;
        }
        
        .map-marker:hover {
            box-shadow: 0 4px 15px rgba(139, 92, 246, 0.4);
        }
        
        .map-popup {
            max-width: 250px;
            font-family: 'Inter', sans-serif;
        }
        
        .map-popup .note-title {
            font-weight: 600;
            color: #8B5CF6;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }
        
        .popup-content {
            font-size: 0.9rem;
            margin: 5px 0;
        }
        
        .popup-time {
            color: #666;
            font-size: 0.8rem;
        }
        
        .popup-location {
            color: #8B5CF6;
            font-weight: 500;
            margin-top: 6px;
            font-size: 0.8rem;
            border-top: 1px solid rgba(139, 92, 246, 0.2);
            padding-top: 4px;
        }

        .live-indicator {
            position: fixed;
            top: 80px;
            right: 20px;
            background: linear-gradient(135deg, #10B981, #059669);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
            animation: pulse 2s infinite;
        }

        .app-footer {
            position: fixed;
            bottom: 0;
            right: 0;
            padding: 8px 12px;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
            z-index: 1000;
        }

        .app-footer a {
            font-size: 0.5rem;
            color: #10b981; /* Emerald-500 - hacker green */
            font-family: monospace;
            text-decoration: none;
            opacity: 0.9;
            transition: all 0.2s ease;
            text-shadow: 0 0 8px rgba(16, 185, 129, 0.3);
        }

        .app-footer a:hover {
            opacity: 1;
            text-decoration: underline;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .note-new {
            animation: slideInFromTop 0.5s ease-out;
            border-left: 4px solid #10B981;
        }

        @keyframes slideInFromTop {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .tripchat-indicator {
            background: linear-gradient(135deg, #8B5CF6, #F59E0B);
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-left: 8px;
        }

        .geohash-tag {
            background: linear-gradient(135deg, #8B5CF6, #F59E0B);
            color: white;
            padding: 4px 10px;
            border-radius: 16px;
            font-size: 0.75rem;
            font-weight: 600;
            font-family: 'Courier New', monospace;
            margin: 0 4px;
            letter-spacing: 0.5px;
            text-decoration: none;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(139, 92, 246, 0.3);
            display: inline-block;
            cursor: pointer;
        }

        .geohash-tag:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(139, 92, 246, 0.5);
            background: linear-gradient(135deg, #7C3AED, #D97706);
        }

        .tripchat-packet {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 8px;
            margin: 8px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            color: #6c757d;
            word-break: break-all;
        }

        .encrypted-content {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 8px;
            margin: 8px 0;
            font-style: italic;
            color: #856404;
        }


        .filter-row {
            display: flex;
            align-items: center;
            gap: 16px;
            flex-wrap: nowrap;
        }

        .compose-form .filter-row {
            margin-top: 4px;
            padding-top: 4px;
        }


        .filter-input-group {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
            min-width: 200px;
            max-width: 400px;
        }

        .geohash-input {
            width: 120px;
            max-width: 120px;
            min-width: 120px;
            padding: 10px 14px;
            border: 1px solid var(--border-color);
            border-radius: 0;
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 0.85rem;
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            transition: all 0.3s ease;
        }

        .search-input {
            flex: 1;
            min-width: 180px;
            padding: 10px 14px;
            border: 1px solid var(--border-color);
            border-radius: 0;
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 0.85rem;
            transition: all 0.3s ease;
        }

        .circles-button {
            width: 40px;
            height: 40px;
            padding: 0;
            border: 1px solid #22c55e;
            border-radius: 6px;
            background: #22c55e;
            color: white;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            box-shadow: 0 2px 4px rgba(34, 197, 94, 0.2);
            box-sizing: border-box;
        }

        .circles-button:hover {
            background: #16a34a;
            color: white;
            border-color: #16a34a;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(34, 197, 94, 0.3);
        }

        .circles-button:active {
            transform: scale(0.95);
        }

        .circles-modal {
            max-width: 500px;
            max-height: 80vh;
        }

        .circles-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 8px;
            max-height: 60vh;
            overflow-y: auto;
        }

        .circle-item {
            padding: 12px 16px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.9rem;
            text-align: center;
        }

        .circle-item:hover {
            background: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
            transform: translateY(-1px);
        }

        .circle-item:active {
            transform: translateY(0);
        }

        .geohash-input:focus,
        .search-input:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 3px rgba(88, 166, 255, 0.1);
            background: var(--bg-secondary);
        }



        .filter-options {
            margin: 12px 0;
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: nowrap;
        }




        /* Nostr Note Details Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            border: 1px solid #34495e;
            border-radius: 20px;
            padding: 20px;
            max-width: 600px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            position: relative;
            font-family: 'Inter', sans-serif;
            backdrop-filter: blur(20px);
            color: #ecf0f1;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 2px solid #34495e;
        }

        .modal-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: #ecf0f1;
            margin: 0;
            font-family: 'Inter', sans-serif;
        }

        .modal-close {
            background: #34495e;
            border: 1px solid #2c3e50;
            font-size: 1.5rem;
            color: #ecf0f1;
            cursor: pointer;
            padding: 8px 12px;
            border-radius: 8px;
            transition: all 0.3s ease;
            font-family: 'Inter', sans-serif;
            font-weight: 600;
        }

        .modal-close:hover {
            background: #22c55e;
            color: #ffffff;
            transform: scale(1.1);
        }

        .modal-section {
            margin-bottom: 20px;
        }

        .modal-section-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: #27ae60;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 5px rgba(255, 136, 0, 0.5);
        }

        .modal-field {
            margin-bottom: 12px;
        }

        .modal-field-label {
            font-size: 0.8rem;
            font-weight: 600;
            color: #ecf0f1;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-family: 'Courier New', monospace;
        }

        .modal-field-value {
            font-family: 'Inter', sans-serif;
            font-size: 0.9rem;
            background: #34495e;
            padding: 12px 16px;
            border-radius: 8px;
            border: 1px solid #2c3e50;
            word-break: break-all;
            color: #ecf0f1;
        }

        .modal-content-text {
            font-size: 0.95rem;
            line-height: 1.6;
            color: #ecf0f1;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-family: 'Courier New', monospace;
        }

        .modal-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .modal-tag {
            background: #34495e;
            color: #ecf0f1;
            padding: 6px 12px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
            font-family: 'Inter', sans-serif;
            border: 1px solid #2c3e50;
        }

        .header-top-row {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 0;
            padding: 12px 16px 8px 16px;
            border-bottom: 2px solid var(--border-color);
            position: sticky;
            top: 0;
            z-index: 100;
            background: var(--bg-secondary);
            box-shadow: 0 2px 4px var(--shadow);
            transition: all 0.3s ease;
        }

        .header-title-group {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 8px;
        }

        .header-logo-container {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .trustroots-logo {
            height: 32px;
            width: auto;
            opacity: 0.8;
            transition: opacity 0.2s ease;
        }

        .trustroots-logo:hover {
            opacity: 1;
        }


        .tripchat-links {
            display: flex;
            gap: 16px;
        }



        .header-btn {
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 20px;
            padding: 8px 12px;
            cursor: pointer;
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            font-size: 0.6rem;
            font-weight: 600;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            box-shadow: 0 4px 15px var(--shadow);
            position: relative;
            overflow: hidden;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            white-space: nowrap;
        }


        .settings-btn::before, .relay-manager-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .settings-btn:hover::before, .relay-manager-btn:hover::before {
            left: 100%;
        }

        .header-btn:hover {
            background: var(--accent-hover);
            transform: translateY(-3px);
            box-shadow: 0 8px 25px var(--shadow-hover);
        }

        .messages-btn.has-unread {
            background: #e74c3c;
            animation: pulse 2s infinite;
        }

        .messages-btn.has-unread::after {
            content: "●";
            position: absolute;
            top: -5px;
            right: -5px;
            color: #ff6b6b;
            font-size: 12px;
            animation: blink 1s infinite;
        }


        .map-toggle-btn.active {
            background: var(--accent-color);
            color: white;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }

        /* Messages Modal Styles */
        .messages-modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
        }

        .messages-modal-content {
            background: var(--bg-primary);
            margin: 5% auto;
            padding: 0;
            border: 1px solid var(--border-color);
            border-radius: 12px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .messages-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-secondary);
            border-radius: 12px 12px 0 0;
        }

        .messages-header h3 {
            margin: 0;
            color: var(--text-primary);
            font-size: 1.2rem;
        }

        .messages-close {
            color: var(--text-muted);
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.2s ease;
        }

        .messages-close:hover {
            color: var(--text-primary);
        }

        .messages-list {
            flex: 1;
            overflow-y: auto;
            padding: 0;
            max-height: 60vh;
        }

        .messages-loading {
            text-align: center;
            padding: 40px;
            color: var(--text-muted);
        }

        .conversation-item {
            padding: 15px 20px;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            transition: background-color 0.2s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .conversation-item:hover {
            background: var(--bg-secondary);
        }

        .conversation-item:last-child {
            border-bottom: none;
        }

        .conversation-info {
            flex: 1;
        }

        .conversation-name {
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        .conversation-preview {
            font-size: 0.9rem;
            color: var(--text-muted);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 300px;
        }

        .conversation-meta {
            text-align: right;
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        .conversation-time {
            margin-bottom: 4px;
        }

        .unread-badge {
            background: #e74c3c;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            font-weight: bold;
        }

        .no-conversations {
            text-align: center;
            padding: 40px;
            color: var(--text-muted);
        }

        .compose-btn-bottom {
            background: var(--accent-color);
            color: white;
            border: none;
            padding: 14px 24px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            font-family: 'Inter', sans-serif;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(39, 174, 96, 0.3);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            width: 100%;
            max-width: 200px;
            margin: 0 auto;
            display: block;
            position: relative;
            overflow: hidden;
        }

        .compose-btn-bottom::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .compose-btn-bottom:hover::before {
            left: 100%;
        }

        .compose-btn-bottom:hover {
            background: var(--accent-hover);
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(39, 174, 96, 0.4);
        }

        /* Compact Inline Compose Form Styles */
        .compose-form {
            background: var(--bg-secondary);
            border-radius: 0;
            padding: 16px;
            margin-bottom: 0;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 15px var(--shadow);
            position: relative;
            transition: all 0.3s ease;
        }


        .compose-form:hover {
            box-shadow: 0 8px 30px var(--shadow-hover);
        }

        .compose-form-body {
            padding: 0;
        }

        .compose-form .compose-section {
            margin-bottom: 0px;
        }

        .compose-form .compose-section:last-child {
            margin-bottom: 0;
        }

        .compose-form label {
            display: block;
            margin-bottom: 3px;
            font-weight: 600;
            color: #2c3e50;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        .compose-form textarea,
        .compose-form input,
        .compose-form select {
            width: 100%;
            padding: 6px 10px;
            border: 1px solid var(--border-color);
            border-radius: 0;
            font-size: 0.85rem;
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            transition: all 0.3s ease;
            background: var(--bg-secondary);
            color: var(--text-primary);
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }

        .compose-form textarea {
            resize: vertical;
            min-height: 50px;
            max-height: 120px;
        }

        .compose-form textarea:focus,
        .compose-form input:focus,
        .compose-form select:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 2px rgba(88, 166, 255, 0.1);
        }

        .compose-form .location-input-group {
            display: flex;
            gap: 6px;
        }

        .compose-form .location-input-group input {
            flex: 1;
        }

        .compose-form .location-btn {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            border: none;
            padding: 6px 8px;
            border-radius: 0;
            cursor: pointer;
            font-size: 0.7rem;
            font-weight: 600;
            white-space: nowrap;
            transition: all 0.2s ease;
        }

        .compose-form .location-btn:hover {
            background: linear-gradient(135deg, #2980b9 0%, #21618c 100%);
            transform: translateY(-1px);
        }


        .compose-form .compose-actions {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #dee2e6;
        }

        .compose-form .post-btn {
            background: var(--accent-color);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 0;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(39, 174, 96, 0.2);
        }

        .compose-form .post-btn:hover {
            background: var(--accent-hover);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(39, 174, 96, 0.3);
        }

        /* Note Persistence Styles */
        .note-item.ephemeral {
            border-left: 3px solid #22c55e; /* Green for ephemeral */
        }

        .note-item.persistent {
            border-left: 3px solid #4ecdc4; /* Teal for persistent */
        }

        .note-item.expiring {
            border-left: 3px solid #ffa726; /* Orange for expiring soon */
        }

        .note-expiration {
            font-size: 0.7rem;
            color: #6c757d;
            font-style: italic;
            margin-top: 4px;
        }

        .persistence-select {
            font-size: 0.8rem;
            padding: 6px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
            width: 120px;
            max-width: 120px;
            flex-shrink: 0;
        }

        .compose-section {
            margin-bottom: 0px;
        }

        .compose-section label {
            display: block;
            font-size: 0.8rem;
            font-weight: 600;
            margin-bottom: 4px;
            color: var(--text-primary);
            transition: color 0.3s ease;
        }

        /* Settings Modal Styles */
        .settings-modal {
            max-width: 700px;
            width: 90%;
        }

        .settings-modal-message {
            display: none;
            padding: 12px 16px;
            margin-bottom: 16px;
            border-radius: 10px;
            background: rgba(39, 174, 96, 0.12);
            border: 1px solid rgba(39, 174, 96, 0.35);
            color: #1f7a52;
            font-weight: 600;
            font-size: 0.9rem;
        }

        .key-setup-prompt {
            display: none;
            flex-direction: column;
            gap: 12px;
            padding: 16px;
            margin-bottom: 24px;
            border-radius: 12px;
            background: rgba(52, 73, 94, 0.3);
            border: 1px solid rgba(52, 152, 219, 0.4);
        }

        .key-setup-prompt.compact {
            background: transparent;
            border: none;
            padding: 8px 0 0 0;
            margin-bottom: 16px;
        }

        .key-setup-prompt.compact .key-setup-actions {
            justify-content: flex-start;
        }

        .key-setup-question {
            font-weight: 600;
            color: #3498db;
            font-size: 0.95rem;
        }

        .key-setup-actions {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .key-btn.key-choice {
            flex: 1 1 200px;
            justify-content: center;
            background: linear-gradient(135deg, #1976d2, #42a5f5);
            color: #ffffff;
        }

        .key-btn.key-choice:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 18px rgba(25, 118, 210, 0.35);
        }

        .key-hint {
            display: none;
            margin-top: 8px;
            font-size: 0.8rem;
            color: #27ae60;
            background: rgba(39, 174, 96, 0.2);
            border: 1px solid rgba(39, 174, 96, 0.4);
            padding: 10px 12px;
            border-radius: 10px;
            text-align: left;
        }

        .key-hint a {
            color: #3498db;
            text-decoration: underline;
        }

        .settings-section {
            margin-bottom: 16px;
        }

        .verification-info {
            background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
            border: 1px solid #e9ecef;
            border-radius: 12px;
            padding: 12px;
        }

        .nip05-identifier {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 12px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            color: #2c3e50;
            word-break: break-all;
            margin-bottom: 12px;
        }

        .nip05-url {
            background: #f0f8ff;
            border: 1px solid #bbdefb;
            border-radius: 8px;
            padding: 12px;
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            color: #1976d2;
            word-break: break-all;
            margin-bottom: 12px;
        }

        .verification-actions {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
        }

        .verification-status {
            font-size: 0.8rem;
            font-style: italic;
            padding: 4px 0;
        }

        .filter-options {
            white-space: nowrap;
            flex: 0 0 auto;
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: nowrap;
        }

        .filter-toggle-label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 0.8rem;
            color: #6c757d;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .filter-toggle-label input[type="checkbox"] {
            display: none;
        }

        .filter-toggle-slider {
            position: relative;
            width: 40px;
            height: 40px;
            background: #e9ecef;
            border-radius: 20px;
            transition: all 0.2s ease;
            border: 1px solid #dee2e6;
            display: flex;
            align-items: center;
            justify-content: center;
            box-sizing: border-box;
        }

        .filter-toggle-slider::before {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 34px;
            height: 34px;
            background: #ffffff;
            border-radius: 50%;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .filter-toggle-label input[type="checkbox"]:checked + .filter-toggle-slider {
            background: var(--accent-color);
            border-color: var(--accent-color);
        }

        .filter-toggle-label input[type="checkbox"]:checked + .filter-toggle-slider::before {
            transform: translateX(2px);
        }

        .filter-toggle-label input[type="checkbox"]:checked + .filter-toggle-slider .filter-toggle-text {
            color: white;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        .filter-toggle-text {
            font-size: 0.8rem;
            font-weight: 700;
            color: #1a1a1a;
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);
            z-index: 2;
            position: relative;
        }


        .settings-section label {
            display: block;
            color: #ecf0f1;
            font-weight: 600;
            margin-bottom: 6px;
            font-family: 'Inter', sans-serif;
        }

        .profile-btn {
            background: #3498db;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 20px;
            cursor: pointer;
            font-family: 'Inter', sans-serif;
            font-size: 0.9rem;
            font-weight: 600;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 8px rgba(52, 152, 219, 0.3);
            margin-top: 12px;
        }

        .profile-btn:hover {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.4);
        }

        .settings-actions {
            display: flex;
            justify-content: flex-end;
            margin-top: 24px;
            padding-top: 20px;
            border-top: 2px solid #e9ecef;
        }

        .compose-section {
            margin-bottom: 1px;
        }

        .compose-section label {
            display: block;
            color: var(--text-primary);
            font-weight: 600;
            margin-bottom: 8px;
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            transition: color 0.3s ease;
        }

        .compose-section textarea,
        .compose-section input {
            width: 100%;
            padding: 16px 20px;
            border: 1px solid var(--border-color);
            border-radius: 12px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            font-size: 0.9rem;
            box-shadow: var(--shadow);
            transition: all 0.3s ease;
        }

        .compose-section textarea:focus,
        .compose-section input:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 4px rgba(88, 166, 255, 0.15), 0 8px 20px var(--shadow);
            transform: translateY(-1px);
        }

        .location-input-group,
        .key-input-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .location-input-group input,
        .key-input-group input {
            flex: 1;
        }

        .key-input-group input.readonly {
            background: rgba(52, 73, 94, 0.85);
            border: 1px dashed rgba(39, 174, 96, 0.4);
            cursor: not-allowed;
        }

        .key-visibility-btn {
            background: #34495e;
            color: #ecf0f1;
            border: 1px solid #2c3e50;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s ease;
            margin-left: 8px;
        }

        .key-visibility-btn:hover {
            background: #2c3e50;
            transform: scale(1.05);
        }

        .key-delete-btn {
            background: #e74c3c;
            color: #ecf0f1;
            border: 1px solid #c0392b;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s ease;
            margin-left: 8px;
        }

        .key-delete-btn:hover {
            background: #c0392b;
            transform: scale(1.05);
        }

        .reply-context-display a {
            color: #27ae60 !important;
            text-decoration: none;
        }

        .reply-context-display a:hover {
            color: #2ecc71 !important;
            text-decoration: underline;
        }

        .modal-copy-btn {
            background: #3498db;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .modal-copy-btn:hover {
            background: #2980b9;
            transform: translateY(-1px);
        }

        .location-btn, .key-btn {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            border: none;
            border-radius: 12px;
            padding: 12px 18px;
            cursor: pointer;
            font-family: 'Inter', sans-serif;
            font-size: 0.8rem;
            white-space: nowrap;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
        }

        .location-btn:hover, .key-btn:hover {
            background: linear-gradient(135deg, #2980b9 0%, #1f618d 100%);
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(52, 152, 219, 0.4);
        }

        .posting-relays-display {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 8px;
        }

        .posting-relay-item {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--accent-color);
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 500;
            color: var(--accent-color);
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
        }

        .posting-relay-item .relay-status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--accent-color);
        }

        .posting-relay-item .relay-name {
            font-weight: 600;
        }

        .posting-relay-item .relay-connected {
            background: var(--accent-color);
        }

        .posting-relay-item .relay-disconnected {
            background: #dc3545;
        }

        .compose-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }

        .post-btn, .cancel-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Inter', sans-serif;
            font-weight: 600;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .post-btn {
            background: var(--accent-color);
            color: white;
            box-shadow: 0 4px 15px rgba(39, 174, 96, 0.3);
        }

        .post-btn:hover {
            background: var(--accent-hover);
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(39, 174, 96, 0.4);
        }

        .cancel-btn {
            background: linear-gradient(135deg, #6c757d 0%, #5a6268 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(108, 117, 125, 0.3);
        }

        .cancel-btn:hover {
            background: linear-gradient(135deg, #5a6268 0%, #495057 100%);
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(108, 117, 125, 0.4);
        }

        /* Relay Manager Styles */
        .relay-modal {
            max-width: 700px;
            width: 90%;
        }

        .relay-section {
            margin-bottom: 12px;
        }

        .relay-section h4 {
            color: var(--accent-color);
            margin-bottom: 8px;
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
        }

        .add-relay-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .add-relay-group input {
            flex: 1;
            padding: 12px 16px;
            border: 1px solid #34495e;
            border-radius: 8px;
            background: #34495e;
            color: #ecf0f1;
            font-family: 'Inter', sans-serif;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .add-btn {
            background: var(--accent-color);
            color: #ffffff;
            border: none;
            border-radius: 8px;
            padding: 12px 20px;
            cursor: pointer;
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            font-weight: 600;
            white-space: nowrap;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px var(--shadow);
        }

        .add-btn:hover {
            background: var(--accent-hover);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px var(--shadow-hover);
        }

        .relay-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .relay-item-manager {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px;
            margin-bottom: 8px;
            background: #ffffff;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            font-family: 'Inter', sans-serif;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        .relay-info {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1;
        }

        .relay-status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .relay-url {
            color: #2c3e50;
            font-size: 0.9rem;
        }

        .relay-actions {
            display: flex;
            gap: 5px;
        }

        .relay-delete {
            padding: 4px 8px;
            border: 1px solid;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8rem;
            font-family: 'Courier New', monospace;
            color: #22c55e;
            border-color: #22c55e;
            background: rgba(34, 197, 94, 0.1);
        }

        .relay-delete:hover {
            background: rgba(34, 197, 94, 0.2);
        }

        .post-toggle-label {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 30px;
            cursor: pointer;
        }

        .post-toggle-label input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .post-toggle-slider {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #e9ecef;
            border-radius: 30px;
            transition: all 0.3s ease;
            border: 2px solid #dee2e6;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .post-toggle-slider:before {
            content: '';
            position: absolute;
            height: 22px;
            width: 22px;
            left: 2px;
            bottom: 2px;
            background-color: #ffffff;
            border-radius: 50%;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .post-toggle-text {
            font-size: 0.7rem;
            font-weight: 600;
            color: #6c757d;
            font-family: 'Inter', sans-serif;
            z-index: 1;
            transition: all 0.3s ease;
        }

        .post-toggle-label input:checked + .post-toggle-slider {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
        }

        .post-toggle-label input:checked + .post-toggle-slider:before {
            transform: translateX(30px);
        }

        .post-toggle-label input:checked + .post-toggle-slider .post-toggle-text {
            color: #ffffff;
        }


        
        @media (max-width: 768px) {
            .main-container {
                flex-direction: column;
                height: 100vh;
                overflow: hidden;
            }

            
            .map-container {
                height: 5vh;
                min-height: 60px;
                order: 2;
                border-right: none;
                border-bottom: 1px solid var(--border-color);
                background: var(--map-bg);
                transition: height 0.3s ease, opacity 0.3s ease;
            }

            .map-container.hidden {
                height: 0;
                min-height: 0;
                opacity: 0;
                border-bottom: none;
            }
            
            .note-container {
                height: 95vh;
                order: 1;
                padding: 0;
                background: #f8f9fa;
                display: flex;
                flex-direction: column;
            }

            .header-top-row {
                padding: 4px 8px;
                margin-bottom: 0;
                border-bottom: 1px solid #e9ecef;
                flex-shrink: 0;
                align-items: center;
            }

            .header-title-group {
                flex: 1;
                min-width: 0;
                gap: 0;
            }

            .header-logo-container {
                gap: 8px;
            }

            .trustroots-logo {
                height: 24px;
            }

            .tripchat-links {
                flex-shrink: 0;
            }

            h1 {
                font-size: 0.9rem;
                margin: 0;
                line-height: 1.1;
            }

            .header-title-group p {
                font-size: 0.6rem !important;
                color: #6c757d !important;
                margin: 1px 0 2px 0 !important;
                line-height: 1.1 !important;
            }

            .tripchat-links {
                display: flex;
                gap: 4px;
                margin-top: 2px;
            }

            .settings-btn, .relay-manager-btn {
                padding: 3px 6px;
                font-size: 0.55rem;
                border-radius: 3px;
                min-width: 40px;
            }

            #noteContainer {
                flex: 1;
                padding: 8px;
                background: transparent;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }

            
            .note-item {
                padding: 12px;
                margin-bottom: 8px;
                border-radius: 8px;
                box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
                background: white;
            }
            
            .note-header {
                margin-bottom: 4px;
            }

            .note-content {
                font-size: 0.9rem;
                line-height: 1.5;
            }

            .note-username {
                font-size: 0.8rem;
                font-weight: 600;
                color: var(--accent-color); /* Default color for non-linked usernames */
            }

            .note-username a {
                color: #22c55e !important; /* Green for NIP-05 links */
                text-decoration: none !important;
            }

            .note-username a:hover {
                color: #16a34a !important; /* Darker green on hover */
                text-decoration: underline !important;
            }

            .note-username a:visited {
                color: #22c55e !important; /* Keep green even after visiting */
            }

            .note-time {
                font-size: 0.5rem;
                margin-left: auto;
            }

            /* Mobile filter - compact and efficient */

            .filter-row {
                flex-direction: row;
                gap: 8px;
                align-items: center;
                flex-wrap: nowrap;
                overflow: hidden;
            }

            .filter-input-group {
                flex: 1;
                min-width: 120px;
                max-width: 250px;
                display: flex;
                gap: 6px;
                align-items: center;
            }

            .geohash-input {
                width: 100px;
                max-width: 100px;
                min-width: 100px;
                font-size: 0.85rem;
                padding: 8px 10px;
            }

            .search-input {
                font-size: 0.85rem;
                padding: 8px 10px;
            }

            .circles-button {
                width: 40px;
                height: 40px;
                font-size: 1.1rem;
                font-weight: 600;
                background: #22c55e;
                border-color: #22c55e;
                color: white;
                border-radius: 6px;
                box-shadow: 0 2px 4px rgba(34, 197, 94, 0.2);
                flex-shrink: 0;
            }

            .circles-button:hover {
                background: #16a34a;
                border-color: #16a34a;
                transform: translateY(-2px);
                box-shadow: 0 4px 8px rgba(34, 197, 94, 0.3);
            }

            .circles-modal {
                max-width: 90vw;
                max-height: 85vh;
            }

            .circles-list {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
                gap: 6px;
                max-height: 70vh;
            }

            .circle-item {
                padding: 10px 12px;
                font-size: 0.85rem;
            }

            .filter-options {
                display: flex;
                align-items: center;
                gap: 8px;
                flex-shrink: 0;
            }

            .filter-toggle-label {
                font-size: 0.7rem;
                gap: 4px;
            }

            .filter-toggle-slider {
                height: 40px;
                border-radius: 20px;
            }

            .filter-toggle-slider::before {
                width: 34px;
                height: 34px;
            }

            .filter-toggle-label input[type="checkbox"]:checked + .filter-toggle-slider::before {
                transform: translateX(2px);
            }

            .filter-toggle-label input[type="checkbox"]:checked + .filter-toggle-slider .filter-toggle-text {
                color: white;
                text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
            }

            .filter-toggle-text {
                font-size: 0.7rem;
                color: #1a1a1a;
                text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);
            }



            /* Mobile compose - always visible at bottom */
            .compose-form {
                padding: 8px 12px;
                margin: 0;
                border-radius: 0;
                background: white;
                border-top: 1px solid #e9ecef;
                flex-shrink: 0;
            }

            .compose-form textarea {
                min-height: 50px;
                font-size: 0.85rem;
                padding: 5px 8px;
            }

            .compose-form .post-btn {
                padding: 8px 16px;
                font-size: 0.8rem;
            }

            .compose-form .compose-actions {
                margin-top: 8px;
                padding-top: 8px;
            }
        }

        @media (max-width: 480px) {
            .map-container {
                height: 4vh;
                min-height: 50px;
                background: var(--map-bg);
                transition: height 0.3s ease, opacity 0.3s ease;
            }

            .map-container.hidden {
                height: 0;
                min-height: 0;
                opacity: 0;
            }

            .note-container {
                height: 96vh;
            }

            h1 {
                font-size: 0.8rem;
            }

            .header-top-row {
                padding: 3px 8px;
            }

            .header-title-group p {
                font-size: 0.55rem !important;
            }

            .trustroots-logo {
                height: 20px;
            }

            .settings-btn, .relay-manager-btn {
                padding: 2px 5px;
                font-size: 0.5rem;
                min-width: 35px;
            }

            .note-item {
                padding: 10px;
                margin-bottom: 6px;
            }

            .note-content {
                font-size: 0.85rem;
            }


            .filter-row {
                gap: 8px;
            }

            .filter-input-group {
                min-width: 100px;
                max-width: 200px;
                display: flex;
                gap: 4px;
                align-items: center;
            }

            .geohash-input {
                width: 80px;
                max-width: 80px;
                min-width: 80px;
                font-size: 0.8rem;
                padding: 6px 8px;
            }

            .search-input {
                font-size: 0.8rem;
                padding: 6px 8px;
            }

            .circles-button {
                width: 40px;
                height: 40px;
                font-size: 1rem;
                font-weight: 600;
                background: #22c55e;
                border-color: #22c55e;
                color: white;
                border-radius: 6px;
                box-shadow: 0 2px 4px rgba(34, 197, 94, 0.2);
                flex-shrink: 0;
            }

            .circles-button:hover {
                background: #16a34a;
                border-color: #16a34a;
                transform: translateY(-2px);
                box-shadow: 0 4px 8px rgba(34, 197, 94, 0.3);
            }

            .filter-toggle-label {
                font-size: 0.65rem;
            }

            .filter-toggle-slider {
                height: 40px;
                border-radius: 20px;
            }

            .filter-toggle-slider::before {
                width: 34px;
                height: 34px;
            }

            .filter-toggle-label input[type="checkbox"]:checked + .filter-toggle-slider::before {
                transform: translateX(2px);
            }

            .filter-toggle-label input[type="checkbox"]:checked + .filter-toggle-slider .filter-toggle-text {
                color: white;
                text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
            }

            .filter-toggle-text {
                font-size: 0.65rem;
                color: #1a1a1a;
                text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);
            }



            .compose-form {
                padding: 6px 10px;
            }

            .compose-form textarea {
                min-height: 45px;
                font-size: 0.8rem;
                padding: 4px 6px;
            }

            .compose-form .post-btn {
                padding: 6px 12px;
                font-size: 0.75rem;
            }
        }

        @media (max-width: 360px) {
            .map-container {
                height: 3vh;
                min-height: 40px;
                background: var(--map-bg);
                transition: height 0.3s ease, opacity 0.3s ease;
            }

            .map-container.hidden {
                height: 0;
                min-height: 0;
                opacity: 0;
            }

            .note-container {
                height: 97vh;
            }

            h1 {
                font-size: 0.75rem;
            }

            .header-top-row {
                padding: 2px 6px;
            }

            .header-title-group p {
                font-size: 0.5rem !important;
            }

            .trustroots-logo {
                height: 18px;
            }

            .settings-btn, .relay-manager-btn {
                padding: 2px 4px;
                font-size: 0.45rem;
                min-width: 30px;
            }

            .note-item {
                padding: 8px;
                margin-bottom: 4px;
            }

            .note-content {
                font-size: 0.8rem;
            }

            .note-username {
                font-size: 0.75rem;
            }

            .note-time {
                font-size: 0.45rem;
            }


            .filter-row {
                gap: 6px;
            }

            .filter-input-group {
                min-width: 80px;
                max-width: 150px;
                display: flex;
                gap: 3px;
                align-items: center;
            }

            .geohash-input {
                width: 70px;
                max-width: 70px;
                min-width: 70px;
                font-size: 0.75rem;
                padding: 5px 6px;
            }

            .search-input {
                font-size: 0.75rem;
                padding: 5px 6px;
            }

            .circles-button {
                width: 40px;
                height: 40px;
                font-size: 0.9rem;
                font-weight: 600;
                background: #22c55e;
                border-color: #22c55e;
                color: white;
                border-radius: 6px;
                box-shadow: 0 2px 4px rgba(34, 197, 94, 0.2);
                flex-shrink: 0;
            }

            .circles-button:hover {
                background: #16a34a;
                border-color: #16a34a;
                transform: translateY(-2px);
                box-shadow: 0 4px 8px rgba(34, 197, 94, 0.3);
            }

            .filter-toggle-label {
                font-size: 0.6rem;
            }

            .filter-toggle-slider {
                height: 40px;
                border-radius: 20px;
            }

            .filter-toggle-slider::before {
                width: 34px;
                height: 34px;
            }

            .filter-toggle-label input[type="checkbox"]:checked + .filter-toggle-slider::before {
                transform: translateX(2px);
            }

            .filter-toggle-label input[type="checkbox"]:checked + .filter-toggle-slider .filter-toggle-text {
                color: white;
                text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
            }

            .filter-toggle-text {
                font-size: 0.6rem;
                color: #1a1a1a;
                text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);
            }



            .compose-form {
                padding: 5px 8px;
            }

            .compose-form textarea {
                min-height: 40px;
                font-size: 0.75rem;
                padding: 3px 5px;
            }

            .compose-form .post-btn {
                padding: 5px 10px;
                font-size: 0.7rem;
            }
        }

        /* Force green for NIP-05 links - highest specificity */
        body .main-container .note-item .note-username a,
        body .main-container .note-item .note-username a:link,
        body .main-container .note-item .note-username a:visited,
        body .main-container .note-item .note-username a:active {
            color: #22c55e !important;
            text-decoration: none !important;
        }

        body .main-container .note-item .note-username a:hover {
            color: #16a34a !important;
            text-decoration: underline !important;
        }

        /* Additional specificity for all link states */
        .note-item .note-username a,
        .note-item .note-username a:link,
        .note-item .note-username a:visited,
        .note-item .note-username a:active {
            color: #22c55e !important;
            text-decoration: none !important;
        }

        .note-item .note-username a:hover {
            color: #16a34a !important;
            text-decoration: underline !important;
        }

        /* URL link styles */
        .external-link {
            color: #22c55e;
            text-decoration: underline;
        }

        .external-link:hover {
            color: #16a34a;
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="map-container">
            <div id="map"></div>
        </div>
        <div class="note-container">
            <div class="container">
                <div class="header-top-row">
                    <div class="header-title-group">
                        <div class="header-logo-container">
                            <img src="logos/color.svg" alt="Trustroots" class="trustroots-logo" />
                            <h1>TRipch.at</h1>
                        </div>
                        <p style="font-size: 0.7rem; color: var(--text-muted); margin: -18px 0 0 0; font-family: 'JetBrains Mono', 'Fira Code', monospace; text-transform: lowercase;">nostr travel chat - connect with travelers worldwide</p>
                    </div>
                    
                    <!-- TRipchat Links -->
                    <div class="tripchat-links">
                        <button id="mapToggleBtn" class="header-btn map-toggle-btn" title="Toggle Map">🗺️ MAP</button>
                        <button id="messagesBtn" class="header-btn messages-btn" title="Private Messages">✉️ MESSAGES</button>
                        <button id="settingsBtn" class="header-btn settings-btn">🔑 KEYS</button>
                        <button id="relayManagerBtn" class="header-btn relay-manager-btn">⚙️ RELAYS</button>
                        <button id="darkModeToggle" class="dark-mode-toggle" title="Toggle dark mode">🌙</button>
                    </div>
                </div>
                
                <div id="noteContainer">
                    <div class="loading">Loading travel messages from Nostr relays...</div>
                </div>
                
                <!-- Compose Controls -->
                <div id="composeButtonContainer" style="display: none;">
                    <button id="composeBtn" class="compose-btn-bottom">✍️ COMPOSE</button>
                </div>
                <div id="composeFormContainer">
                    <div class="compose-form">
                        <div class="compose-form-body">
                            <div class="compose-section">
                                <label for="composeContent" style="display: flex; align-items: center; gap: 6px; margin-bottom: 2px; font-size: 0.75rem; color: var(--text-muted);">
                                    <span style="color: #22c55e;">⚠️</span>
                                    <span>Your message will be public on the Nostr network. Deletion doesn't always work.</span>
                                </label>
                                <div id="replyContextDisplay" class="reply-context-display" style="display: none; margin-bottom: 8px; padding: 8px 12px; background: rgba(52, 152, 219, 0.1); border: 1px solid rgba(52, 152, 219, 0.3); border-radius: 6px; font-size: 0.8rem;">
                                    <div style="display: flex; align-items: center; gap: 8px;">
                                        <span style="color: #3498db;">💬</span>
                                        <span style="color: var(--text-muted);">Replying to:</span>
                                        <span id="replyTargetUsername" style="color: #2c3e50; font-weight: 600;"></span>
                                        <button type="button" id="clearReplyContext" style="background: none; border: none; color: #6c757d; cursor: pointer; font-size: 0.7rem; margin-left: auto;" title="Cancel reply">✕</button>
                                    </div>
                                </div>
                                <textarea id="composeContent" placeholder="What's happening? Share your thoughts, travel updates, or location-specific info..." rows="3"></textarea>
                            </div>
                            <div class="compose-section" style="display: flex; align-items: center; gap: 8px;">
                                <label for="notePersistence" style="margin: 0; font-size: 0.8rem; color: var(--text-muted); flex-shrink: 0;">Note Duration:</label>
                                <select id="notePersistence" class="persistence-select" style="flex-shrink: 0;">
                                    <option value="1h" selected>1 Hour</option>
                                    <option value="short">24 Hours</option>
                                    <option value="medium">7 Days</option>
                                    <option value="long">30 Days</option>
                                    <option value="permanent">Permanent</option>
                                </select>
                                <div style="font-size: 0.7rem; color: var(--text-muted); margin-left: auto;">
                                    Enter to post<br/>Shift+Enter new line
                                </div>
                            </div>
                            
                            <!-- Filter Row merged into compose form -->
                            <div class="filter-row">
                                <div class="filter-input-group">
                                    <input type="text" id="geohashFilter" placeholder="geohash" class="geohash-input" />
                                    <input type="text" id="searchFilter" placeholder="search filter e.g. #hashtags" class="search-input" />
                                </div>
                                <div class="filter-options">
                                    <button id="circlesButton" class="circles-button" title="Select Trustroots Circle">∞</button>
                                    <label class="filter-toggle-label">
                                        <input type="checkbox" id="nip05Filter" />
                                        <span class="filter-toggle-slider">
                                            <span class="filter-toggle-text">✓</span>
                                        </span>
                                    </label>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
            </div>
        </div>
    </div>

    <!-- Live indicator -->
    <div id="liveIndicator" class="live-indicator" style="display: none;">
        🔴 LIVE
    </div>

    <!-- Private Message Modal -->
    <div id="pmModal" class="messages-modal pm-modal">
        <div class="messages-modal-content">
            <div class="messages-header">
                <h3 id="pmRecipientName">✉️ Private Message</h3>
                <span class="messages-close" id="pmClose">&times;</span>
            </div>
            <div class="pm-messages" id="pmMessages">
                <!-- Messages will be added here -->
            </div>
            <div class="pm-input-group">
                <textarea id="pmInput" class="pm-input" placeholder="Type your message..." rows="2"></textarea>
                <button id="pmSendBtn" class="pm-send-btn">Send</button>
            </div>
        </div>
    </div>

    <!-- Messages List Modal -->
    <div id="messagesModal" class="messages-modal">
        <div class="messages-modal-content">
            <div class="messages-header">
                <h3>✉️ Private Messages</h3>
                <span class="messages-close" id="messagesClose">&times;</span>
            </div>
            <div class="messages-list" id="messagesList">
                <div class="messages-loading">Loading conversations...</div>
            </div>
        </div>
    </div>

    <!-- Settings/Keys Modal -->
    <div id="settingsModal" class="modal-overlay" style="display: none;">
        <div class="modal-content settings-modal">
            <div class="modal-header">
                <h3 class="modal-title">🔑 Key Management</h3>
                <button class="modal-close" onclick="document.getElementById('settingsModal').style.display='none'">&times;</button>
            </div>
            <div class="modal-body">
                <div id="settingsModalMessage" class="settings-modal-message"></div>
                <div id="keySetupPrompt" class="key-setup-prompt">
                    <div id="keySetupQuestion" class="key-setup-question">
                        Generate a new nsec or paste an existing one below
                        <span style="display: block; font-weight: 400; font-size: 0.8rem; color: #bdc3c7; margin-top: 6px;">
                            An <strong>nsec</strong> is your Nostr private key. Keep it secret—anyone who gets it can post as you. Paste your existing nsec below or generate a new keypair.
                        </span>
                    </div>
                    <div class="key-setup-actions">
                        <button id="settingsGenerateKeyBtn" class="key-btn key-choice">🔑 Generate New nsec</button>
                    </div>
                </div>
                <div class="settings-section">
                    <label>PRIVATE KEY, nsec:</label>
                    <div class="key-input-group">
                        <input type="password" id="settingsPrivateKey" placeholder="Enter your nsec private key or generate new" />
                        <button type="button" id="togglePrivateKeyVisibility" class="key-visibility-btn" title="Show/Hide private key">👁️</button>
                        <button type="button" id="deletePrivateKeyBtn" class="key-delete-btn" title="Delete private key" style="display: none;">🗑️</button>
                    </div>
                    <div id="settingsPrivateKeyHint" class="key-hint"></div>
                </div>
                <div class="settings-section">
                    <label>PUBLIC KEY:</label>
                    <div class="key-input-group">
                        <input type="text" id="settingsPublicKey" placeholder="Your public key will appear here" readonly />
                    </div>
                    <button id="updateProfileBtn" type="button" class="profile-btn">🌐 UPDATE TRUSTROOTS PROFILE</button>
                </div>
                <div class="settings-section">
                    <label>TRUSTROOTS USERNAME:</label>
                    <div class="key-input-group">
                        <input type="text" id="trustrootsUsername" placeholder="Enter your Trustroots username (e.g., john)" />
                </div>
                    <div id="usernameStatus" class="username-status" style="margin-top: 4px; font-size: 0.8rem; color: #6c757d; font-style: italic;"></div>
            </div>
                <div class="settings-section">
                    <label>NIP-05 VERIFICATION:</label>
                    <div class="verification-info">
                        <div id="nip05Identifier" class="nip05-identifier" style="margin-bottom: 6px; padding: 6px; background: #f8f9fa; border-radius: 8px; font-family: 'Courier New', monospace; font-size: 0.9rem; color: #2c3e50;"></div>
                        <div id="nip05Url" class="nip05-url" style="margin-bottom: 6px; padding: 6px; background: #f0f8ff; border-radius: 8px; font-family: 'Courier New', monospace; font-size: 0.8rem; color: #1976d2; word-break: break-all; border: 1px solid #bbdefb; display: none;"></div>
                        <div class="verification-actions">
                            <button id="retryProfilePostBtn" class="key-btn" style="display: none;">🔁 RETRY PROFILE POST</button>
                        </div>
                        <div id="verificationStatus" class="verification-status" style="margin-top: 6px; font-size: 0.8rem; font-style: italic;"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Relay Manager Modal -->
    <div id="relayManagerModal" class="modal-overlay" style="display: none;">
        <div class="modal-content relay-modal">
            <div class="modal-header">
                <h3 class="modal-title">⚙️ Relay Manager</h3>
                <button class="modal-close" onclick="document.getElementById('relayManagerModal').style.display='none'">&times;</button>
            </div>
            <div class="modal-body">
                <div class="relay-section">
                    <h4>Add New Relay:</h4>
                    <div class="add-relay-group">
                        <input type="text" id="newRelayUrl" placeholder="wss://relay.example.com" />
                    </div>
                </div>
                <div class="relay-section">
                    <h4>Current Relays:</h4>
                    <div id="relayList" class="relay-list">
                        <!-- Relays will be populated here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Circles Modal -->
    <div id="circlesModal" class="modal-overlay" style="display: none;">
        <div class="modal-content circles-modal">
            <div class="modal-header">
                <h3 class="modal-title">∞ Trustroots Circles</h3>
                <button class="modal-close" onclick="window.tripchatVisualizer.hideCirclesModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="circles-section">
                    <p style="margin-bottom: 16px; color: var(--text-muted); font-size: 0.9rem;">Select a circle to filter messages by community interest:</p>
                    <div id="circlesList" class="circles-list">
                        <!-- Circles will be populated here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        class TRipchatVisualizer {
            constructor() {
                this.relays = [
                    'wss://relay.nomadwiki.org',
                    'wss://relay.trustroots.org'
                ];
                this.relayEnabled = {}; // Track which relays are enabled for reading
                this.postingRelays = {}; // Track which relays are enabled for posting
                
                // Note persistence options
                this.NOTE_PERSISTENCE_OPTIONS = {
                    EPHEMERAL: 'ephemeral',
                    SHORT_TERM: 'short',
                    MEDIUM_TERM: 'medium',
                    LONG_TERM: 'long',
                    PERMANENT: 'permanent'
                };
                this.notes = [];
                this.map = null;
                this.mapMarkers = [];
                this.relayStatus = {};
                this.websockets = {};
                this.subscriptionIds = {};
                this.totalEventsReceived = 0;
                this.searchFilter = '';
                this.geohashFilter = '';
                this.nip05Filter = false;
                // Filter states initialized
                this.initialLoadComplete = false;
                this.completedRelays = new Set(); // Track which relays have completed initial load
                this.geohashRectangles = [];
                this.userProfiles = {}; // Cache for user profiles
                this.profileCache = new Map(); // In-memory cache for profiles
                this.pendingProfileRequests = new Map(); // Track pending profile requests
                this.privateKey = null; // User's private key for posting
                this.shouldPreserveSettingsMessage = false; // Control modal message resets
                
                // Request queue system to limit concurrent REQ requests
                this.requestQueue = [];
                this.activeRequests = 0;
                this.maxConcurrentRequests = 1; // Limit to 1 concurrent request per relay
                this.requestDelay = 2000; // 2 second delay between requests
                this.updatingHash = false; // Flag to prevent circular hash updates
                this.userHasScrolled = false; // Track if user has manually scrolled
                this.datetimeClickHandlerSetup = false; // Flag to prevent duplicate click handlers
                this.highlightEventId = null; // Event ID to highlight and scroll to
                this.init();
            }

            // Persistence preference methods
            savePersistencePreference(persistence) {
                localStorage.setItem('tripchat_note_persistence', persistence);
            }

            loadPersistencePreference() {
                return localStorage.getItem('tripchat_note_persistence') || '1h';
            }

            // Add expiration filtering
            filterExpiredNotes(notes) {
                const now = Math.floor(Date.now() / 1000);
                let expiredCount = 0;
                let permanentCount = 0;
                let validCount = 0;
                
                const filtered = notes.filter(note => {
                    if (note.kind === 20000) {
                        validCount++;
                        return true; // Ephemeral notes handled by relay
                    }
                    
                    const expirationTag = note.tags?.find(tag => tag[0] === 'expires_at');
                    if (!expirationTag) {
                        permanentCount++;
                        return true; // No expiration = permanent
                    }
                    
                    const expiresAt = parseInt(expirationTag[1]);
                    const isValid = now < expiresAt;
                    
                    if (isValid) {
                        validCount++;
                    } else {
                        expiredCount++;
                    }
                    
                    return isValid; // Show if not expired
                });
                
                
                return filtered;
            }

            // Add expiration check
            isExpiringSoon(note, hoursThreshold = 24) {
                if (note.kind === 20000) return false;
                
                const expirationTag = note.tags?.find(tag => tag[0] === 'expires_at');
                if (!expirationTag) return false;
                
                const expiresAt = parseInt(expirationTag[1]);
                const now = Math.floor(Date.now() / 1000);
                const timeLeft = expiresAt - now;
                
                return timeLeft > 0 && timeLeft <= (hoursThreshold * 3600);
            }

            async init() {
                try {
                    this.initMap();
                    this.initializeRelayStatus();
                    this.setupFilterHandlers();
                    this.setupComposeHandlers();
                    this.setupSettingsHandlers();
                    this.setupPMHandlers();
                    this.setupMessagesHandlers();
                    this.setupMapToggleHandlers();
                    this.setupRelayManagerHandlers();
                    this.setupScrollHandlers();
                    this.setupDatetimeClickHandlers(); // Set up click handlers early
                    this.loadFilterFromHash();
                    await this.connectToRelays();
                    
                    // Clean up any profile notes that might have been loaded
                    this.cleanupProfileNotes();
                    
                    // Load saved keys from localStorage
                    this.loadKeysFromStorage();
                } catch (error) {
                    this.displayError('Failed to connect to relays: ' + error.message);
                }
            }

            // Get Trustroots circles data (fetched from actual Trustroots database)
            // Data source: MongoDB query: db.tribes.find({}, {slug: 1, _id: 0})
            // Collection: trust-roots.tribes
            // Last updated: 2024-12-19
            getTrustrootsCircles() {
                return [
                    { slug: 'hitch' },
                    { slug: 'dumpsterdivers' },
                    { slug: 'families' },
                    { slug: 'musicians' },
                    { slug: 'buskers' },
                    { slug: 'veg' },
                    { slug: 'hackers' },
                    { slug: 'lgbtq' },
                    { slug: 'ecoliving' },
                    { slug: 'lindyhoppers' },
                    { slug: 'nomads' },
                    { slug: 'punks' },
                    { slug: 'cyclists' },
                    { slug: 'foodsharing' },
                    { slug: 'yoga' },
                    { slug: 'climbers' },
                    { slug: 'hikers' },
                    { slug: 'sailors' },
                    { slug: 'artists' },
                    { slug: 'rainbowgathering' },
                    { slug: 'slackline' },
                    { slug: 'spirituals' },
                    { slug: 'dancers' },
                    { slug: 'acroyoga' },
                    { slug: 'jugglers' },
                    { slug: 'vanlife' },
                    { slug: 'volunteers' },
                    { slug: 'winemakers' },
                    { slug: 'squatters' },
                    { slug: 'surfers' },
                    { slug: 'skateboarders' },
                    { slug: 'pilgrims' },
                    { slug: 'photographers' },
                    { slug: 'naturists' },
                    { slug: 'motorcyclists' },
                    { slug: 'feminists' },
                    { slug: 'circus' },
                    { slug: 'cooking' },
                    { slug: 'burners' },
                    { slug: 'beerbrewers' },
                    { slug: 'anarchists' },
                    { slug: 'gardeners' },
                    { slug: 'scubadivers' },
                    { slug: 'ravers' },
                    { slug: 'zero-wasters' },
                    { slug: 'activists' },
                    { slug: 'runners' },
                    { slug: 'filmmakers' },
                    { slug: 'books' },
                    { slug: 'cypherpunks' },
                    { slug: 'lightfoot' }
                ];
            }


            initMap() {
                this.map = L.map('map').setView([20, 0], 2);
                
                // Initialize with light theme, will be updated by setTheme
                this.updateMapTheme();
                
                this.styleMap();
                
                // Add keyboard input for geohash filtering
                this.setupMapKeyboardInput();
                
                // Show geohash grid overlay
                this.showGeohashGrid();
                
                // Add zoom event listener to show/hide grid and adjust geohash filter
                this.map.on('zoomend', () => {
                    const currentZoom = this.map.getZoom();
                    
                    // Only adjust geohash filter if user is actively filtering by geohash
                    // Don't interfere with normal map navigation
                    if (this.geohashFilter && this.geohashFilter.length > 0) {
                        let targetLength = 0;
                        
                        // Determine target geohash length based on zoom level
                        if (currentZoom <= 2) {
                            targetLength = 0; // Global view - no geohash
                        } else if (currentZoom <= 4) {
                            targetLength = 1; // Single character level
                        } else if (currentZoom <= 6) {
                            targetLength = 2; // Two character level
                        } else if (currentZoom <= 8) {
                            targetLength = 3; // Three character level
                        } else if (currentZoom <= 10) {
                            targetLength = 4; // Four character level
                        } else if (currentZoom <= 12) {
                            targetLength = 5; // Five character level
                        } else {
                            targetLength = 6; // Six character level (final)
                        }
                        
                        // Only adjust if the current geohash is longer than target
                        if (this.geohashFilter.length > targetLength) {
                            if (targetLength === 0) {
                                // Clear geohash filter for global view
                                this.geohashFilter = '';
                                const geohashFilterInput = document.getElementById('geohashFilter');
                                if (geohashFilterInput) {
                                    geohashFilterInput.value = '';
                                }
                                this.updateHash();
                                this.showGeohashGrid();
                            } else {
                                // Truncate geohash to match zoom level
                                const newGeohash = this.geohashFilter.substring(0, targetLength);
                                this.geohashFilter = newGeohash;
                                const geohashFilterInput = document.getElementById('geohashFilter');
                                if (geohashFilterInput) {
                                    geohashFilterInput.value = newGeohash;
                                }
                                this.updateHash();
                                
                                // Show appropriate grid for the new geohash length
                                if (newGeohash.length < 6) {
                                    this.showNextLevelGeohashGrid(newGeohash);
                                } else {
                                    this.highlightGeohashArea(newGeohash);
                                }
                            }
                        } else {
                            // Show appropriate grid for current geohash
                            if (this.geohashFilter.length < 6) {
                                this.showNextLevelGeohashGrid(this.geohashFilter);
                            } else {
                                this.highlightGeohashArea(this.geohashFilter);
                            }
                        }
                    } else {
                        // No geohash filter - show global grid when zoomed out
                        if (currentZoom <= 3) {
                            this.showGeohashGrid();
                        }
                    }
                });
                
                // Map initialized
            }

            setupMapKeyboardInput() {
                // Add keyboard event listener to the map container
                const mapContainer = document.getElementById('map');
                if (!mapContainer) return;

                mapContainer.addEventListener('keydown', (e) => {
                    // Only handle input if the map is focused and no other input is focused
                    if (document.activeElement === mapContainer || 
                        (document.activeElement && document.activeElement.tagName === 'BODY')) {
                        
                        // Don't interfere with special keys
                        if (e.ctrlKey || e.metaKey || e.altKey) return;
                        
                        // Handle special keys
                        if (e.key === 'Backspace') {
                            // Remove last character from geohash filter
                            const geohashFilter = document.getElementById('geohashFilter');
                            if (geohashFilter) {
                                geohashFilter.value = geohashFilter.value.slice(0, -1);
                                this.geohashFilter = geohashFilter.value.trim().toLowerCase();
                                this.updateHash();
                                this.displayActivities(this.notes);
                                this.plotActivitiesOnMap(this.notes);
                                
                                // If still filtering by a specific geohash, show its rectangle and move map
                                if (this.geohashFilter && this.isGeohash(this.geohashFilter)) {
                                    this.highlightGeohashArea(this.geohashFilter);
                                } else {
                                    // Clear geohash rectangles and show whole world if no valid geohash
                                    this.geohashRectangles.forEach(rect => this.map.removeLayer(rect));
                                    this.geohashRectangles = [];
                                    this.showWholeWorld();
                                }
                            }
                            e.preventDefault();
                            return;
                        }
                        
                        if (e.key === 'Enter') {
                            // Clear geohash filter
                            const geohashFilter = document.getElementById('geohashFilter');
                            if (geohashFilter) {
                                geohashFilter.value = '';
                                this.geohashFilter = '';
                                this.updateHash();
                                this.displayActivities(this.notes);
                                this.plotActivitiesOnMap(this.notes);
                                
                                // Clear geohash rectangles and show whole world
                                this.geohashRectangles.forEach(rect => this.map.removeLayer(rect));
                                this.geohashRectangles = [];
                                this.showWholeWorld();
                            }
                            e.preventDefault();
                            return;
                        }
                        
                        if (e.key === 'Escape') {
                            // Clear geohash filter
                            const geohashFilter = document.getElementById('geohashFilter');
                            if (geohashFilter) {
                                geohashFilter.value = '';
                                this.geohashFilter = '';
                                this.updateHash();
                                this.displayActivities(this.notes);
                                this.plotActivitiesOnMap(this.notes);
                                
                                // Clear geohash rectangles and show whole world
                                this.geohashRectangles.forEach(rect => this.map.removeLayer(rect));
                                this.geohashRectangles = [];
                                this.showWholeWorld();
                            }
                            e.preventDefault();
                            return;
                        }
                        
                        // Only allow geohash characters (base32: 0-9, a-z, A-Z excluding i, l, o)
                        const geohashChars = /^[0-9bcdefghjkmnpqrstuvwxyz]$/i;
                        if (geohashChars.test(e.key)) {
                            // Add character to geohash filter
                            const geohashFilter = document.getElementById('geohashFilter');
                            if (geohashFilter) {
                                geohashFilter.value += e.key.toLowerCase();
                                this.geohashFilter = geohashFilter.value.trim().toLowerCase();
                                this.updateHash();
                                this.displayActivities(this.notes);
                                this.plotActivitiesOnMap(this.notes);
                                
                                // If filtering by a specific geohash, show its rectangle and move map
                                if (this.geohashFilter && this.isGeohash(this.geohashFilter)) {
                                    this.highlightGeohashArea(this.geohashFilter);
                                }
                            }
                            e.preventDefault();
                        }
                    }
                });

                // Make the map focusable
                mapContainer.setAttribute('tabindex', '0');
                mapContainer.style.outline = 'none'; // Remove focus outline
            }

            showWholeWorld() {
                // Reset map view to show the whole world
                if (this.map) {
                    this.map.setView([20, 0], 2);
                    // Show geohash grid when showing whole world
                    this.showGeohashGrid();
                }
            }

            styleMap() {
                const style = document.createElement('style');
                style.textContent = `
                    .custom-map-tiles {
                        /* Clean, light map tiles - no filters needed for CartoDB Positron */
                    }
                    .leaflet-container {
                        background: #f8f9fa;
                    }
                    .leaflet-control-zoom a {
                        background: #2c3e50;
                        color: #ffffff;
                        border: 1px solid #34495e;
                        font-family: 'Inter', sans-serif;
                        font-weight: 600;
                        width: 32px;
                        height: 32px;
                        line-height: 32px;
                        text-align: center;
                        font-size: 16px;
                        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
                        transition: all 0.3s ease;
                    }
                    .leaflet-control-zoom a:hover {
                        background: var(--accent-color);
                        color: #ffffff;
                        border-color: var(--accent-color);
                        transform: translateY(-1px);
                        box-shadow: 0 4px 12px var(--shadow-hover);
                    }
                    .leaflet-control-zoom {
                        border: 1px solid #34495e;
                        border-radius: 8px;
                        background: #2c3e50;
                        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
                    }
                    .leaflet-control-zoom a:first-child {
                        border-bottom: 1px solid #34495e;
                        border-radius: 8px 8px 0 0;
                    }
            .leaflet-control-zoom a:last-child {
                border-radius: 0 0 8px 8px;
            }
            
            /* Dark mode attribution styling */
            .leaflet-control-attribution {
                background: rgba(44, 62, 80, 0.9) !important;
                color: #bdc3c7 !important;
                border: 1px solid #34495e !important;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3) !important;
                font-size: 11px !important;
                padding: 4px 8px !important;
                border-radius: 4px !important;
            }
            
            .leaflet-control-attribution a {
                color: #3498db !important;
                text-decoration: none !important;
            }
            
            .leaflet-control-attribution a:hover {
                color: #5dade2 !important;
                text-decoration: underline !important;
            }
                    .leaflet-popup-content-wrapper {
                        background: #ffffff;
                        border-radius: 12px;
                        border: 1px solid #e9ecef;
                        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
                        color: #2c3e50;
                        font-family: 'Inter', sans-serif;
                    }
                    .leaflet-popup-tip {
                        background: #ffffff;
                        border: 1px solid #e9ecef;
                    }
                    .leaflet-popup-content {
                        color: #2c3e50;
                        font-family: 'Inter', sans-serif;
                        margin: 16px;
                    }
                    .leaflet-popup-content .note-title {
                        color: var(--accent-color);
                        font-weight: 700;
                        font-size: 1rem;
                        margin-bottom: 8px;
                    }
                    .leaflet-popup-content .popup-content {
                        color: #2c3e50;
                        line-height: 1.5;
                        margin-bottom: 8px;
                    }
                    .leaflet-popup-content .popup-time {
                        color: #6c757d;
                        font-size: 0.9rem;
                        font-style: italic;
                    }
            .leaflet-popup-content .popup-location {
                        color: var(--accent-color);
                        font-weight: 600;
                        font-size: 0.9rem;
                        margin-top: 8px;
                    }
                    .leaflet-popup-close-button {
                        color: #6c757d;
                        font-size: 18px;
                    font-weight: bold;
                        padding: 8px;
                    }
                    .leaflet-popup-close-button:hover {
                        color: #dc3545;
                    }
                    .tripchat-marker {
                        transition: all 0.3s ease;
                        animation: pulse 2s infinite;
                        z-index: 1000;
                    }
                    .tripchat-marker:hover {
                        fillColor: 'var(--accent-hover)';
                        box-shadow: 0 2px 8px var(--shadow-hover);
                        animation: none;
                    }
                    @keyframes pulse {
                        0% {
                            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
                        }
                        50% {
                            box-shadow: 0 2px 8px var(--shadow-hover);
                        }
                        100% {
                            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
                        }
                    }
                    .geohash-rectangle {
                        transition: all 0.3s ease;
                        z-index: 100;
                    }
                    .geohash-highlight {
                        transition: all 0.3s ease;
                        animation: pulse 2s infinite;
                    }
                    .geohash-grid-cell {
                        transition: all 0.3s ease;
                    }
                    .geohash-grid-cell:hover {
                        opacity: 0.7 !important;
                        fill-opacity: 0.08 !important;
                        stroke-width: 2px !important;
                    }
                    .geohash-grid-label {
                        transition: all 0.2s ease;
                    }
                    .geohash-grid-label:hover {
                        transform: scale(1.05);
                        box-shadow: 0 4px 12px rgba(0,0,0,0.4) !important;
                    }
                    @keyframes pulse {
                        0% { opacity: 0.8; }
                        50% { opacity: 0.4; }
                        100% { opacity: 0.8; }
                    }
                `;
                document.head.appendChild(style);
            }

            setupFilterHandlers() {
                const searchFilter = document.getElementById('searchFilter');
                const geohashFilter = document.getElementById('geohashFilter');
                const nip05Filter = document.getElementById('nip05Filter');
                const circlesButton = document.getElementById('circlesButton');

                searchFilter.addEventListener('input', (e) => {
                    this.searchFilter = e.target.value.trim().toLowerCase();
                    this.updateHash();
                    this.displayActivities(this.notes);
                    this.plotActivitiesOnMap(this.notes);
                });

                circlesButton.addEventListener('click', () => {
                    this.showCirclesModal();
                });

                geohashFilter.addEventListener('input', (e) => {
                    this.geohashFilter = e.target.value.trim().toLowerCase();
                    this.updateHash();
                    this.displayActivities(this.notes);
                    this.plotActivitiesOnMap(this.notes);
                    
                    // If filtering by a specific geohash, show its rectangle
                    if (this.geohashFilter && this.isGeohash(this.geohashFilter)) {
                        this.highlightGeohashArea(this.geohashFilter);
                    } else {
                        // Clear geohash rectangles and show whole world if no valid geohash
                        this.geohashRectangles.forEach(rect => this.map.removeLayer(rect));
                        this.geohashRectangles = [];
                        this.showWholeWorld();
                    }
                });


                nip05Filter.addEventListener('change', (e) => {
                    this.nip05Filter = e.target.checked;
                    this.updateHash();
                    this.displayActivities(this.notes);
                    this.plotActivitiesOnMap(this.notes);
                });




                // Listen for hash changes (when user manually changes URL)
                window.addEventListener('hashchange', () => {
                    // Only process hash changes if we're not programmatically updating the hash
                    if (!this.updatingHash) {
                        this.loadFilterFromHash();
                        this.plotActivitiesOnMap(this.notes);
                    }
                });
            }

            showCirclesModal() {
                const modal = document.getElementById('circlesModal');
                const circlesList = document.getElementById('circlesList');
                
                // Clear existing circles
                circlesList.innerHTML = '';
                
                // Get Trustroots circles
                const circles = this.getTrustrootsCircles();
                
                // Create circle items
                circles.forEach(circle => {
                    const circleItem = document.createElement('div');
                    circleItem.className = 'circle-item';
                    circleItem.textContent = `#${circle.slug}`;
                    circleItem.title = `#${circle.slug}`;
                    
                    circleItem.addEventListener('click', () => {
                        // Set the circle hashtag in the search filter
                        const hashtag = `#${circle.slug}`;
                        this.searchFilter = hashtag;
                        
                        const searchFilterInput = document.getElementById('searchFilter');
                        if (searchFilterInput) {
                            searchFilterInput.value = hashtag;
                        }
                        
                        // Update display and hash
                        this.updateHash();
                        this.displayActivities(this.notes);
                        this.plotActivitiesOnMap(this.notes);
                        
                        // Close modal
                        this.hideCirclesModal();
                    });
                    
                    circlesList.appendChild(circleItem);
                });
                
                // Show modal
                modal.style.display = 'flex';
                
                // Add ESC key listener
                this.escKeyHandler = (e) => {
                    if (e.key === 'Escape') {
                        this.hideCirclesModal();
                    }
                };
                document.addEventListener('keydown', this.escKeyHandler);
            }

            hideCirclesModal() {
                const modal = document.getElementById('circlesModal');
                modal.style.display = 'none';
                
                // Remove ESC key listener
                if (this.escKeyHandler) {
                    document.removeEventListener('keydown', this.escKeyHandler);
                    this.escKeyHandler = null;
                }
            }

            setTheme(theme) {
                document.documentElement.setAttribute('data-theme', theme);
                const darkModeToggle = document.getElementById('darkModeToggle');
                if (darkModeToggle) {
                    darkModeToggle.textContent = theme === 'dark' ? '☀️' : '🌙';
                }
                this.updateMapTheme();
            }

            updateMapTheme() {
                if (!this.map) return;
                
                // Remove existing tile layer
                this.map.eachLayer((layer) => {
                    if (layer instanceof L.TileLayer) {
                        this.map.removeLayer(layer);
                    }
                });
                
                const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
                
                if (isDark) {
                    // Dark theme map
                    L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                        attribution: '© OpenStreetMap contributors, © CARTO',
                        className: 'custom-map-tiles',
                        subdomains: 'abcd',
                        maxZoom: 19
                    }).addTo(this.map);
                } else {
                    // Light theme map
                    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
                        attribution: '© OpenStreetMap contributors, © CARTO',
                        className: 'custom-map-tiles',
                        subdomains: 'abcd',
                        maxZoom: 19
                    }).addTo(this.map);
                }
            }

            setupComposeHandlers() {
                const composeBtn = document.getElementById('composeBtn');

                // Initialize the compose form since it's always visible

                // Compose button is now hidden since form is always visible
                // composeBtn.addEventListener('click', () => { ... });

                // Set default persistence preference
                const persistenceSelect = document.getElementById('notePersistence');
                if (persistenceSelect) {
                    const savedPreference = this.loadPersistencePreference();
                    console.log('Loading persistence preference:', savedPreference);
                    persistenceSelect.value = savedPreference;
                    console.log('Set persistence select value to:', persistenceSelect.value);
                    
                    // Save preference when changed
                    persistenceSelect.addEventListener('change', (e) => {
                        console.log('Persistence changed to:', e.target.value);
                        this.savePersistencePreference(e.target.value);
                    });
                }

                // Dark mode toggle
                const darkModeToggle = document.getElementById('darkModeToggle');
                if (darkModeToggle) {
                    // Load saved theme
                    const savedTheme = localStorage.getItem('theme') || 'light';
                    this.setTheme(savedTheme);
                    
                    darkModeToggle.addEventListener('click', () => {
                        const currentTheme = document.documentElement.getAttribute('data-theme');
                        const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
                        this.setTheme(newTheme);
                        localStorage.setItem('theme', newTheme);
                    });
                }


                // Add Enter and Shift+Enter functionality to textarea
                const composeContent = document.getElementById('composeContent');
                if (composeContent) {
                    composeContent.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' && !e.shiftKey) {
                            // Enter sends the note
                            e.preventDefault();
                            this.postNote();
                        }
                        // Shift+Enter allows multiline content (default behavior)
                    });
                }

                // Note: Modal click handler removed since we're using inline compose form
            }

            setupSettingsHandlers() {
                const settingsBtn = document.getElementById('settingsBtn');
                const settingsModal = document.getElementById('settingsModal');
                const settingsGenerateKeyBtn = document.getElementById('settingsGenerateKeyBtn');
                const updateProfileBtn = document.getElementById('updateProfileBtn');
                const settingsPrivateKey = document.getElementById('settingsPrivateKey');
                const settingsPublicKey = document.getElementById('settingsPublicKey');
                const settingsPrivateKeyHint = document.getElementById('settingsPrivateKeyHint');
                const trustrootsUsername = document.getElementById('trustrootsUsername');
                const usernameStatus = document.getElementById('usernameStatus');
                const nip05Identifier = document.getElementById('nip05Identifier');
                const nip05Url = document.getElementById('nip05Url');
                const retryProfilePostBtn = document.getElementById('retryProfilePostBtn');
                const verificationStatus = document.getElementById('verificationStatus');

                // Update username status display
                const updateUsernameStatus = () => {
                    const savedUsername = localStorage.getItem('tripchat_trustroots_username');
                    
                    if (savedUsername) {
                        usernameStatus.textContent = `Press Enter to verify ${savedUsername}`;
                        usernameStatus.style.color = 'var(--accent-color)';
                    } else {
                        usernameStatus.textContent = 'No username saved yet';
                        usernameStatus.style.color = '#6c757d';
                    }
                };

                // Update NIP-05 identifier display
                const updateNip05Display = () => {
                    const savedUsername = localStorage.getItem('tripchat_trustroots_username');
                    const npub = localStorage.getItem('tripchat_npub');
                    
                    if (savedUsername && npub) {
                        const identifier = `${savedUsername}@trustroots.org`;
                        nip05Identifier.textContent = identifier;
                        nip05Identifier.style.display = 'block';
                        nip05Url.textContent = '';
                        nip05Url.style.display = 'none';
                    } else {
                        nip05Identifier.textContent = 'Enter username and generate keys first';
                        nip05Identifier.style.display = 'block';
                        nip05Url.textContent = '';
                        nip05Url.style.display = 'none';
                    }
                };

                settingsBtn.addEventListener('click', () => {
                    // Load current keys into settings modal
                    const nsecKey = localStorage.getItem('tripchat_nsec');
                    const npubKey = localStorage.getItem('tripchat_npub');
                    const savedUsername = localStorage.getItem('tripchat_trustroots_username');
                    
                    if (nsecKey) {
                        settingsPrivateKey.value = nsecKey;
                        // Only hide the field if there's an existing nsec key
                        settingsPrivateKey.type = 'password';
                        // Update toggle button state
                        const toggleBtn = document.getElementById('togglePrivateKeyVisibility');
                        if (toggleBtn) {
                            toggleBtn.textContent = '👁️';
                            toggleBtn.title = 'Show private key';
                        }
                        
                        // Show security reminder for existing keys
                        this.shouldPreserveSettingsMessage = true; // Preserve the message
                        this.setSettingsModalMessage('🔐 <strong>Security Reminder:</strong> Did you already safely store your nsec in your password manager? We recommend <a href="https://bitwarden.com/" target="_blank" rel="noopener noreferrer">Bitwarden</a> if you don\'t have one yet.');
                    } else {
                        // No existing key - keep field visible for typing
                        settingsPrivateKey.type = 'text';
                        // Update toggle button state
                        const toggleBtn = document.getElementById('togglePrivateKeyVisibility');
                        if (toggleBtn) {
                            toggleBtn.textContent = '🙈';
                            toggleBtn.title = 'Hide private key';
                        }
                        
                        // Clear any existing message for new users
                        this.setSettingsModalMessage('');
                    }
                    if (npubKey) {
                        settingsPublicKey.value = npubKey;
                    }
                    if (settingsPrivateKeyHint) {
                        settingsPrivateKeyHint.style.display = 'none';
                        settingsPrivateKeyHint.innerHTML = '';
                    }
                    if (savedUsername) {
                        trustrootsUsername.value = savedUsername;
                    }
                    
                    // Update displays after a short delay to ensure DOM is ready
                    setTimeout(() => {
                        updateUsernameStatus();
                        updateNip05Display();
                        this.highlightKeyInputs();
                        this.toggleKeyButtonsVisibility();
                        this.updateDeleteButtonVisibility();
                    }, 100);

                    if (!this.shouldPreserveSettingsMessage) {
                        this.setSettingsModalMessage('');
                    }

                    settingsModal.style.display = 'flex';
                    this.shouldPreserveSettingsMessage = false;
                });

                // Close modal when clicking outside
                settingsModal.addEventListener('click', (e) => {
                    if (e.target === settingsModal) {
                        settingsModal.style.display = 'none';
                        this.setSettingsModalMessage('');
                    }
                });

                // Close modal when pressing ESC
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && settingsModal.style.display === 'flex') {
                        settingsModal.style.display = 'none';
                        this.setSettingsModalMessage('');
                    }
                });

                settingsGenerateKeyBtn.addEventListener('click', async () => {
                    try {
                        const { nsecKey, npubKey } = await this.generateKeyPair();
                        settingsPrivateKey.value = nsecKey;
                        settingsPublicKey.value = npubKey;
                        
                        // Save to localStorage
                        localStorage.setItem('tripchat_nsec', nsecKey);
                        localStorage.setItem('tripchat_npub', npubKey);
                        
                        // Set class property for immediate use
                        this.privateKey = nsecKey;
                        
                        if (settingsPrivateKeyHint) {
                            settingsPrivateKeyHint.innerHTML = 'Store this nsec safely in your password manager. We recommend <a href="https://bitwarden.com/" target="_blank" rel="noopener noreferrer">Bitwarden</a> if you don\'t have one yet.';
                            settingsPrivateKeyHint.style.display = 'block';
                        }
                        // Keep generated key visible so user can copy it
                        settingsPrivateKey.type = 'text';
                        // Update toggle button state for generated key
                        const toggleBtn = document.getElementById('togglePrivateKeyVisibility');
                        if (toggleBtn) {
                            toggleBtn.textContent = '🙈';
                            toggleBtn.title = 'Hide private key';
                        }
                        this.highlightKeyInputs();
                        this.toggleKeyButtonsVisibility();
                        this.updateDeleteButtonVisibility();
                        
                        // Re-subscribe to DMs with new keys
                        this.subscribeToDMs();
                    } catch (error) {
                        console.error('Error generating key:', error);
                        alert('Error generating keys. Please try again.');
                    }
                });

                // Toggle private key visibility
                const togglePrivateKeyVisibility = document.getElementById('togglePrivateKeyVisibility');
                if (togglePrivateKeyVisibility) {
                    togglePrivateKeyVisibility.addEventListener('click', () => {
                        const isPassword = settingsPrivateKey.type === 'password';
                        settingsPrivateKey.type = isPassword ? 'text' : 'password';
                        togglePrivateKeyVisibility.textContent = isPassword ? '🙈' : '👁️';
                        togglePrivateKeyVisibility.title = isPassword ? 'Hide private key' : 'Show private key';
                    });
                }

                // Delete private key functionality
                const deletePrivateKeyBtn = document.getElementById('deletePrivateKeyBtn');
                if (deletePrivateKeyBtn) {
                    deletePrivateKeyBtn.addEventListener('click', () => {
                        this.showDeleteKeyWarning();
                    });
                }

                // Auto-validate and process nsec when pasted or typed
                settingsPrivateKey.addEventListener('input', async () => {
                    const nsecInput = settingsPrivateKey.value.trim();
                    
                    // Only process if it looks like an nsec (starts with 'nsec1')
                    if (nsecInput.startsWith('nsec1') && nsecInput.length > 10) {
                        try {
                            // Validate the nsec format
                            const privateKeyHex = this.nsecToHex(nsecInput);
                            const npubKey = this.deriveNpubFromPrivateKey(privateKeyHex);
                            
                            // Update the public key field
                            settingsPublicKey.value = npubKey;
                            
                            // Save to localStorage
                            localStorage.setItem('tripchat_nsec', nsecInput);
                            localStorage.setItem('tripchat_npub', npubKey);
                            
                            // Set class property for immediate use
                            this.privateKey = nsecInput;
                            
                            // Hide the field now that we have a valid key
                            settingsPrivateKey.type = 'password';
                            
                            // Update toggle button state
                            const toggleBtn = document.getElementById('togglePrivateKeyVisibility');
                            if (toggleBtn) {
                                toggleBtn.textContent = '👁️';
                                toggleBtn.title = 'Show private key';
                            }
                            
                            // Show success feedback
                            if (settingsPrivateKeyHint) {
                                settingsPrivateKeyHint.innerHTML = '✅ Valid nsec key! Public key derived and saved.';
                                settingsPrivateKeyHint.style.display = 'block';
                                settingsPrivateKeyHint.style.color = '#22c55e';
                            }
                            
                            // Auto-population temporarily disabled
                            
                            // Hide the generate button since we have a valid key
                            const generateBtn = document.getElementById('settingsGenerateKeyBtn');
                            if (generateBtn) {
                                generateBtn.style.display = 'none';
                            }
                            
                            // Clear the setup message since we now have valid keys
                            this.setSettingsModalMessage('');
                            
                            // Focus on Trustroots username field for next step
                            setTimeout(() => {
                                const trustrootsUsername = document.getElementById('trustrootsUsername');
                                if (trustrootsUsername) {
                                    trustrootsUsername.focus();
                                    console.log('🎯 Focused on Trustroots username field');
                                } else {
                                    console.log('⚠️ Trustroots username field not found');
                                }
                            }, 100);
                            
                            this.highlightKeyInputs();
                            this.toggleKeyButtonsVisibility();
                            this.updateDeleteButtonVisibility();
                            
                            // Re-subscribe to DMs with new keys
                            this.subscribeToDMs();
                            
                            console.log('nsec key automatically processed and saved');
                        } catch (error) {
                            console.error('Error processing private key:', error);
                            if (settingsPrivateKeyHint) {
                                settingsPrivateKeyHint.innerHTML = '❌ Invalid nsec format. Please check your key.';
                                settingsPrivateKeyHint.style.display = 'block';
                                settingsPrivateKeyHint.style.color = '#dc3545';
                            }
                        }
                    } else if (nsecInput.length > 0) {
                        // Clear hint if input doesn't look like nsec
                        if (settingsPrivateKeyHint) {
                            settingsPrivateKeyHint.style.display = 'none';
                            settingsPrivateKeyHint.innerHTML = '';
                        }
                        
                        // Show generate button if input doesn't look like nsec
                        const generateBtn = document.getElementById('settingsGenerateKeyBtn');
                        if (generateBtn) {
                            generateBtn.style.display = '';
                        }
                    } else {
                        // Clear hint if input is empty
                        if (settingsPrivateKeyHint) {
                            settingsPrivateKeyHint.style.display = 'none';
                            settingsPrivateKeyHint.innerHTML = '';
                        }
                        
                        // Show the field again if it's empty (no existing key)
                        const existingNsec = localStorage.getItem('tripchat_nsec');
                        if (!existingNsec) {
                            settingsPrivateKey.type = 'text';
                            const toggleBtn = document.getElementById('togglePrivateKeyVisibility');
                            if (toggleBtn) {
                                toggleBtn.textContent = '🙈';
                                toggleBtn.title = 'Hide private key';
                            }
                        }
                        
                        // Show generate button if input is empty
                        const generateBtn = document.getElementById('settingsGenerateKeyBtn');
                        if (generateBtn) {
                            generateBtn.style.display = '';
                        }
                    }
                });

                updateProfileBtn.addEventListener('click', async (event) => {
                    event.preventDefault();
                    const npub = settingsPublicKey.value.trim();
                    if (npub) {
                        try {
                            await navigator.clipboard.writeText(npub);
                            alert('Your public key has been copied to the clipboard. Please paste this npub into the Nostr field on Trustroots.');
                        } catch (clipboardError) {
                            console.warn('Failed to copy public key to clipboard:', clipboardError);
                            alert('Could not copy the public key automatically. Please copy it manually before updating Trustroots and paste it into the Nostr field.');
                        }
                    }
                    window.open('https://www.trustroots.org/profile/edit/networks', '_blank');
                });

                // Trustroots username handlers
                // Verify NIP-05 identifier
                const verifyNip05 = async () => {
                    const savedUsername = localStorage.getItem('tripchat_trustroots_username');
                    const npub = localStorage.getItem('tripchat_npub');
                    
                    if (!savedUsername || !npub) {
                        verificationStatus.textContent = 'Please enter username and generate keys first';
                        verificationStatus.style.color = '#dc3545';
                        return;
                    }

                    verificationStatus.textContent = 'Verifying...';
                    verificationStatus.style.color = '#6c757d';
                    console.log('🔍 Starting NIP-05 verification', { savedUsername, npub });

                    try {
                        const identifier = `${savedUsername}@trustroots.org`;
                        const verificationUrl = `https://trustroots.org/.well-known/nostr.json?name=${savedUsername}`;
                        console.log('🌐 Fetching verification URL:', verificationUrl);
                        
                        const response = await fetch(verificationUrl);
                        console.log('📥 Received response status:', response.status);
                        const data = await response.json();
                        console.log('📄 Parsed verification data:', data);

                        if (data.names && data.names[savedUsername]) {
                            const hexPubkey = data.names[savedUsername];
                            console.log('✅ Trustroots returned pubkey:', hexPubkey);
                            
                            // Convert hex to npub for comparison
                            let expectedNpub;
                            try {
                                if (typeof window.nostrTools !== 'undefined') {
                                    expectedNpub = window.nostrTools.nip19.npubEncode(hexPubkey);
                                } else {
                                    // Fallback conversion using the class method
                                    expectedNpub = window.tripchatVisualizer.hexToNpub(hexPubkey);
                                }
                            } catch (conversionError) {
                                console.error('Error converting hex to npub:', conversionError);
                                expectedNpub = null;
                            }
                            
                            if (expectedNpub && expectedNpub === npub) {
                                console.log('🎉 NIP-05 verification matched npub');
                                verificationStatus.textContent = '✓ NIP-05 verification successful!';
                                verificationStatus.style.color = 'var(--accent-color)';
                                
                                // Post kind 0 profile event to Nostr after successful verification
                                verificationStatus.textContent = '✓ NIP-05 verified! Posting profile to Nostr...';
                                try {
                                    console.log('📝 Posting profile to Nostr...');
                                    const profilePosted = await this.postProfileToNostr(savedUsername, npub);
                                    if (profilePosted) {
                                        console.log('🚀 Profile posted to at least one relay');
                                        verificationStatus.innerHTML = '✓ NIP-05 verified<br/>✓ Profile posted to Nostr!';
                                        verificationStatus.style.color = 'var(--accent-color)';
                                        
                                        // Hide retry button on success
                                        const retryProfilePostBtn = document.getElementById('retryProfilePostBtn');
                                        if (retryProfilePostBtn) {
                                            retryProfilePostBtn.style.display = 'none';
                                        }
                                        
                                        this.toggleKeyButtonsVisibility();
                                    } else {
                                        console.warn('⚠️ Profile post returned false');
                                        verificationStatus.innerHTML = '<span style="color: var(--accent-color);">✓ NIP-05 verified</span><br/><span style="color: #f39c12;">❌ Failed to post profile to Nostr</span>';
                                        verificationStatus.style.color = 'inherit';
                                        
                                        // Show retry button for profile posting
                                        const retryProfilePostBtn = document.getElementById('retryProfilePostBtn');
                                        if (retryProfilePostBtn) {
                                            retryProfilePostBtn.style.display = 'inline-block';
                                        }
                                    }
                                } catch (error) {
                                    console.error('Error posting profile:', error);
                                    verificationStatus.innerHTML = '<span style="color: var(--accent-color);">✓ NIP-05 verified</span><br/><span style="color: #f39c12;">❌ Failed to post profile to Nostr</span>';
                                    verificationStatus.style.color = 'inherit';
                                    
                                    // Show retry button for profile posting
                                    const retryProfilePostBtn = document.getElementById('retryProfilePostBtn');
                                    if (retryProfilePostBtn) {
                                        retryProfilePostBtn.style.display = 'inline-block';
                                    }
                                }
                            } else {
                                console.warn('❌ NIP-05 pubkey mismatch', { expectedNpub, npub });
                                verificationStatus.textContent = `✗ NIP-05 verification failed. Expected: ${expectedNpub}, Got: ${npub}`;
                                verificationStatus.style.color = '#dc3545';
                                this.toggleKeyButtonsVisibility();
                            }
                        } else {
                            console.warn('⚠️ Username not found in Trustroots data', data);
                            verificationStatus.textContent = '✗ NIP-05 verification failed. Username not found in Trustroots data.';
                            verificationStatus.style.color = '#dc3545';
                            this.toggleKeyButtonsVisibility();
                        }
                    } catch (error) {
                        console.error('NIP-05 verification error:', error);
                        verificationStatus.textContent = '✗ Verification failed. Check your internet connection.';
                        verificationStatus.style.color = '#dc3545';
                        this.toggleKeyButtonsVisibility();
                    }
                    this.toggleKeyButtonsVisibility();
                };

                retryProfilePostBtn.addEventListener('click', async () => {
                    const savedUsername = localStorage.getItem('tripchat_trustroots_username');
                    const npub = localStorage.getItem('tripchat_npub');
                    if (!savedUsername || !npub) {
                        alert('Please ensure you have generated keys and saved your Trustroots username first.');
                        return;
                    }

                    console.log('🔁 Manual retry requested for profile post', { savedUsername, npub });
                    verificationStatus.textContent = 'Retrying profile post...';
                    verificationStatus.style.color = '#6c757d';

                    try {
                        const profilePosted = await this.postProfileToNostr(savedUsername, npub);
                        if (profilePosted) {
                            console.log('✅ Manual retry succeeded');
                            verificationStatus.textContent = '✓ Profile posted to Nostr!';
                            verificationStatus.style.color = 'var(--accent-color)';
                        } else {
                            console.warn('⚠️ Manual retry reported failure');
                            verificationStatus.textContent = '✗ Failed to post profile. Please try again later or confirm relay connectivity.';
                            verificationStatus.style.color = '#dc3545';
                        }
                    } catch (error) {
                        console.error('❌ Error during manual profile post retry:', error);
                        verificationStatus.textContent = '✗ Error posting profile. Check console for details.';
                        verificationStatus.style.color = '#dc3545';
                    }
                    this.toggleKeyButtonsVisibility();
                });

                // Event listeners

                // Auto-save username when typing (with debounce)
                let usernameTimeout;
                trustrootsUsername.addEventListener('input', () => {
                    clearTimeout(usernameTimeout);
                    usernameTimeout = setTimeout(() => {
                        const username = trustrootsUsername.value.trim();
                        if (username) {
                            localStorage.setItem('tripchat_trustroots_username', username);
                            updateUsernameStatus();
                            updateNip05Display();
                        }
                    }, 500); // 500ms delay
                });

                const handleManualUsernameSave = () => {
                    const username = trustrootsUsername.value.trim();
                    if (username) {
                        localStorage.setItem('tripchat_trustroots_username', username);
                        updateUsernameStatus();
                        updateNip05Display();
                        alert(`Trustroots username "${username}" saved successfully!`);
                    } else {
                        alert('Please enter a valid Trustroots username.');
                    }
                };

                // Allow NIP-05 verification with Enter key
                trustrootsUsername.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        // Save username first, then trigger verification
                        const username = trustrootsUsername.value.trim();
                        if (username) {
                            localStorage.setItem('tripchat_trustroots_username', username);
                            updateUsernameStatus();
                            updateNip05Display();
                            // Trigger NIP-05 verification
                            verifyNip05();
                        }
                    }
                });
            }

            setSettingsModalMessage(message) {
                const messageElement = document.getElementById('settingsModalMessage');
                if (!messageElement) {
                    console.warn('Settings modal message element not found.');
                    return;
                }

                if (message) {
                    messageElement.innerHTML = message;
                    messageElement.style.display = 'block';
                } else {
                    messageElement.innerHTML = '';
                    messageElement.style.display = 'none';
                }
            }

            enableAutoSelect(input) {
                if (!input) {
                    return;
                }

                if (input.dataset.autoselectInitialized === 'true') {
                    return;
                }

                input.addEventListener('focus', () => {
                    // Delay selection to ensure focus styling applies first
                    setTimeout(() => {
                        if (document.activeElement === input) {
                            input.select();
                        }
                    }, 0);
                });
                input.dataset.autoselectInitialized = 'true';
            }

            highlightKeyInputs() {
                const privateKeyInput = document.getElementById('settingsPrivateKey');
                const publicKeyInput = document.getElementById('settingsPublicKey');

                this.enableAutoSelect(privateKeyInput);
                this.enableAutoSelect(publicKeyInput);

                if (privateKeyInput) {
                    privateKeyInput.focus();
                    if (privateKeyInput.value) {
                        privateKeyInput.select();
                    }
                }
            }

            updateKeySetupPrompt() {
                const prompt = document.getElementById('keySetupPrompt');
                const question = document.getElementById('keySetupQuestion');
                const verificationStatus = document.getElementById('verificationStatus');

                if (!prompt) {
                    return;
                }

                const verificationText = verificationStatus?.textContent || '';
                const isVerified = verificationText.includes('✓ NIP-05 verified');

                if (isVerified) {
                    prompt.style.display = 'none';
                    return;
                }

                const privateKeyValue = document.getElementById('settingsPrivateKey')?.value.trim();
                const publicKeyValue = document.getElementById('settingsPublicKey')?.value.trim();
                const hasKeys = !!privateKeyValue && !!publicKeyValue;

                prompt.style.display = 'flex';
                if (hasKeys) {
                    prompt.classList.add('compact');
                } else {
                    prompt.classList.remove('compact');
                }
                if (question) {
                    question.style.display = hasKeys ? 'none' : 'block';
                }
            }

            toggleKeyButtonsVisibility() {
                const generateBtn = document.getElementById('settingsGenerateKeyBtn');
                const verificationStatus = document.getElementById('verificationStatus');
                const prompt = document.getElementById('keySetupPrompt');
                const updateProfileBtn = document.getElementById('updateProfileBtn');
                const trustrootsUsername = document.getElementById('trustrootsUsername');
                const retryProfilePostBtn = document.getElementById('retryProfilePostBtn');

                if (!generateBtn || !verificationStatus) {
                    return;
                }

                const verificationText = verificationStatus.textContent || '';
                const isVerified = verificationText.includes('✓ NIP-05 verified');
                const isVerificationAttempted = verificationText.length > 0;

                if (isVerified) {
                    generateBtn.style.display = 'none';
                    if (prompt) {
                        prompt.style.display = 'none';
                    }
                    if (updateProfileBtn) {
                        updateProfileBtn.style.display = 'none';
                    }
                    if (trustrootsUsername) {
                        trustrootsUsername.setAttribute('readonly', 'readonly');
                        trustrootsUsername.classList.add('readonly');
                    }
                    if (retryProfilePostBtn) {
                        retryProfilePostBtn.style.display = 'none';
                    }
                } else {
                    // Check if we have a valid nsec key in the input
                    const settingsPrivateKey = document.getElementById('settingsPrivateKey');
                    const nsecInput = settingsPrivateKey?.value.trim() || '';
                    const hasValidNsec = nsecInput.startsWith('nsec1') && nsecInput.length > 10;
                    
                    // Only show generate button if we don't have a valid nsec
                    generateBtn.style.display = hasValidNsec ? 'none' : '';
                    if (prompt) {
                        prompt.style.display = 'flex';
                    }
                    if (updateProfileBtn) {
                        updateProfileBtn.style.display = '';
                    }
                    if (trustrootsUsername) {
                        trustrootsUsername.removeAttribute('readonly');
                        trustrootsUsername.classList.remove('readonly');
                    }
                    if (retryProfilePostBtn) {
                        retryProfilePostBtn.style.display = isVerificationAttempted ? '' : 'none';
                    }
                    this.updateKeySetupPrompt();
                }
            }

            openKeysDialog(message = '') {
                const finalMessage = message || "Let's help you set up some keys so you can start posting.";
                this.shouldPreserveSettingsMessage = true;

                const afterOpen = () => {
                    this.setSettingsModalMessage(finalMessage);
                    this.highlightKeyInputs();
                    this.updateKeySetupPrompt();
                    this.toggleKeyButtonsVisibility();
                    this.shouldPreserveSettingsMessage = false;
                };

                const settingsBtn = document.getElementById('settingsBtn');
                if (settingsBtn) {
                    settingsBtn.click();
                    setTimeout(afterOpen, 60);
                    return;
                }

                const settingsModal = document.getElementById('settingsModal');
                if (settingsModal) {
                    settingsModal.style.display = 'flex';
                    setTimeout(afterOpen, 10);
                } else {
                    console.warn('Settings modal not found when attempting to open keys dialog.');
                    this.shouldPreserveSettingsMessage = false;
                }
            }

            setupPMHandlers() {
                const pmModal = document.getElementById('pmModal');
                const pmClose = document.getElementById('pmClose');
                const pmSendBtn = document.getElementById('pmSendBtn');
                const pmInput = document.getElementById('pmInput');

                // Close PM modal
                pmClose.addEventListener('click', () => {
                    this.closePM();
                });

                // Close PM modal when clicking outside
                pmModal.addEventListener('click', (e) => {
                    if (e.target === pmModal) {
                        this.closePM();
                    }
                });

                // Send PM on button click
                pmSendBtn.addEventListener('click', () => {
                    this.sendPM();
                });

                // Send PM on Enter key (but allow Shift+Enter for new lines)
                pmInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.sendPM();
                    }
                });

                // Close PM modal on Escape key
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && pmModal.classList.contains('show')) {
                        this.closePM();
                    }
                });
            }

            setupMessagesHandlers() {
                const messagesBtn = document.getElementById('messagesBtn');
                const messagesModal = document.getElementById('messagesModal');
                const messagesClose = document.getElementById('messagesClose');

                // Open messages modal
                messagesBtn.addEventListener('click', () => {
                    this.openMessagesModal();
                });

                // Close messages modal
                messagesClose.addEventListener('click', () => {
                    this.closeMessagesModal();
                });

                // Close messages modal when clicking outside
                messagesModal.addEventListener('click', (e) => {
                    if (e.target === messagesModal) {
                        this.closeMessagesModal();
                    }
                });

                // Close messages modal on Escape key
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && messagesModal.style.display === 'block') {
                        this.closeMessagesModal();
                    }
                });
            }

            setupMapToggleHandlers() {
                const mapToggleBtn = document.getElementById('mapToggleBtn');
                const mapContainer = document.querySelector('.map-container');
                const noteContainer = document.getElementById('noteContainer');
                
                // Initialize map state from localStorage
                const mapVisible = localStorage.getItem('tripchat_map_visible') !== 'false';
                this.updateMapVisibility(mapVisible);
                
                mapToggleBtn.addEventListener('click', () => {
                    const isCurrentlyVisible = !mapContainer.classList.contains('hidden');
                    const newVisibility = !isCurrentlyVisible;
                    this.updateMapVisibility(newVisibility);
                    localStorage.setItem('tripchat_map_visible', newVisibility.toString());
                });
            }

            updateMapVisibility(visible) {
                const mapContainer = document.querySelector('.map-container'); // Get the map-container div directly
                const mapToggleBtn = document.getElementById('mapToggleBtn');
                
                if (visible) {
                    mapContainer.classList.remove('hidden');
                    mapToggleBtn.classList.add('active');
                    mapToggleBtn.textContent = '🗺️ MAP';
                    
                    // Reinitialize map if it was hidden
                    if (this.map) {
                        setTimeout(() => {
                            this.map.invalidateSize();
                        }, 100);
                    }
                } else {
                    mapContainer.classList.add('hidden');
                    mapToggleBtn.classList.remove('active');
                    mapToggleBtn.textContent = '🗺️ MAP';
                }
            }

            subscribeToDMs() {
                const currentUserPubkey = this.getCurrentUserPubkey();
                if (!currentUserPubkey) return;
                
                const currentUserHex = this.npubToHex(currentUserPubkey);
                
                // Subscribe to DMs on all connected relays
                for (const [relayUrl, ws] of Object.entries(this.websockets)) {
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        const subscriptionId = this.subscriptionIds[relayUrl];
                        if (!subscriptionId) continue;
                        
                        // Subscribe to DMs sent by us
                        const dmSentFilters = {
                            "kinds": [4],
                            "authors": [currentUserHex],
                            "limit": 100,
                            "since": Math.floor(Date.now() / 1000) - (30 * 24 * 60 * 60)
                        };
                        
                        const dmSentSubscription = [
                            "REQ",
                            subscriptionId + "-dms-sent",
                            dmSentFilters
                        ];
                        ws.send(JSON.stringify(dmSentSubscription));
                        
                        // Subscribe to DMs received by us
                        const dmReceivedFilters = {
                            "kinds": [4],
                            "#p": [currentUserHex],
                            "limit": 100,
                            "since": Math.floor(Date.now() / 1000) - (30 * 24 * 60 * 60)
                        };
                        
                        const dmReceivedSubscription = [
                            "REQ",
                            subscriptionId + "-dms-received",
                            dmReceivedFilters
                        ];
                        ws.send(JSON.stringify(dmReceivedSubscription));
                    }
                }
            }

            setupRelayManagerHandlers() {
                const relayManagerBtn = document.getElementById('relayManagerBtn');
                const relayManagerModal = document.getElementById('relayManagerModal');
                const newRelayUrl = document.getElementById('newRelayUrl');

                relayManagerBtn.addEventListener('click', () => {
                    relayManagerModal.style.display = 'flex';
                    this.updateRelayList();
                    // Focus on the input field when modal opens
                    setTimeout(() => newRelayUrl.focus(), 100);
                });

                // Handle Enter key for adding relays
                newRelayUrl.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        const url = newRelayUrl.value.trim();
                        if (url && url.startsWith('wss://')) {
                            this.addRelay(url);
                            newRelayUrl.value = '';
                            this.updateRelayList();
                        } else {
                            alert('Please enter a valid WebSocket URL (wss://...)');
                        }
                    }
                });

                // Handle ESC key to close modal
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && relayManagerModal.style.display === 'flex') {
                        relayManagerModal.style.display = 'none';
                    }
                });

                // Close modal when clicking outside
                relayManagerModal.addEventListener('click', (e) => {
                    if (e.target === relayManagerModal) {
                        relayManagerModal.style.display = 'none';
                    }
                });
            }


            setupGeohashTagClickHandlers() {
                document.querySelectorAll('.geohash-tag').forEach(tagElement => {
                    tagElement.addEventListener('click', (e) => {
                        const geohash = e.target.dataset.geohash;
                        if (geohash) {
                            this.geohashFilter = geohash;
                            document.getElementById('geohashFilter').value = geohash;
                            this.updateHash();
                            this.displayActivities(this.notes);
                            this.plotActivitiesOnMap(this.notes);
                            if (this.isGeohash(this.geohashFilter)) {
                                this.highlightGeohashArea(this.geohashFilter);
                            }
                        }
                    });
                });
            }

            setupDatetimeClickHandlers() {
                // Use event delegation to handle clicks on dynamically added elements
                // Only set up once to avoid duplicate listeners
                if (this.datetimeClickHandlerSetup) {
                    return;
                }
                
                const noteContainer = document.getElementById('noteContainer');
                if (noteContainer) {
                    noteContainer.addEventListener('click', (e) => {
                        // Check if the clicked element or its parent has the note-time class
                        const timeElement = e.target.closest('.note-time');
                        if (timeElement) {
                            const noteId = timeElement.dataset.noteId;
                            if (noteId) {
                                const note = this.notes.find(a => a.id === noteId);
                                if (note) {
                                    this.showNoteDetailsModal(note);
                                }
                            }
                        }
                    });
                    this.datetimeClickHandlerSetup = true;
                }
            }

            setupHashtagClickHandlers() {
                document.querySelectorAll('.hashtag-link').forEach(link => {
                    link.addEventListener('click', (e) => {
                        e.preventDefault();
                        const circleSlug = link.dataset.circle;
                        const hashtag = link.dataset.hashtag;
                        
                        console.log('Hashtag clicked:', hashtag, 'isGeohash:', this.isGeohash(hashtag));
                        
                        // Check if the hashtag is actually a geohash
                        if (this.isGeohash(hashtag)) {
                            // Update geohash filter
                            this.geohashFilter = hashtag;
                            const geohashFilterInput = document.getElementById('geohashFilter');
                            if (geohashFilterInput) {
                                geohashFilterInput.value = hashtag;
                            }
                            
                            // Update display and hash
                            this.updateHash();
                            this.displayActivities(this.notes);
                            this.plotActivitiesOnMap(this.notes);
                            
                            // Highlight the geohash area on map
                            if (this.isGeohash(this.geohashFilter)) {
                                this.highlightGeohashArea(this.geohashFilter);
                            }
                            
                            // Added geohash to filter
                        } else {
                            console.log('Setting search filter for hashtag:', hashtag);
                            // Add hashtag to the search filter, replacing any existing hashtag
                            const currentFilter = this.searchFilter || '';
                            const hashtagText = `#${hashtag}`;
                            let newFilter = currentFilter;
                            
                            // Check if there's already a hashtag in the filter
                            const hashtagRegex = /#\w+/g;
                            const existingHashtags = currentFilter.match(hashtagRegex);
                            
                            if (existingHashtags && existingHashtags.length > 0) {
                                // Replace the first hashtag with the new one
                                newFilter = currentFilter.replace(hashtagRegex, hashtagText);
                            } else if (currentFilter) {
                                // Add space and hashtag if there's already content but no hashtag
                                newFilter = `${currentFilter} ${hashtagText}`;
                            } else {
                                // Just add the hashtag if filter is empty
                                newFilter = hashtagText;
                            }
                            
                            // Update the search filter
                            this.searchFilter = newFilter;
                            const searchFilterInput = document.getElementById('searchFilter');
                            if (searchFilterInput) {
                                searchFilterInput.value = newFilter;
                            }
                            
                            // Update display and hash
                            this.updateHash();
                            this.displayActivities(this.notes);
                            this.plotActivitiesOnMap(this.notes);
                            
                            // Added hashtag to search filter
                        }
                    });
                });
            }

            setupScrollHandlers() {
                const noteContainer = document.getElementById('noteContainer');
                if (noteContainer) {
                    noteContainer.addEventListener('scroll', () => {
                        // Check if user is near the bottom (within 100px)
                        const isNearBottom = noteContainer.scrollTop + noteContainer.clientHeight >= noteContainer.scrollHeight - 100;
                        
                        if (isNearBottom) {
                            // User is at or near bottom, allow auto-scroll
                            this.userHasScrolled = false;
                        } else {
                            // User has scrolled up, disable auto-scroll
                            this.userHasScrolled = true;
                        }
                    });
                }
            }

            scrollToBottom() {
                // Only auto-scroll if user hasn't manually scrolled up
                if (!this.userHasScrolled) {
                    const noteContainer = document.getElementById('noteContainer');
                    if (noteContainer) {
                        noteContainer.scrollTop = noteContainer.scrollHeight;
                    }
                }
            }



            // NIP-05 Profile Caching Methods
            getCachedProfile(pubkey) {
                try {
                    const cached = localStorage.getItem(`tripchat_profile_${pubkey}`);
                    if (cached) {
                        const profile = JSON.parse(cached);
                        const now = Date.now();
                        // Cache for 7 days (profiles don't change often)
                        if (now - profile.cachedAt < 7 * 24 * 60 * 60 * 1000) {
                            return profile.data;
                        } else {
                            localStorage.removeItem(`tripchat_profile_${pubkey}`);
                        }
                    }
                } catch (e) {
                    console.warn('Error reading cached profile:', e);
                }
                return null;
            }

            setCachedProfile(pubkey, profile) {
                try {
                    const cacheData = {
                        data: profile,
                        cachedAt: Date.now()
                    };
                    localStorage.setItem(`tripchat_profile_${pubkey}`, JSON.stringify(cacheData));
                } catch (e) {
                    console.warn('Error caching profile:', e);
                }
            }

            // Preload profiles for visible notes to show green links faster
            async preloadVisibleProfiles() {
                // Throttle profile preloading to avoid excessive requests
                if (this.profilePreloadInProgress) {
                    return;
                }
                
                this.profilePreloadInProgress = true;
                
                try {
                    const visibleNotes = this.notes.slice(0, 20); // Only preload first 20 notes
                    const profilePromises = visibleNotes.map(note => {
                        if (note.pubkey && !this.userProfiles[note.pubkey]) {
                            return this.fetchUserProfile(note.pubkey);
                        }
                        return Promise.resolve();
                    });
                    
                    await Promise.allSettled(profilePromises);
                    // Re-render to show any newly loaded profiles
                    this.displayActivities(this.notes);
                } finally {
                    // Reset the flag after a delay to allow occasional updates
                    setTimeout(() => {
                        this.profilePreloadInProgress = false;
                    }, 2000);
                }
            }

            async fetchUserProfile(pubkey) {
                // Check in-memory cache first
                if (this.userProfiles[pubkey]) {
                    return this.userProfiles[pubkey];
                }

                // Check if we're already requesting this profile
                if (this.pendingProfileRequests && this.pendingProfileRequests.has(pubkey)) {
                    return this.pendingProfileRequests.get(pubkey);
                }

                // Check localStorage cache
                const cachedProfile = this.getCachedProfile(pubkey);
                if (cachedProfile) {
                    this.userProfiles[pubkey] = cachedProfile;
                    this.profileCache.set(pubkey, cachedProfile);
                    return cachedProfile;
                }

                // Create a promise for this profile request to prevent duplicates
                const profilePromise = this.fetchProfileFromRelays(pubkey);
                this.pendingProfileRequests.set(pubkey, profilePromise);
                
                try {
                    const profile = await profilePromise;
                    return profile;
                } finally {
                    // Clean up the pending request
                    this.pendingProfileRequests.delete(pubkey);
                }
            }

            async fetchProfileFromRelays(pubkey) {
                try {
                    // Try to fetch from the first available relay
                    for (const relayUrl of this.relays) {
                        if (this.websockets[relayUrl] && this.websockets[relayUrl].readyState === WebSocket.OPEN) {
                            const profile = await this.requestUserProfile(relayUrl, pubkey);
                            if (profile) {
                                // Cache profile in both memory and localStorage
                                this.userProfiles[pubkey] = profile;
                                this.profileCache.set(pubkey, profile);
                                this.setCachedProfile(pubkey, profile);
                                // Re-render notes to show the new username
                                this.displayActivities(this.notes);
                                return profile;
                            }
                        }
                    }
                } catch (error) {
                    console.warn('Error fetching user profile for', pubkey, ':', error);
                }

                // Fallback: create a basic profile with shortened pubkey
                const shortPubkey = pubkey.substring(0, 8) + '...';
                const fallbackProfile = { name: shortPubkey, pubkey: pubkey };
                this.userProfiles[pubkey] = fallbackProfile;
                this.profileCache.set(pubkey, fallbackProfile);
                // Don't cache fallback profiles in localStorage
                return fallbackProfile;
            }

            // Auto-population method temporarily removed

            // Direct profile fetch method temporarily removed

            // Clean up any existing kind 0 notes from the notes array
            cleanupProfileNotes() {
                const beforeCount = this.notes.length;
                this.notes = this.notes.filter(note => note.kind !== 0);
                const afterCount = this.notes.length;
                if (beforeCount !== afterCount) {
                    console.log(`Cleaned up ${beforeCount - afterCount} profile notes from chat`);
                }
            }

            // Helper function to get private key from localStorage
            getPrivateKey() {
                const nsecKey = localStorage.getItem('tripchat_nsec');
                if (!nsecKey) {
                    return null;
                }
                
                try {
                    // Convert nsec to hex private key using existing function
                    return this.nsecToHex(nsecKey);
                } catch (error) {
                    console.error('Error decoding private key:', error);
                    return null;
                }
            }

            // NIP-4 Encrypted Direct Messages
            async createEncryptedDM(recipientPubkey, content) {
                console.log('🔍 PM Debug - createEncryptedDM called:', { recipientPubkey, contentLength: content.length });
                try {
                    // Get our private key
                    const privateKey = await this.getPrivateKey();
                    console.log('🔍 PM Debug - Private key retrieved:', !!privateKey);
                    if (!privateKey) {
                        throw new Error('No private key available');
                    }

                    // Convert hex keys to Uint8Array
                    const privateKeyBytes = new Uint8Array(privateKey.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
                    const recipientPubkeyBytes = new Uint8Array(recipientPubkey.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
                    console.log('🔍 PM Debug - Keys converted to bytes:', { privateKeyLength: privateKeyBytes.length, recipientLength: recipientPubkeyBytes.length });

                    // Derive shared secret using ECDH
                    console.log('🔍 PM Debug - Key order for encryption:', { 
                        privateKey: Array.from(privateKeyBytes.slice(0, 4)).map(b => b.toString(16).padStart(2, '0')).join(''),
                        recipientPubkey: Array.from(recipientPubkeyBytes.slice(0, 4)).map(b => b.toString(16).padStart(2, '0')).join('')
                    });
                    const sharedSecret = await this.deriveSharedSecret(privateKeyBytes, recipientPubkeyBytes);
                    console.log('🔍 PM Debug - Shared secret derived:', !!sharedSecret);
                    console.log('🔍 PM Debug - Shared secret length:', sharedSecret.length);
                    console.log('🔍 PM Debug - Shared secret first 8 bytes:', Array.from(sharedSecret.slice(0, 8)).map(b => b.toString(16).padStart(2, '0')).join(''));
                    
                    // Encrypt the content
                    const encryptedContent = await this.encryptAES(new TextEncoder().encode(content), sharedSecret);
                    console.log('🔍 PM Debug - Content encrypted:', { encryptedLength: encryptedContent.length });
                    
                    // Get current user's pubkey
                    const currentUserPubkey = this.getCurrentUserPubkey();
                    console.log('🔍 PM Debug - Current user pubkey:', currentUserPubkey);
                    if (!currentUserPubkey) {
                        throw new Error('No user pubkey available');
                    }

                    // Convert to hex for storage
                    const currentUserHex = this.npubToHex(currentUserPubkey);
                    const recipientHex = recipientPubkey.startsWith('npub') ? this.npubToHex(recipientPubkey) : recipientPubkey;
                    console.log('🔍 PM Debug - Using hex pubkeys:', { currentUserHex, recipientHex });

                    // Create the encrypted DM event (kind 4)
                    const dmEvent = {
                        kind: 4,
                        pubkey: currentUserHex,
                        created_at: Math.floor(Date.now() / 1000),
                        content: encryptedContent,
                        tags: [['p', recipientHex]]
                    };
                    console.log('🔍 PM Debug - DM event created:', { 
                        id: dmEvent.id, 
                        kind: dmEvent.kind, 
                        tags: dmEvent.tags,
                        contentType: typeof encryptedContent,
                        contentLength: encryptedContent.length,
                        contentPreview: encryptedContent.substring(0, 20) + '...'
                    });
                    
                    return dmEvent;
                } catch (error) {
                    console.error('Error creating encrypted DM:', error);
                    throw error;
                }
            }

            async decryptDM(dmEvent) {
                console.log('🔍 PM Debug - decryptDM called:', { 
                    id: dmEvent.id, 
                    pubkey: dmEvent.pubkey, 
                    contentLength: dmEvent.content?.length,
                    contentType: typeof dmEvent.content,
                    contentPreview: dmEvent.content?.substring(0, 20) + '...',
                    tags: dmEvent.tags 
                });
                try {
                    // Get our private key
                    const privateKey = await this.getPrivateKey();
                    console.log('🔍 PM Debug - Private key retrieved for decryption:', !!privateKey);
                    if (!privateKey) {
                        throw new Error('No private key available');
                    }

                    // Get sender's public key
                    const senderPubkey = dmEvent.pubkey;
                    console.log('🔍 PM Debug - Sender pubkey:', senderPubkey);
                    
                    // Determine if this is a message we sent or received
                    const currentUserHex = this.npubToHex(this.getCurrentUserPubkey());
                    const isSentByUs = senderPubkey === currentUserHex;
                    console.log('🔍 PM Debug - Is sent by us:', isSentByUs);
                    
                    let otherPubkey;
                    if (isSentByUs) {
                        // Message sent by us - get recipient from tags
                        const pTag = dmEvent.tags?.find(tag => tag[0] === 'p');
                        otherPubkey = pTag ? pTag[1] : null;
                        console.log('🔍 PM Debug - Message sent by us, recipient pubkey:', otherPubkey);
                    } else {
                        // Message received by us - sender is the other party
                        otherPubkey = senderPubkey;
                        console.log('🔍 PM Debug - Message received by us, sender pubkey:', otherPubkey);
                    }
                    
                    if (!otherPubkey) {
                        throw new Error('Cannot determine other party for decryption');
                    }
                    
                    const otherPubkeyBytes = new Uint8Array(otherPubkey.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
                    const privateKeyBytes = new Uint8Array(privateKey.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
                    console.log('🔍 PM Debug - Key bytes:', { 
                        otherPubkeyLength: otherPubkeyBytes.length, 
                        privateLength: privateKeyBytes.length 
                    });

                    // Derive shared secret using ECDH
                    console.log('🔍 PM Debug - Deriving shared secret...');
                    console.log('🔍 PM Debug - Key order for decryption:', { 
                        privateKey: Array.from(privateKeyBytes.slice(0, 4)).map(b => b.toString(16).padStart(2, '0')).join(''),
                        otherPubkey: Array.from(otherPubkeyBytes.slice(0, 4)).map(b => b.toString(16).padStart(2, '0')).join('')
                    });
                    const sharedSecret = await this.deriveSharedSecret(privateKeyBytes, otherPubkeyBytes);
                    console.log('🔍 PM Debug - Shared secret derived:', !!sharedSecret);
                    console.log('🔍 PM Debug - Shared secret length:', sharedSecret.length);
                    console.log('🔍 PM Debug - Shared secret first 8 bytes:', Array.from(sharedSecret.slice(0, 8)).map(b => b.toString(16).padStart(2, '0')).join(''));
                    
                    // Decrypt the content
                    console.log('🔍 PM Debug - Decrypting content...');
                    const decryptedBytes = await this.decryptAES(dmEvent.content, sharedSecret);
                    console.log('🔍 PM Debug - Content decrypted, bytes length:', decryptedBytes.length);
                    const decryptedContent = new TextDecoder().decode(decryptedBytes);
                    console.log('🔍 PM Debug - Decrypted content:', decryptedContent.substring(0, 50) + '...');
                    
                    return decryptedContent;
                } catch (error) {
                    console.error('❌ PM Debug - Error decrypting DM:', error);
                    throw error;
                }
            }

            async encryptAES(data, key) {
                // Use the first 32 bytes of the shared secret as the AES key
                const aesKey = key.slice(0, 32);
                
                const iv = crypto.getRandomValues(new Uint8Array(16));
                const cryptoKey = await crypto.subtle.importKey(
                    'raw',
                    aesKey,
                    { name: 'AES-GCM' },
                    false,
                    ['encrypt']
                );
                const encrypted = await crypto.subtle.encrypt(
                    { name: 'AES-GCM', iv: iv },
                    cryptoKey,
                    data
                );
                const result = new Uint8Array(iv.length + encrypted.byteLength);
                result.set(iv);
                result.set(new Uint8Array(encrypted), iv.length);
                return btoa(String.fromCharCode(...result));
            }

            async decryptAES(encryptedData, key) {
                console.log('🔍 PM Debug - decryptAES called:', { 
                    encryptedDataLength: encryptedData.length, 
                    keyLength: key.length 
                });
                try {
                    // Use the first 32 bytes of the shared secret as the AES key
                    const aesKey = key.slice(0, 32);
                    console.log('🔍 PM Debug - AES key length:', aesKey.length);
                    
                    const data = Uint8Array.from(atob(encryptedData), c => c.charCodeAt(0));
                    const iv = data.slice(0, 16);
                    const encrypted = data.slice(16);
                    console.log('🔍 PM Debug - Decryption data:', { 
                        dataLength: data.length, 
                        ivLength: iv.length, 
                        encryptedLength: encrypted.length 
                    });
                    
                    const cryptoKey = await crypto.subtle.importKey(
                        'raw',
                        aesKey,
                        { name: 'AES-GCM' },
                        false,
                        ['decrypt']
                    );
                    console.log('🔍 PM Debug - Crypto key imported successfully');
                    
                    const decrypted = await crypto.subtle.decrypt(
                        { name: 'AES-GCM', iv: iv },
                        cryptoKey,
                        encrypted
                    );
                    console.log('🔍 PM Debug - AES decryption successful, length:', decrypted.byteLength);
                    return new Uint8Array(decrypted);
                } catch (error) {
                    console.error('❌ PM Debug - AES decryption failed:', error);
                    throw error;
                }
            }

            async deriveSharedSecret(privateKey, publicKey) {
                console.log('🔍 PM Debug - deriveSharedSecret called:', { 
                    privateKeyLength: privateKey.length, 
                    publicKeyLength: publicKey.length,
                    hasNostrTools: typeof window.nostrTools !== 'undefined',
                    hasGetSharedSecret: typeof window.nostrTools?.getSharedSecret !== 'undefined'
                });
                try {
                    // Use nostr-tools for proper secp256k1 ECDH
                    if (typeof window.nostrTools !== 'undefined' && window.nostrTools.getSharedSecret) {
                        console.log('🔍 PM Debug - Using nostr-tools getSharedSecret');
                        const sharedSecret = window.nostrTools.getSharedSecret(privateKey, publicKey);
                        console.log('🔍 PM Debug - Shared secret from nostr-tools:', sharedSecret.length, 'bytes');
                        return new Uint8Array(sharedSecret);
                    } else {
                        console.log('🔍 PM Debug - Using fallback hash-based approach');
                        // Fallback: hash-based approach that's consistent
                        // Convert Uint8Arrays to hex strings for consistent hashing
                        const privateKeyHex = Array.from(privateKey).map(b => b.toString(16).padStart(2, '0')).join('');
                        const publicKeyHex = Array.from(publicKey).map(b => b.toString(16).padStart(2, '0')).join('');
                        
                        // Sort keys to ensure consistent ordering
                        const keys = [privateKeyHex, publicKeyHex].sort();
                        const combined = keys.join('');
                        
                        const hash = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(combined));
                        console.log('🔍 PM Debug - Hash-based shared secret:', hash.byteLength, 'bytes');
                        return new Uint8Array(hash);
                    }
                } catch (error) {
                    console.error('❌ PM Debug - Error deriving shared secret:', error);
                    // Fallback: hash-based approach that's consistent
                    const privateKeyHex = Array.from(privateKey).map(b => b.toString(16).padStart(2, '0')).join('');
                    const publicKeyHex = Array.from(publicKey).map(b => b.toString(16).padStart(2, '0')).join('');
                    const keys = [privateKeyHex, publicKeyHex].sort();
                    const combined = keys.join('');
                    const hash = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(combined));
                    return new Uint8Array(hash);
                }
            }

            // PM Modal and Message Management
            openPM(recipientPubkey) {
                console.log('🔍 PM Debug - openPM called:', { recipientPubkey });
                const nsecKey = localStorage.getItem('tripchat_nsec');
                const npubKey = localStorage.getItem('tripchat_npub');
                
                console.log('🔍 PM Debug - Keys check:', { hasNsec: !!nsecKey, hasNpub: !!npubKey });
                
                if (!nsecKey || !npubKey) {
                    alert('Please set up your keys first to send private messages.');
                    return;
                }

                this.currentPMRecipient = recipientPubkey;
                const recipientName = this.userProfiles[recipientPubkey]?.name || recipientPubkey.substring(0, 8) + '...';
                
                console.log('🔍 PM Debug - Setting up PM modal:', { recipientName, currentPMRecipient: this.currentPMRecipient });
                
                document.getElementById('pmRecipientName').textContent = `Private Message with ${recipientName}`;
                document.getElementById('pmModal').classList.add('show');
                document.getElementById('pmInput').focus();
                
                console.log('🔍 PM Debug - PM modal should be visible now');
                
                // Load existing messages
                this.loadPMMessages(recipientPubkey);
            }

            closePM() {
                document.getElementById('pmModal').classList.remove('show');
                this.currentPMRecipient = null;
                document.getElementById('pmMessages').innerHTML = '';
                document.getElementById('pmInput').value = '';
            }

            async loadPMMessages(recipientPubkey) {
                console.log('🔍 PM Debug - loadPMMessages called:', { recipientPubkey });
                const messagesContainer = document.getElementById('pmMessages');
                messagesContainer.innerHTML = '<div style="text-align: center; color: var(--text-muted);">Loading messages...</div>';

                try {
                    // Get current user's pubkey
                    const currentUserPubkey = this.getCurrentUserPubkey();
                    console.log('🔍 PM Debug - Current user pubkey:', currentUserPubkey);
                    if (!currentUserPubkey) {
                        messagesContainer.innerHTML = '<div style="text-align: center; color: #dc3545;">Unable to load messages - no user key found</div>';
                        return;
                    }

                    // Convert npub to hex for comparison
                    const currentUserHex = this.npubToHex(currentUserPubkey);
                    console.log('🔍 PM Debug - Current user hex pubkey:', currentUserHex);
                    
                    // Convert recipient pubkey to hex if it's in npub format
                    const recipientHex = recipientPubkey.startsWith('npub') ? this.npubToHex(recipientPubkey) : recipientPubkey;
                    console.log('🔍 PM Debug - Recipient hex pubkey:', recipientHex);

                    console.log('🔍 PM Debug - Total notes in array:', this.notes.length);
                    console.log('🔍 PM Debug - Kind 4 notes:', this.notes.filter(note => note.kind === 4).length);

                    // Get all kind 4 events (DMs) between us and the recipient
                    const dmEvents = this.notes.filter(note => {
                        if (note.kind !== 4) return false;
                        
                        // Message sent by us to recipient
                        if (note.pubkey === currentUserHex) {
                            return note.tags?.some(tag => tag[0] === 'p' && tag[1] === recipientHex);
                        }
                        
                        // Message sent by recipient to us
                        if (note.pubkey === recipientHex) {
                            return note.tags?.some(tag => tag[0] === 'p' && tag[1] === currentUserHex);
                        }
                        
                        return false;
                    });

                    console.log('🔍 PM Debug - Found DM events:', dmEvents.length);

                    // Sort by timestamp
                    dmEvents.sort((a, b) => a.created_at - b.created_at);

                    if (dmEvents.length === 0) {
                        console.log('🔍 PM Debug - No DM events found, showing empty state');
                        messagesContainer.innerHTML = '<div style="text-align: center; color: var(--text-muted);">No messages yet. Start the conversation!</div>';
                        return;
                    }

                    // Decrypt and display messages
                    let messagesHtml = '';
                    for (const event of dmEvents) {
                        try {
                            const decryptedContent = await this.decryptDM(event);
                            
                            const isSent = event.pubkey === currentUserHex;
                            const senderName = isSent ? 'You' : (this.userProfiles[event.pubkey]?.name || event.pubkey.substring(0, 8) + '...');
                            const messageDate = new Date(event.created_at * 1000);
                            const timeString = messageDate.toLocaleString('en-US', {
                                month: 'short',
                                day: 'numeric',
                                hour: '2-digit',
                                minute: '2-digit',
                                hour12: true
                            });
                            
                            messagesHtml += `
                                <div class="pm-message ${isSent ? 'sent' : 'received'}">
                                    <div>${this.escapeHtml(decryptedContent)}</div>
                                    <div class="pm-message-time">${senderName} • ${timeString}</div>
                                </div>
                            `;
                        } catch (error) {
                            console.warn('❌ PM Debug - Failed to decrypt message:', error);
                            const errorDate = new Date(event.created_at * 1000);
                            const errorTimeString = errorDate.toLocaleString('en-US', {
                                month: 'short',
                                day: 'numeric',
                                hour: '2-digit',
                                minute: '2-digit',
                                hour12: true
                            });
                            messagesHtml += `
                                <div class="pm-message received">
                                    <div style="color: var(--text-muted); font-style: italic;">Failed to decrypt message</div>
                                    <div class="pm-message-time">${errorTimeString}</div>
                                </div>
                            `;
                        }
                    }

                    messagesContainer.innerHTML = messagesHtml;
                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                } catch (error) {
                    console.error('Error loading PM messages:', error);
                    messagesContainer.innerHTML = '<div style="text-align: center; color: #dc3545;">Error loading messages</div>';
                }
            }

            async sendPM() {
                const input = document.getElementById('pmInput');
                const content = input.value.trim();
                
                console.log('🔍 PM Debug - sendPM called:', { content, recipient: this.currentPMRecipient });
                
                if (!content) return;
                if (!this.currentPMRecipient) return;

                const sendBtn = document.getElementById('pmSendBtn');
                sendBtn.disabled = true;
                sendBtn.textContent = 'Sending...';

                try {
                    console.log('🔍 PM Debug - Creating encrypted DM...');
                    // Create encrypted DM
                    const dmEvent = await this.createEncryptedDM(this.currentPMRecipient, content);
                    console.log('🔍 PM Debug - DM event created:', { id: dmEvent.id, kind: dmEvent.kind, contentLength: dmEvent.content?.length });
                    
                    console.log('🔍 PM Debug - Signing event...');
                    // Sign the event
                    const signedEvent = await this.signEvent(dmEvent);
                    console.log('🔍 PM Debug - Event signed:', { id: signedEvent.id, sig: signedEvent.sig?.substring(0, 16) + '...' });
                    
                    console.log('🔍 PM Debug - Publishing to relays...');
                    // Send to relays
                    await this.publishEvent(signedEvent);
                    console.log('🔍 PM Debug - Event published successfully');
                    
                    console.log('🔍 PM Debug - Adding to notes array...');
                    // Add the sent message to our notes array so it appears immediately
                    this.notes.push(signedEvent);
                    console.log('🔍 PM Debug - Added to notes array. Total notes:', this.notes.length);
                    
                    // Clear input
                    input.value = '';
                    
                    console.log('🔍 PM Debug - Reloading PM messages...');
                    // Reload messages to show the new one
                    await this.loadPMMessages(this.currentPMRecipient);
                    console.log('🔍 PM Debug - PM messages reloaded');
                } catch (error) {
                    console.error('❌ PM Debug - Error sending PM:', error);
                    alert('Failed to send message: ' + error.message);
                } finally {
                    sendBtn.disabled = false;
                    sendBtn.textContent = 'Send';
                }
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            // Messages Modal Methods
            openMessagesModal() {
                const messagesModal = document.getElementById('messagesModal');
                messagesModal.style.display = 'block';
                this.loadConversations();
            }

            closeMessagesModal() {
                const messagesModal = document.getElementById('messagesModal');
                messagesModal.style.display = 'none';
            }

            openPMFromMessages(recipientPubkey) {
                // Close messages modal and open PM modal
                this.closeMessagesModal();
                this.openPM(recipientPubkey);
            }

            async loadConversations() {
                console.log('🔍 PM Debug - loadConversations called');
                const messagesList = document.getElementById('messagesList');
                messagesList.innerHTML = '<div class="messages-loading">Loading conversations...</div>';

                try {
                    const currentUserPubkey = this.getCurrentUserPubkey();
                    console.log('🔍 PM Debug - Current user pubkey for conversations:', currentUserPubkey);
                    if (!currentUserPubkey) {
                        messagesList.innerHTML = '<div class="no-conversations">Please set up your keys first to view messages</div>';
                        return;
                    }

                    // Convert to hex for comparison
                    const currentUserHex = this.npubToHex(currentUserPubkey);
                    console.log('🔍 PM Debug - Current user hex for conversations:', currentUserHex);

                    console.log('🔍 PM Debug - Total notes for conversations:', this.notes.length);
                    console.log('🔍 PM Debug - Kind 4 notes for conversations:', this.notes.filter(note => note.kind === 4).length);
                    console.log('🔍 PM Debug - All kind 4 notes:', this.notes.filter(note => note.kind === 4).map(n => ({ 
                        id: n.id, 
                        pubkey: n.pubkey, 
                        tags: n.tags 
                    })));

                    // Get all DMs involving the current user
                    const dmEvents = this.notes.filter(note => 
                        note.kind === 4 && 
                        (note.pubkey === currentUserHex || 
                         note.tags?.some(tag => tag[0] === 'p' && tag[1] === currentUserHex))
                    );
                    console.log('🔍 PM Debug - Found DM events for conversations:', dmEvents.length);

                    // Group DMs by conversation partner
                    const conversations = new Map();
                    console.log('🔍 PM Debug - Starting conversation grouping...');
                    
                    for (const event of dmEvents) {
                        console.log('🔍 PM Debug - Processing DM event:', { 
                            id: event.id, 
                            pubkey: event.pubkey, 
                            tags: event.tags,
                            isSent: event.pubkey === currentUserHex 
                        });
                        
                        let partnerPubkey;
                        if (event.pubkey === currentUserHex) {
                            // Message sent by us - get recipient from tags
                            const pTag = event.tags?.find(tag => tag[0] === 'p');
                            partnerPubkey = pTag ? pTag[1] : null;
                            console.log('🔍 PM Debug - Sent message, partner from tag:', partnerPubkey);
                        } else {
                            // Message received by us - sender is the partner
                            partnerPubkey = event.pubkey;
                            console.log('🔍 PM Debug - Received message, partner is sender:', partnerPubkey);
                        }

                        if (!partnerPubkey) {
                            console.log('🔍 PM Debug - No partner pubkey found, skipping');
                            continue;
                        }

                        if (!conversations.has(partnerPubkey)) {
                            console.log('🔍 PM Debug - Creating new conversation for:', partnerPubkey);
                            conversations.set(partnerPubkey, {
                                partnerPubkey,
                                lastMessage: event,
                                unreadCount: 0,
                                messages: []
                            });
                        }

                        const conversation = conversations.get(partnerPubkey);
                        conversation.messages.push(event);
                        console.log('🔍 PM Debug - Added message to conversation, total messages:', conversation.messages.length);
                        
                        // Update last message if this is newer
                        if (event.created_at > conversation.lastMessage.created_at) {
                            conversation.lastMessage = event;
                            console.log('🔍 PM Debug - Updated last message');
                        }

                        // Count unread messages (received messages we haven't seen)
                        if (event.pubkey !== currentUserHex) {
                            conversation.unreadCount++;
                            console.log('🔍 PM Debug - Incremented unread count:', conversation.unreadCount);
                        }
                    }
                    
                    console.log('🔍 PM Debug - Conversation grouping complete, total conversations:', conversations.size);

                    // Convert to array and sort by last message time
                    const conversationList = Array.from(conversations.values())
                        .sort((a, b) => b.lastMessage.created_at - a.lastMessage.created_at);

                    if (conversationList.length === 0) {
                        messagesList.innerHTML = '<div class="no-conversations">No conversations yet. Start a conversation by clicking the PM button on any note!</div>';
                        return;
                    }

                    // Render conversations
                    let conversationsHtml = '';
                    for (const conversation of conversationList) {
                        const partnerName = this.userProfiles[conversation.partnerPubkey]?.name || 
                                          conversation.partnerPubkey.substring(0, 8) + '...';
                        
                        // Try to decrypt the last message for preview
                        let preview = 'Encrypted message';
                        try {
                            const decryptedContent = await this.decryptDM(conversation.lastMessage);
                            preview = decryptedContent.length > 50 ? 
                                     decryptedContent.substring(0, 50) + '...' : 
                                     decryptedContent;
                        } catch (error) {
                            // Keep default preview if decryption fails
                        }

                        const timeString = new Date(conversation.lastMessage.created_at * 1000).toLocaleTimeString();
                        const unreadBadge = conversation.unreadCount > 0 ? 
                            `<div class="unread-badge">${conversation.unreadCount}</div>` : '';

                        conversationsHtml += `
                            <div class="conversation-item" onclick="window.tripchatVisualizer.openPMFromMessages('${conversation.partnerPubkey}')">
                                <div class="conversation-info">
                                    <div class="conversation-name">${this.escapeHtml(partnerName)}</div>
                                    <div class="conversation-preview">${this.escapeHtml(preview)}</div>
                                </div>
                                <div class="conversation-meta">
                                    <div class="conversation-time">${timeString}</div>
                                    ${unreadBadge}
                                </div>
                            </div>
                        `;
                    }

                    messagesList.innerHTML = conversationsHtml;
                    
                } catch (error) {
                    console.error('Error loading conversations:', error);
                    messagesList.innerHTML = '<div class="no-conversations">Error loading conversations</div>';
                }
            }

            updateUnreadCount() {
                const messagesBtn = document.getElementById('messagesBtn');
                const currentUserPubkey = this.getCurrentUserPubkey();
                
                if (!currentUserPubkey) {
                    messagesBtn.classList.remove('has-unread');
                    return;
                }

                // Convert to hex for comparison
                const currentUserHex = this.npubToHex(currentUserPubkey);

                // Count unread DMs (received messages)
                const unreadCount = this.notes.filter(note => 
                    note.kind === 4 && 
                    note.pubkey !== currentUserHex &&
                    note.tags?.some(tag => tag[0] === 'p' && tag[1] === currentUserHex)
                ).length;

                if (unreadCount > 0) {
                    messagesBtn.classList.add('has-unread');
                } else {
                    messagesBtn.classList.remove('has-unread');
                }
            }

            showDeleteKeyWarning() {
                const warningMessage = `
                    <div style="text-align: center; padding: 20px;">
                        <div style="font-size: 2rem; margin-bottom: 15px;">⚠️</div>
                        <h3 style="color: #e74c3c; margin-bottom: 15px;">Delete Private Key?</h3>
                        <p style="margin-bottom: 20px; line-height: 1.5;">
                            <strong>Are you sure you want to delete your nsec private key?</strong>
                        </p>
                        <p style="margin-bottom: 20px; color: #7f8c8d; font-size: 0.9rem;">
                            <strong>⚠️ IMPORTANT:</strong> Did you store this nsec key in your password manager?<br/>
                            Once deleted, you won't be able to recover it unless you have a backup.
                        </p>
                        <div style="display: flex; gap: 10px; justify-content: center; margin-top: 25px;">
                            <button id="confirmDeleteKey" style="
                                background: #e74c3c; 
                                color: white; 
                                border: none; 
                                padding: 10px 20px; 
                                border-radius: 5px; 
                                cursor: pointer;
                                font-weight: bold;
                            ">Yes, Delete Key</button>
                            <button id="cancelDeleteKey" style="
                                background: #95a5a6; 
                                color: white; 
                                border: none; 
                                padding: 10px 20px; 
                                border-radius: 5px; 
                                cursor: pointer;
                            ">Cancel</button>
                        </div>
                    </div>
                `;

                // Create modal overlay
                const modal = document.createElement('div');
                modal.id = 'deleteKeyModal';
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.7);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                `;

                // Create modal content
                const modalContent = document.createElement('div');
                modalContent.style.cssText = `
                    background: white;
                    border-radius: 10px;
                    max-width: 500px;
                    width: 90%;
                    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
                `;
                modalContent.innerHTML = warningMessage;

                modal.appendChild(modalContent);
                document.body.appendChild(modal);

                // Add event listeners
                document.getElementById('confirmDeleteKey').addEventListener('click', () => {
                    this.deletePrivateKey();
                    document.body.removeChild(modal);
                });

                document.getElementById('cancelDeleteKey').addEventListener('click', () => {
                    document.body.removeChild(modal);
                });

                // Close on overlay click
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        document.body.removeChild(modal);
                    }
                });
            }

            deletePrivateKey() {
                try {
                    // Clear localStorage
                    localStorage.removeItem('tripchat_nsec');
                    localStorage.removeItem('tripchat_npub');
                    localStorage.removeItem('tripchat_trustroots_username');

                    // Clear class properties
                    this.privateKey = null;

                    // Clear UI fields
                    const settingsPrivateKey = document.getElementById('settingsPrivateKey');
                    const settingsPublicKey = document.getElementById('settingsPublicKey');
                    const trustrootsUsername = document.getElementById('trustrootsUsername');
                    const nip05Identifier = document.getElementById('nip05Identifier');
                    const usernameStatus = document.getElementById('usernameStatus');

                    if (settingsPrivateKey) {
                        settingsPrivateKey.value = '';
                        settingsPrivateKey.type = 'text';
                    }
                    if (settingsPublicKey) settingsPublicKey.value = '';
                    if (trustrootsUsername) trustrootsUsername.value = '';
                    if (nip05Identifier) nip05Identifier.textContent = 'Enter username and generate keys first';
                    if (usernameStatus) {
                        usernameStatus.textContent = 'No username saved yet';
                        usernameStatus.style.color = '#6c757d';
                    }

                    // Hide delete button
                    const deletePrivateKeyBtn = document.getElementById('deletePrivateKeyBtn');
                    if (deletePrivateKeyBtn) {
                        deletePrivateKeyBtn.style.display = 'none';
                    }

                    // Show generate button
                    const generateBtn = document.getElementById('settingsGenerateKeyBtn');
                    if (generateBtn) {
                        generateBtn.style.display = 'block';
                    }

                    // Update toggle button
                    const toggleBtn = document.getElementById('togglePrivateKeyVisibility');
                    if (toggleBtn) {
                        toggleBtn.textContent = '🙈';
                        toggleBtn.title = 'Hide private key';
                    }

                    // Clear hint
                    const settingsPrivateKeyHint = document.getElementById('settingsPrivateKeyHint');
                    if (settingsPrivateKeyHint) {
                        settingsPrivateKeyHint.innerHTML = '';
                        settingsPrivateKeyHint.style.display = 'none';
                    }

                    // Update button visibility
                    this.toggleKeyButtonsVisibility();

                    // Show success message
                    this.setSettingsModalMessage('🗑️ Private key deleted successfully. You can now generate a new key or paste a different one.');

                    console.log('Private key deleted successfully');
                } catch (error) {
                    console.error('Error deleting private key:', error);
                    alert('Error deleting private key. Please try again.');
                }
            }

            updateDeleteButtonVisibility() {
                const deletePrivateKeyBtn = document.getElementById('deletePrivateKeyBtn');
                const nsecKey = localStorage.getItem('tripchat_nsec');
                
                if (deletePrivateKeyBtn) {
                    if (nsecKey && nsecKey.trim() !== '') {
                        deletePrivateKeyBtn.style.display = 'block';
                    } else {
                        deletePrivateKeyBtn.style.display = 'none';
                    }
                }
            }

            // Request queue management methods
            async queueRequest(relayUrl, requestFunction) {
                return new Promise((resolve, reject) => {
                    this.requestQueue.push({
                        relayUrl,
                        requestFunction,
                        resolve,
                        reject
                    });
                    this.processRequestQueue();
                });
            }

            async processRequestQueue() {
                if (this.activeRequests >= this.maxConcurrentRequests || this.requestQueue.length === 0) {
                    return;
                }

                const request = this.requestQueue.shift();
                if (!request) return;

                this.activeRequests++;
                
                try {
                    // Add delay between requests to avoid overwhelming the relay
                    await new Promise(resolve => setTimeout(resolve, this.requestDelay));
                    
                    const result = await request.requestFunction();
                    request.resolve(result);
                } catch (error) {
                    request.reject(error);
                } finally {
                    this.activeRequests--;
                    // Process next request in queue
                    setTimeout(() => this.processRequestQueue(), 100);
                }
            }

            requestUserProfile(relayUrl, pubkey) {
                return this.queueRequest(relayUrl, () => {
                    return new Promise((resolve) => {
                        const subscriptionId = "profile-" + Date.now() + "-" + Math.random().toString(36).substr(2, 9);
                        const filters = {
                            "kinds": [0], // Metadata events
                            "authors": [pubkey],
                            "limit": 1
                        };
                        
                        const subscription = ["REQ", subscriptionId, filters];
                        // Profile request sent to relay
                        
                        const timeout = setTimeout(() => {
                            console.log(`⏰ Profile request timeout for ${relayUrl}`);
                            // Close the subscription
                            if (this.websockets[relayUrl]) {
                                this.websockets[relayUrl].send(JSON.stringify(["CLOSE", subscriptionId]));
                            }
                            resolve(null);
                        }, 10000); // 10 second timeout
                        
                        const handleMessage = (event) => {
                            try {
                                const data = JSON.parse(event.data);
                                // Message received from relay
                                if (Array.isArray(data)) {
                                    const [messageType, subId, eventData] = data;
                                    
                                    if (messageType === 'EVENT' && subId === subscriptionId && eventData.kind === 0) {
                                        // Profile event received
                                        
                                        // Only process if pubkey matches
                                        if (eventData.pubkey === pubkey) {
                                            clearTimeout(timeout);
                                            this.websockets[relayUrl].removeEventListener('message', handleMessage);
                                            
                                            // Close the subscription
                                            this.websockets[relayUrl].send(JSON.stringify(["CLOSE", subscriptionId]));
                                            
                                            try {
                                                const metadata = JSON.parse(eventData.content);
                                                const profile = {
                                                    name: metadata.name || metadata.display_name || pubkey.substring(0, 8) + '...',
                                                    pubkey: pubkey,
                                                    picture: metadata.picture,
                                                    about: metadata.about,
                                                    nip05: metadata.nip05, // Add NIP-05 field
                                                    trustroots_username: metadata.trustroots_username, // Add Trustroots username
                                                    website: metadata.website,
                                                    lud16: metadata.lud16,
                                                    trustroots_profile: metadata.trustroots_profile,
                                                    travel_preferences: metadata.travel_preferences,
                                                    created_at: metadata.created_at
                                                };
                                                // Profile processed successfully
                                                // Profile fetched successfully
                                                resolve(profile);
                                            } catch (e) {
                                                console.log(`❌ Error parsing profile for pubkey: ${pubkey}`);
                                                resolve({ name: pubkey.substring(0, 8) + '...', pubkey: pubkey });
                                            }
                                        } else {
                                            console.log(`⚠️ Ignoring profile for different pubkey: ${eventData.pubkey}`);
                                            // Don't resolve yet, wait for the correct profile or EOSE
                                        }
                                    } else if (messageType === 'EOSE' && subId === subscriptionId) {
                                        console.log(`ℹ️ End of stored events from ${relayUrl} - no profile found`);
                                        console.log(`🔍 Resolving promise with null for ${relayUrl}`);
                                        clearTimeout(timeout);
                                        this.websockets[relayUrl].removeEventListener('message', handleMessage);
                                        
                                        // Close the subscription
                                        this.websockets[relayUrl].send(JSON.stringify(["CLOSE", subscriptionId]));
                                        
                                        resolve(null);
                                    }
                                }
                            } catch (e) {
                                // Ignore parsing errors
                            }
                        };
                        
                        this.websockets[relayUrl].addEventListener('message', handleMessage);
                        this.websockets[relayUrl].send(JSON.stringify(subscription));
                    });
                });
            }

            updateHash() {
                this.updatingHash = true; // Prevent circular hash updates
                
                const url = new URL(window.location);
                let hashParts = [];
                
                // Handle search filter - if it's a simple hashtag, use direct format
                if (this.searchFilter) {
                    // Check if it's just a hashtag (starts with #)
                    if (this.searchFilter.startsWith('#')) {
                        // Remove the # prefix since we'll add it when constructing the hash
                        hashParts.push(this.searchFilter.substring(1));
                    } else {
                        // For other search terms, use parameter format
                        hashParts.push(`search=${encodeURIComponent(this.searchFilter)}`);
                    }
                }
                
                // Handle geohash filter
                if (this.geohashFilter) {
                    hashParts.push(`geohash=${this.geohashFilter}`);
                }
                
                // Handle NIP-05 filter
                if (this.nip05Filter) {
                    hashParts.push('nip05=true');
                }
                
                // Update the hash
                if (hashParts.length > 0) {
                    url.hash = `#${hashParts.join('&')}`;
                } else {
                    url.hash = '';
                }
                window.history.replaceState(null, '', url);
                
                this.updatingHash = false; // Reset flag
            }

            loadFilterFromHash() {
                const hash = window.location.hash;
                console.log('Loading filter from hash:', hash);
                if (hash && hash.startsWith('#')) {
                    const hashContent = hash.substring(1); // Remove the # symbol
                    
                    // Check if it starts with a hashtag (no = in the first part)
                    const parts = hashContent.split('&');
                    const firstPart = parts[0];
                    
                    if (!firstPart.includes('=')) {
                        // Direct hashtag format: testing or testing&geohash=u1&nip05=true&eventid=abc123
                        const hashtag = firstPart; // testing
                        
                        // Set the hashtag as search filter (add # prefix)
                        this.searchFilter = '#' + hashtag.toLowerCase();
                        console.log('Set search filter to:', this.searchFilter);
                        const searchFilterInput = document.getElementById('searchFilter');
                        if (searchFilterInput) {
                            searchFilterInput.value = '#' + hashtag;
                            console.log('Updated search filter input to:', '#' + hashtag);
                        }
                        
                        // Parse additional parameters
                        for (let i = 1; i < parts.length; i++) {
                            const [key, value] = parts[i].split('=');
                            if (key === 'geohash') {
                                this.geohashFilter = value.toLowerCase();
                                const geohashFilterInput = document.getElementById('geohashFilter');
                                if (geohashFilterInput) {
                                    geohashFilterInput.value = value;
                                }
                            } else if (key === 'nip05' && value === 'true') {
                                this.nip05Filter = true;
                                const nip05FilterInput = document.getElementById('nip05Filter');
                                if (nip05FilterInput) {
                                    nip05FilterInput.checked = true;
                                }
                            } else if (key === 'eventid') {
                                this.highlightEventId = value;
                                console.log('Event ID to highlight:', value);
                            }
                        }
                    } else {
                        // Try to parse as URL parameters (legacy format)
                        try {
                            const params = new URLSearchParams(hashContent);
                            const search = params.get('search');
                            const geohash = params.get('geohash');
                            const nip05 = params.get('nip05');
                            const eventid = params.get('eventid');
                            
                            if (search) {
                                this.searchFilter = search.toLowerCase();
                                const searchFilterInput = document.getElementById('searchFilter');
                                if (searchFilterInput) {
                                    searchFilterInput.value = search;
                                }
                            }
                            
                            if (geohash) {
                                this.geohashFilter = geohash.toLowerCase();
                                const geohashFilterInput = document.getElementById('geohashFilter');
                                if (geohashFilterInput) {
                                    geohashFilterInput.value = geohash;
                                }
                            }
                            
                            if (nip05 === 'true') {
                                this.nip05Filter = true;
                                const nip05FilterInput = document.getElementById('nip05Filter');
                                if (nip05FilterInput) {
                                    nip05FilterInput.checked = true;
                                }
                            } else {
                                this.nip05Filter = false;
                                const nip05FilterInput = document.getElementById('nip05Filter');
                                if (nip05FilterInput) {
                                    nip05FilterInput.checked = false;
                                }
                            }
                            
                            if (eventid) {
                                this.highlightEventId = eventid;
                                console.log('Event ID to highlight:', eventid);
                            }
                        } catch (e) {
                            // Invalid hash format - ignore
                        }
                    }
                } else {
                    // No hash parameters - ensure filters are in default state
                    this.nip05Filter = false;
                    const nip05FilterInput = document.getElementById('nip05Filter');
                    if (nip05FilterInput) {
                        nip05FilterInput.checked = false;
                    }
                }
                
                // Handle geohash zoom and grid display
                if (this.geohashFilter && this.isGeohash(this.geohashFilter)) {
                    // Show appropriate grid level based on geohash length
                    if (this.geohashFilter.length < 6) {
                        this.showNextLevelGeohashGrid(this.geohashFilter);
                    } else {
                        // For 6-character geohashes, just highlight the area
                        this.highlightGeohashArea(this.geohashFilter);
                    }
                } else {
                    // No geohash filter - show global grid
                    this.showGeohashGrid();
                }
                
                // Update display after loading filters
                this.displayActivities();
                this.updateUnreadCount(); // Update unread count for any new DMs
                
                // If there's an event ID to highlight, do it after a short delay
                if (this.highlightEventId) {
                    setTimeout(() => {
                        this.highlightAndScrollToNote(this.highlightEventId);
                    }, 1000); // Wait 1 second for notes to load
                }
                // Filter state loaded from hash
            }

            highlightAndScrollToNote(eventId) {
                console.log('Attempting to highlight note with event ID:', eventId);
                
                // Find the note with the matching event ID
                const note = this.notes.find(n => n.id === eventId);
                if (!note) {
                    console.log('Note not found with event ID:', eventId);
                    return;
                }
                
                console.log('Found note to highlight:', note);
                
                // Find the note element in the DOM
                const noteElement = document.querySelector(`[data-note-id="${eventId}"]`);
                if (!noteElement) {
                    console.log('Note element not found in DOM for event ID:', eventId);
                    return;
                }
                
                // Add highlight styling
                noteElement.style.backgroundColor = 'rgba(52, 152, 219, 0.2)';
                noteElement.style.border = '2px solid #3498db';
                noteElement.style.borderRadius = '8px';
                noteElement.style.padding = '8px';
                noteElement.style.margin = '4px 0';
                
                // Scroll to the note
                noteElement.scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'center',
                    inline: 'nearest'
                });
                
                // Remove highlight after 5 seconds
                setTimeout(() => {
                    noteElement.style.backgroundColor = '';
                    noteElement.style.border = '';
                    noteElement.style.borderRadius = '';
                    noteElement.style.padding = '';
                    noteElement.style.margin = '';
                }, 5000);
                
                console.log('Note highlighted and scrolled to');
            }

            getFilteredActivities() {
                // Filter out profile notes (kind 0) - they shouldn't appear in chat
                let filtered = this.notes.filter(note => note.kind !== 0);
                
                // Notes filtered
                
                // Apply geohash filter (only when geohash filter is active)
                if (this.geohashFilter) {
                    const beforeCount = filtered.length;
                    const geohashTerm = this.geohashFilter.toLowerCase();
                    filtered = filtered.filter(note => {
                        // Check if note has matching geohash
                        const hasMatchingGeohash = note.tags && note.tags.some(tag => 
                            tag[0] === 'g' && 
                            tag[1] && 
                            tag[1].toLowerCase().includes(geohashTerm)
                        );
                        
                        // Show note if it has matching geohash
                        return hasMatchingGeohash;
                    });
                    // Geohash filter applied
                }
                
                // Apply search filter (hashtags, content, usernames)
                if (this.searchFilter) {
                    const beforeCount = filtered.length;
                    const searchTerm = this.searchFilter.toLowerCase();
                    filtered = filtered.filter(note => {
                        // Search in hashtag tags
                        const hasHashtagMatch = note.tags && note.tags.some(tag => 
                            tag[0] === 't' && 
                            tag[1] && 
                            tag[1].toLowerCase().includes(searchTerm)
                        );
                        
                        // Search in note content
                        const hasContentMatch = note.content && 
                            note.content.toLowerCase().includes(searchTerm);
                        
                        // Search in username (if we have profile data)
                        const profile = this.userProfiles[note.pubkey];
                        const hasUsernameMatch = profile && profile.name && 
                            profile.name.toLowerCase().includes(searchTerm);
                        
                        // Search in geohash tags
                        const hasGeohashMatch = note.tags && note.tags.some(tag => 
                            tag[0] === 'g' && 
                            tag[1] && 
                            tag[1].toLowerCase().includes(searchTerm)
                        );
                        
                        return hasHashtagMatch || hasContentMatch || hasUsernameMatch || hasGeohashMatch;
                    });
                    // Search filter applied
                }
                
                // Apply NIP-05 verification filter
                if (this.nip05Filter) {
                    const beforeCount = filtered.length;
                    filtered = filtered.filter(note => {
                        if (!note.tags) return false;
                        
                        return note.tags.some(tag => 
                            tag[0] === 'nip05' && 
                            tag[1] && 
                            tag[1].endsWith('@trustroots.org')
                        );
                    });
                    console.log('NIP-05 filter applied:', beforeCount, '->', filtered.length);
                }
                
                // Filtering complete
                return filtered;
            }





            async connectToRelays() {
                const noteContainer = document.getElementById('noteContainer');
                noteContainer.innerHTML = '<div class="loading">Connecting to TRipchat Nostr relays...</div>';

                // Starting connection to relays

                for (const relayUrl of this.relays) {
                    this.connectToRelay(relayUrl);
                }
                
                // Set a timeout to show connection status
                setTimeout(() => {
                    this.updateConnectionStatus();
                }, 5000);
            }

            updateConnectionStatus() {
                const noteContainer = document.getElementById('noteContainer');
                const connectedRelays = Object.values(this.relayStatus).filter(status => status.status === 'connected').length;
                const totalRelays = this.relays.length;
                
                if (connectedRelays === 0) {
                    noteContainer.innerHTML = '<div class="loading">❌ Failed to connect to any relays. Check console for errors.</div>';
                } else if (connectedRelays < totalRelays) {
                    noteContainer.innerHTML = `<div class="loading">⚠️ Connected to ${connectedRelays}/${totalRelays} relays. Events received: ${this.totalEventsReceived}, Notes: ${this.notes.length}</div>`;
                } else {
                    noteContainer.innerHTML = `<div class="loading">✅ Connected to all relays. Events received: ${this.totalEventsReceived}, Notes: ${this.notes.length}</div>`;
                }
                
                // If we have notes, display them
                if (this.notes.length > 0) {
                    this.displayActivities(this.notes);
                    // Preload profiles for faster green link display (throttled)
                    this.preloadVisibleProfiles();
                }
            }

            connectToRelay(relayUrl) {
                this.updateRelayStatus(relayUrl, 'connecting');

                try {
                    const ws = new WebSocket(relayUrl);
                    this.websockets[relayUrl] = ws;
                    
                    const subscriptionId = "tripchat-note-" + Math.random().toString(36).substr(2, 9);
                    this.subscriptionIds[relayUrl] = subscriptionId;

                    ws.onopen = () => {
                        this.updateRelayStatus(relayUrl, 'connected');
                        
                        // Subscribe to TRipchat-specific event kinds
                        const currentUserPubkey = this.getCurrentUserPubkey();
                        const currentUserHex = currentUserPubkey ? this.npubToHex(currentUserPubkey) : null;
                        
                        // Basic filters for public content
                        const publicFilters = {
                            "kinds": [1, 0], // Text notes + profiles
                            "limit": 100,
                            "since": Math.floor(Date.now() / 1000) - (7 * 24 * 60 * 60) // Last 7 days
                        };
                        
                        // Send public content subscription
                        const publicSubscription = [
                            "REQ",
                            subscriptionId + "-public",
                            publicFilters
                        ];
                        ws.send(JSON.stringify(publicSubscription));
                        
                        // Send DM subscription if user has keys
                        if (currentUserHex) {
                            const dmFilters = {
                                "kinds": [4], // DMs only
                                "authors": [currentUserHex], // Messages sent by us
                                "limit": 100,
                                "since": Math.floor(Date.now() / 1000) - (30 * 24 * 60 * 60) // Last 30 days for DMs
                            };
                            
                            const dmSubscription = [
                                "REQ",
                                subscriptionId + "-dms-sent",
                                dmFilters
                            ];
                            ws.send(JSON.stringify(dmSubscription));
                            
                            // Also request DMs where we are the recipient (using p tag)
                            const dmReceivedFilters = {
                                "kinds": [4], // DMs only
                                "#p": [currentUserHex], // Messages where we are in the p tag (recipient)
                                "limit": 100,
                                "since": Math.floor(Date.now() / 1000) - (30 * 24 * 60 * 60) // Last 30 days for DMs
                            };
                            
                            const dmReceivedSubscription = [
                                "REQ",
                                subscriptionId + "-dms-received",
                                dmReceivedFilters
                            ];
                            ws.send(JSON.stringify(dmReceivedSubscription));
                        }
                        
                        // Update connection status
                        this.updateConnectionStatus();
                    };

                    ws.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            // Received data from relay
                            
                            if (Array.isArray(data)) {
                                const [messageType, subId, eventData] = data;
                                
                                if (messageType === 'EVENT' && eventData && (subId === subscriptionId || subId.startsWith('tripchat-live-') || subId.includes('-public') || subId.includes('-dms-sent') || subId.includes('-dms-received'))) {
                                    this.totalEventsReceived++;
                                    const noteAge = Math.floor((Date.now() / 1000) - eventData.created_at);
                                    const ageHours = Math.floor(noteAge / 3600);
                                    const ageDays = Math.floor(ageHours / 24);
                                    // Received event
                                    
                                    // Check for geohash tags in events
                                    
                                    // Check if this is TRipchat note
                                    if (this.isTRipchatNote(eventData)) {
                                        this.addNewNote(eventData);
                                        this.updateRelayStatus(relayUrl, 'connected', this.notes.length);
                                        this.updateConnectionStatus();
                                    }
                } else if (messageType === 'EOSE' && subId === subscriptionId) {
                    this.updateRelayStatus(relayUrl, 'connected', this.notes.length);
                    this.updateConnectionStatus();
                    
                    // Start live subscription for new notes
                    this.startLiveSubscription(relayUrl);
                    
                    // Track completed relays for initial load
                    this.completedRelays.add(relayUrl);
                    this.checkAllRelaysCompleted();
                    
                    // Show load more button after initial load
                    if (!this.initialLoadComplete) {
                        this.initialLoadComplete = true;
                    }
                } else if (messageType === 'NOTICE') {
                                    // Notice from relay
                                }
                            }
                        } catch (e) {
                            console.warn('Error parsing message from', relayUrl, ':', e);
                        }
                    };

                    ws.onerror = (error) => {
                        console.error(`Error connecting to ${relayUrl}:`, error);
                        this.updateRelayStatus(relayUrl, 'disconnected');
                        this.updateConnectionStatus();
                    };

                    ws.onclose = () => {
                        this.updateRelayStatus(relayUrl, 'disconnected');
                        
                        setTimeout(() => {
                            this.connectToRelay(relayUrl);
                        }, 5000);
                    };
                } catch (error) {
                    console.error(`Failed to connect to ${relayUrl}:`, error);
                    this.updateRelayStatus(relayUrl, 'disconnected');
                }
            }

            isTRipchatNote(event) {
                // Accept Kind 1 events (text notes)
                if (event.kind === 1) {
                    return true;
                }
                
                // Check if it has location-related content
                const content = event.content || '';
                const hasLocationKeywords = /travel|trip|location|geohash|trustroots|hitchhiking/i.test(content);
                if (hasLocationKeywords) {
                    return true;
                }
                
                return false;
            }

            startLiveSubscription(relayUrl) {
                // Subscribe to new notes in real-time
                const liveSubscriptionId = "tripchat-live-" + Math.random().toString(36).substr(2, 9);
                const liveFilters = {
                    "kinds": [1], // Only text notes for live updates
                    "since": Math.floor(Date.now() / 1000) // Only new notes from now
                };
                
                const liveSubscription = [
                    "REQ",
                    liveSubscriptionId,
                    liveFilters
                ];
                
                // Starting live subscription
                
                if (this.websockets[relayUrl]) {
                    this.websockets[relayUrl].send(JSON.stringify(liveSubscription));
                }
            }

            checkAllRelaysCompleted() {
                // Check if all enabled relays have completed their initial load
                const enabledRelays = this.relays.filter(relay => this.relayEnabled[relay] !== false);
                // Check relay completion status
                
                if (this.completedRelays.size >= enabledRelays.length) {
                    // Auto-scroll to bottom after all notes have loaded
                    setTimeout(() => {
                        this.scrollToBottom();
                        // Focus on compose content after loading
                        const composeContent = document.getElementById('composeContent');
                        if (composeContent) {
                            composeContent.focus();
                        }
                    }, 200); // Shorter delay since displayActivities already has a 100ms delay
                }
            }

            addNewNote(note) {
                // Skip profile notes (kind 0) - they shouldn't appear in chat
                if (note.kind === 0) {
                    return;
                }

                // Check if note already exists
                if (this.notes.find(a => a.id === note.id)) {
                    // Note already exists, skipping
                    return;
                }

                // Store DMs (kind 4) but don't display them in main chat
                if (note.kind === 4) {
                    console.log('🔍 PM Debug - Adding DM to notes array:', { 
                        id: note.id, 
                        pubkey: note.pubkey, 
                        tags: note.tags,
                        contentLength: note.content?.length 
                    });
                    this.notes.push(note);
                    this.updateUnreadCount(); // Update unread count for DMs
                    console.log('🔍 PM Debug - DM added. Total notes now:', this.notes.length);
                    return;
                }

                // Ensure created_at is a number
                if (typeof note.created_at !== 'number') {
                    console.warn(`Note ${note.id} has invalid created_at:`, note.created_at);
                    note.created_at = Math.floor(Date.now() / 1000);
                }

                // Adding note
                
                this.notes.push(note);
                this.notes.sort((a, b) => {
                    const aTime = typeof a.created_at === 'number' ? a.created_at : parseInt(a.created_at);
                    const bTime = typeof b.created_at === 'number' ? b.created_at : parseInt(b.created_at);
                    return aTime - bTime; // Sort oldest first (newest at bottom)
                });
                
                // Note added to collection
                
                if (this.notes.length > 200) {
                    this.notes = this.notes.slice(-200); // Keep newest 200 notes (last 200)
                }

                // Profile will be fetched by preloadVisibleProfiles when needed

                // Show live indicator
                const liveIndicator = document.getElementById('liveIndicator');
                if (liveIndicator) {
                    liveIndicator.style.display = 'block';
                    setTimeout(() => {
                        liveIndicator.style.display = 'none';
                    }, 3000);
                }

                this.displayActivities(this.notes);
                this.plotActivitiesOnMap(this.notes);
                
                // Add visual effect to the new note
                setTimeout(() => {
                    const noteElement = document.querySelector(`[data-note-id="${note.id}"]`);
                    if (noteElement) {
                        noteElement.classList.add('note-new');
                        setTimeout(() => {
                            noteElement.classList.remove('note-new');
                        }, 500);
                    }
                }, 100);
                
            }

            displayActivities(notes) {
                const noteContainer = document.getElementById('noteContainer');
                const filteredActivities = this.getFilteredActivities();
                const nonExpiredActivities = this.filterExpiredNotes(filteredActivities);
                
                if (nonExpiredActivities.length === 0) {
                    if (this.searchFilter || this.geohashFilter) {
                        const filterText = this.geohashFilter ? `geohash "${this.geohashFilter}"` : `search "${this.searchFilter}"`;
                        noteContainer.innerHTML = `<div class="loading">No notes found for ${filterText}. Try a different search term, clear the filter or post something yourself!</div>`;
                    } else {
                        noteContainer.innerHTML = '<div class="loading">No TRipchat note found. Check the browser console for debug information.</div>';
                    }
                    return;
                }

                const loadingDiv = noteContainer.querySelector('.loading');
                if (loadingDiv) {
                    loadingDiv.remove();
                }

                // Ensure created_at is a number before sorting
                const sortedActivities = [...nonExpiredActivities].sort((a, b) => {
                    const aTime = typeof a.created_at === 'number' ? a.created_at : parseInt(a.created_at);
                    const bTime = typeof b.created_at === 'number' ? b.created_at : parseInt(b.created_at);
                    return aTime - bTime; // Oldest first (newest at bottom)
                });
                const limitedActivities = sortedActivities.slice(-50); // Take last 50 notes (newest at bottom)
                
                
                
                noteContainer.innerHTML = '';

                limitedActivities.forEach(note => {
                    const noteDiv = document.createElement('div');
                    
                    // Add persistence classes
                    const isExpiring = this.isExpiringSoon(note);
                    noteDiv.className = `note-item persistent ${isExpiring ? 'expiring' : ''}`;
                    noteDiv.setAttribute('data-note-id', note.id);
                    
                    try {
                        const timestamp = new Date(note.created_at * 1000);
                        const timeString = this.formatTime(timestamp);
                        const relativeTime = this.getRelativeTime(timestamp);
                        
                        const renderedHtml = this.renderNote(note, timeString, relativeTime);
                        
                        if (renderedHtml && typeof renderedHtml === 'string' && renderedHtml.trim().length > 0) {
                            noteDiv.innerHTML = renderedHtml;
                        } else {
                            noteDiv.innerHTML = this.renderFallbackNote(note, timeString, relativeTime);
                        }
                        
                        // Expiration info is now combined with timestamp in renderNote
                    } catch (error) {
                        console.error('Error rendering note:', error, note);
                        noteDiv.innerHTML = this.renderFallbackNote(note, timeString, relativeTime);
                    }
                    
                    noteContainer.appendChild(noteDiv);
                });
                
                // Set up click handlers for geohash tags
                this.setupGeohashTagClickHandlers();
                
                // Scroll to bottom to show latest messages (with delay to ensure DOM is rendered)
                setTimeout(() => {
                    this.scrollToBottom();
                }, 100);
                
                // Set up click handlers for hashtag links
                this.setupHashtagClickHandlers();
                
            }

            renderNote(note, timeString, relativeTime) {
                const content = note.content || '';
                const processedContent = content.replace(/\n/g, '<br>');
                
                // Extract geohash tags (prioritize geohash over coordinates)
                const geohashTags = [];
                let hasGeohash = false;
                
                if (note.tags) {
                    // First pass: look for geohash tags
                    for (const tag of note.tags) {
                        if (tag[0] === 'g' && tag[1]) {
                            if (this.isGeohash(tag[1])) {
                                geohashTags.push(tag[1]);
                                hasGeohash = true;
                            }
                        }
                    }
                    
                    // Second pass: look for coordinate tags only if no geohash was found
                    if (!hasGeohash) {
                        for (const tag of note.tags) {
                            if (tag[0] === 'g' && tag[1]) {
                                const coordMatch = tag[1].match(/^(-?\d+\.?\d*),(-?\d+\.?\d*)$/);
                                if (coordMatch) {
                                    geohashTags.push(tag[1]);
                                }
                            }
                        }
                    }
                }
                
                const geohashHtml = geohashTags.length > 0 ? `
                    <div style="margin: 8px 0; text-align: right;">
                        ${geohashTags.map(geohash => `<span class="geohash-tag" data-geohash="${geohash}">📍 ${geohash}</span>`).join('')}
                    </div>
                ` : '';
                
                const noteType = this.getNoteType(note);
                
                // Get username from profile cache with discriminator
                const profile = this.userProfiles[note.pubkey];
                // Rendering note with profile data
                const username = this.formatUsernameWithDiscriminator(profile, note.pubkey);
                
                // Process content to make URLs and hashtags clickable
                let contentHtml = this.processContent(processedContent);
                
                // Get expiration info for combined timestamp
                let expirationText = '';
                const expirationTag = note.tags?.find(tag => tag[0] === 'expires_at');
                if (expirationTag) {
                    const expiresAt = parseInt(expirationTag[1]);
                    const now = Math.floor(Date.now() / 1000);
                    const timeLeft = expiresAt - now;
                    
                    if (timeLeft > 0) {
                        const hoursLeft = Math.floor(timeLeft / 3600);
                        const minutesLeft = Math.floor(timeLeft / 60);
                        
                        if (hoursLeft >= 1) {
                            expirationText = ` • expires in ${hoursLeft}h`;
                        } else if (minutesLeft >= 1) {
                            expirationText = ` • expires in ${minutesLeft}m`;
                        } else {
                            expirationText = ` • expires in <1m`;
                        }
                    }
                }

                // Check if this note is by the current user
                const isCurrentUser = this.isNoteByCurrentUser(note);
                const deleteButton = isCurrentUser ? `<button class="note-delete-btn" data-note-id="${note.id}" onclick="window.tripchatVisualizer.deleteNote('${note.id}')" title="Delete this note">🗑️ DELETE</button>` : '';
                
                // Add reply button for all notes
                const replyButton = `<button class="note-reply-btn" data-note-id="${note.id}" data-npub="${note.pubkey}" onclick="window.tripchatVisualizer.replyToNote('${note.id}', '${note.pubkey}')" title="Reply to this note">💬 Reply</button>`;
                
                // Add PM button for all notes (except our own)
                const pmButton = !isCurrentUser ? `<button class="note-pm-btn" data-note-id="${note.id}" data-npub="${note.pubkey}" onclick="window.tripchatVisualizer.openPM('${note.pubkey}')" title="Send private message">✉️ PM</button>` : '';

                return `
                    <div class="note-header">
                        <span class="note-username" style="font-weight: 600; font-size: 0.75rem;">${username}</span>
                    </div>
                    <div class="note-time" title="Click to view raw Nostr data: ${timeString}" data-note-id="${note.id}" style="font-size: 0.5rem; color: var(--text-muted); text-align: right; line-height: 1.2; margin-bottom: 4px;">
                        <div>${relativeTime}</div>
                        ${expirationText ? `<div style="font-size: 0.45rem; margin-top: 1px;">${expirationText.replace(' • ', '')}</div>` : ''}
                    </div>
                    <div class="note-content">${contentHtml}</div>
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 8px;">
                        <div style="display: flex; gap: 8px;">
                            ${geohashTags.map(geohash => `<span class="geohash-tag" data-geohash="${geohash}" style="background: #e9ecef; color: #6c757d; padding: 2px 6px; border-radius: 4px; font-size: 0.7rem;">📍 ${geohash}</span>`).join('')}
                        </div>
                        <div style="display: flex; gap: 8px;">
                            ${replyButton}
                            ${pmButton}
                            ${deleteButton}
                        </div>
                    </div>
                `;
            }

            getNoteType(note) {
                // All notes are Kind 1 (text notes)
                return '';
            }

            processContent(content) {
                // First process markdown formatting on raw content
                let markdownProcessedContent = this.processMarkdown(content);
                
                // Then process URLs on markdown-processed content
                let urlProcessedContent = this.processUrls(markdownProcessedContent);
                
                // Then process hashtags
                let hashtagProcessedContent = this.processHashtags(urlProcessedContent);
                
                // Finally sanitize HTML to prevent XSS attacks
                return this.sanitizeHtml(hashtagProcessedContent);
            }

            processUrls(content) {
                // URL regex pattern that matches http/https URLs but not inside existing HTML tags
                const urlRegex = /(https?:\/\/[^\s<>]+)/g;
                
                return content.replace(urlRegex, (url) => {
                    // Skip if this looks like it's already inside HTML
                    if (url.includes('<') || url.includes('>') || url.includes('"')) {
                        return url;
                    }
                    
                    try {
                        const urlObj = new URL(url);
                        const domain = urlObj.hostname.toLowerCase();
                        
                        // Check if it's a trusted domain
                        const isHitchwiki = domain === 'hitchwiki.org' || domain.endsWith('.hitchwiki.org');
                        const isTrustroots = domain === 'trustroots.org' || domain.endsWith('.trustroots.org');
                        const isNomadwiki = domain === 'nomadwiki.org' || domain.endsWith('.nomadwiki.org');
                        const isTrashwiki = domain === 'trashwiki.org' || domain.endsWith('.trashwiki.org');
                        
                        if (isHitchwiki || isTrustroots || isNomadwiki || isTrashwiki) {
                            // Decode URL for display while keeping original for href
                            const displayUrl = decodeURIComponent(url);
                            return `<a href="${url}" target="_blank" rel="noopener noreferrer" class="external-link">${displayUrl}</a>`;
                        } else {
                            // Return as plain text for untrusted domains
                            return url;
                        }
                    } catch (error) {
                        // If URL parsing fails, return as plain text
                        return url;
                    }
                });
            }

            processMarkdown(content) {
                // Process markdown formatting while preserving existing HTML
                let processed = content;
                
                // Headers (### Header, ## Header, # Header)
                processed = processed.replace(/^### (.*$)/gim, '<h3>$1</h3>');
                processed = processed.replace(/^## (.*$)/gim, '<h2>$1</h2>');
                processed = processed.replace(/^# (.*$)/gim, '<h1>$1</h1>');
                
                // Bold text (**bold** or __bold__)
                processed = processed.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                processed = processed.replace(/__(.*?)__/g, '<strong>$1</strong>');
                
                // Italic text (*italic* or _italic_)
                processed = processed.replace(/\*(.*?)\*/g, '<em>$1</em>');
                processed = processed.replace(/_(.*?)_/g, '<em>$1</em>');
                
                // Code spans (`code`)
                processed = processed.replace(/`([^`]+)`/g, '<code>$1</code>');
                
                // Strikethrough (~~strikethrough~~)
                processed = processed.replace(/~~(.*?)~~/g, '<del>$1</del>');
                
                // Unordered lists (- item or * item)
                processed = processed.replace(/^[\s]*[-*] (.*$)/gim, '<li>$1</li>');
                
                // Ordered lists (1. item)
                processed = processed.replace(/^[\s]*\d+\. (.*$)/gim, '<li>$1</li>');
                
                // Wrap consecutive list items in <ul> or <ol>
                processed = processed.replace(/(<li>.*<\/li>)/gs, (match) => {
                    // Check if it's an ordered list (contains numbers)
                    const hasNumbers = /^\s*\d+\./.test(match);
                    const listTag = hasNumbers ? 'ol' : 'ul';
                    return `<${listTag}>${match}</${listTag}>`;
                });
                
                // Blockquotes (> quote)
                processed = processed.replace(/^> (.*$)/gim, '<blockquote>$1</blockquote>');
                
                // Line breaks (double newline = paragraph break)
                processed = processed.replace(/\n\n/g, '</p><p>');
                processed = processed.replace(/\n/g, '<br>');
                
                // Wrap in paragraph tags if not already wrapped
                if (!processed.startsWith('<') || !processed.includes('<p>')) {
                    processed = '<p>' + processed + '</p>';
                }
                
                return processed;
            }

            processHashtags(content) {
                // Create a mapping of hashtags to circle slugs
                const hashtagToCircleMap = {
                    'hitchhiking': 'hitchhikers',
                    'hitchhikers': 'hitchhikers',
                    'hitchwiki': 'hitchhikers',
                    'dumpster': 'dumpster-divers',
                    'dumpsterdiving': 'dumpster-divers',
                    'family': 'families',
                    'families': 'families',
                    'kids': 'families',
                    'music': 'musicians',
                    'musicians': 'musicians',
                    'busking': 'buskers',
                    'buskers': 'buskers',
                    'vegan': 'veg',
                    'vegetarian': 'veg',
                    'veg': 'veg',
                    'hacker': 'hackers',
                    'hackers': 'hackers',
                    'coding': 'hackers',
                    'lgbtq': 'lgbtq',
                    'lgbt': 'lgbtq',
                    'eco': 'ecoliving',
                    'ecoliving': 'ecoliving',
                    'sustainable': 'ecoliving',
                    'lindy': 'lindyhoppers',
                    'lindyhop': 'lindyhoppers',
                    'swing': 'lindyhoppers',
                    'dance': 'lindyhoppers',
                    'nomad': 'nomads',
                    'nomads': 'nomads',
                    'travel': 'nomads',
                    'punk': 'punks',
                    'punks': 'punks',
                    'cycling': 'cyclists',
                    'cyclists': 'cyclists',
                    'bike': 'cyclists',
                    'foodsharing': 'foodsharing',
                    'foodsharing': 'foodsharing',
                    'yoga': 'yoga',
                    'climbing': 'climbers',
                    'climbers': 'climbers',
                    'hiking': 'hikers',
                    'hikers': 'hikers',
                    'sailing': 'sailors',
                    'sailors': 'sailors',
                    'art': 'artists',
                    'artists': 'artists',
                    'creative': 'artists'
                };

                // Replace hashtags with clickable links
                return content.replace(/#([a-zA-Z0-9_]+)/g, (match, hashtag) => {
                    const circleSlug = hashtagToCircleMap[hashtag.toLowerCase()];
                    if (circleSlug) {
                        return `<a href="#" class="hashtag-link" data-circle="${circleSlug}" data-hashtag="${hashtag}">#${hashtag}</a>`;
                    } else {
                        return `<a href="#" class="hashtag-link" data-hashtag="${hashtag}">#${hashtag}</a>`;
                    }
                });
            }

            renderFallbackNote(note, timeString, relativeTime) {
                const profile = this.userProfiles[note.pubkey];
                const username = this.formatUsernameWithDiscriminator(profile, note.pubkey);
                
                // Process content in fallback note
                const content = note.content || 'No content';
                const processedContent = this.processContent(content);
                
                // Check if this note is by the current user
                const isCurrentUser = this.isNoteByCurrentUser(note);
                const deleteButton = isCurrentUser ? `<button class="note-delete-btn" data-note-id="${note.id}" onclick="window.tripchatVisualizer.deleteNote('${note.id}')" title="Delete this note">🗑️ DELETE</button>` : '';
                
                return `
                    <div class="note-header">
                        <span class="note-username" style="font-weight: 600; font-size: 0.75rem;">${username}</span>
                    </div>
                    <div class="note-time" title="Click to view raw Nostr data: ${timeString}" data-note-id="${note.id}" style="font-size: 0.5rem; color: var(--text-muted); text-align: right; margin-bottom: 4px;">${relativeTime}</div>
                    <div class="note-content">${processedContent}</div>
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 8px;">
                        <div style="display: flex; gap: 8px;">
                            <span style="background: #e9ecef; color: #6c757d; padding: 2px 6px; border-radius: 4px; font-size: 0.7rem;">Kind ${note.kind || 'Unknown'}</span>
                        </div>
                    </div>
                    ${deleteButton}
                `;
            }


            formatTime(date) {
                return date.toLocaleString('en-CA', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: false
                });
            }

            getRelativeTime(date) {
                const now = new Date();
                const diffInSeconds = Math.floor((now - date) / 1000);
                
                if (diffInSeconds < 60) return 'just now';
                if (diffInSeconds < 3600) return `${Math.floor(diffInSeconds / 60)}m ago`;
                if (diffInSeconds < 86400) return `${Math.floor(diffInSeconds / 3600)}h ago`;
                if (diffInSeconds < 2592000) return `${Math.floor(diffInSeconds / 86400)}d ago`;
                
                return date.toLocaleDateString();
            }

            extractGeoLocation(note) {
                let lat = null;
                let lng = null;
                let location = null;
                let hasGeohash = false;
                let hasCoordinates = false;
                
                if (note.tags) {
                    // First pass: look for geohash (prioritize geohash over coordinates)
                    for (const tag of note.tags) {
                        if (tag[0] === 'g' && tag[1]) {
                            if (this.isGeohash(tag[1])) {
                                const coords = this.geohashToLatLng(tag[1]);
                                if (coords) {
                                    lat = coords.lat;
                                    lng = coords.lng;
                                    location = `Geohash: ${tag[1]}`;
                                    hasGeohash = true;
                                    break;
                                }
                            }
                        }
                    }
                    
                    // Second pass: look for coordinates only if no geohash was found
                    if (!hasGeohash) {
                        for (const tag of note.tags) {
                            if (tag[0] === 'g' && tag[1]) {
                                const coordMatch = tag[1].match(/^(-?\d+\.?\d*),(-?\d+\.?\d*)$/);
                                if (coordMatch) {
                                    lat = parseFloat(coordMatch[1]);
                                    lng = parseFloat(coordMatch[2]);
                                    location = `Coordinates: ${tag[1]}`;
                                    hasCoordinates = true;
                                    break;
                                }
                            }
                        }
                    }
                }
                
                if (lat && lng && lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180) {
                    return { lat, lng, location: location || `${lat.toFixed(4)}, ${lng.toFixed(4)}` };
                }
                
                return null;
            }

            isGeohash(str) {
                // Geohash uses base32 encoding: 0-9, b-h, j-k, m-n, p-z (excludes a, i, l, o)
                // For tripch.at, we only want actual geohashes, not common words
                const hasValidChars = /^[0-9bcdefghjkmnpqrstuvwxyz]+$/.test(str);
                const hasValidLength = str.length >= 1 && str.length <= 12;
                
                // Strict requirements for geohashes:
                // 1. Must contain at least one number (real geohashes always have numbers)
                // 2. Must not be a common English word
                const hasNumber = /[0-9]/.test(str);
                const isCommonWord = [
                    'buskers', 'musicians', 'travelers', 'hitchhikers', 'nomads', 'artists', 'writers', 'photographers',
                    'cypherpunk', 'cypherpunks', 'bitcoin', 'crypto', 'blockchain', 'privacy', 'freedom', 'liberty',
                    'anarchist', 'anarchists', 'hacker', 'hackers', 'developer', 'developers', 'programmer', 'programmers'
                ].includes(str.toLowerCase());
                
                const result = hasValidChars && hasValidLength && hasNumber && !isCommonWord;
                return result;
            }

            // Generate single-character geohash codes and their bounds
            generateSingleCharGeohashes() {
                const base32 = "0123456789bcdefghjkmnpqrstuvwxyz";
                const geohashes = [];
                
                for (let i = 0; i < base32.length; i++) {
                    const char = base32[i];
                    const bounds = this.geohashToBounds(char);
                    if (bounds) {
                        geohashes.push({
                            code: char,
                            bounds: bounds
                        });
                    }
                }
                
                return geohashes;
            }

            // Show geohash grid overlay on map
            showGeohashGrid() {
                // Clear existing grid
                this.clearGeohashGrid();
                
                // Only show global grid when zoomed out (zoom level 3 or less) and no specific geohash is selected
                if (this.map.getZoom() > 3 || this.geohashFilter) {
                    return;
                }
                
                const geohashes = this.generateSingleCharGeohashes();
                const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
                
                geohashes.forEach(({ code, bounds }) => {
                    // Create rectangle for the geohash area
                    const rectangle = L.rectangle([
                        [bounds.south, bounds.west],
                        [bounds.north, bounds.east]
                    ], {
                        color: isDark ? '#58a6ff' : '#3498db',
                        fillColor: isDark ? '#58a6ff' : '#3498db',
                        fillOpacity: 0.01,
                        weight: 0.8,
                        opacity: 0.1,
                        className: 'geohash-grid-cell'
                    });
                    
                    // Add click handler to filter by this geohash
                    rectangle.on('click', () => {
                        this.filterByGeohash(code);
                    });
                    
                    // Create text label for the geohash code
                    const centerLat = (bounds.south + bounds.north) / 2;
                    const centerLng = (bounds.west + bounds.east) / 2;
                    
                    const label = L.marker([centerLat, centerLng], {
                        icon: L.divIcon({
                            className: 'geohash-grid-label',
                            html: `<div style="
                                background: ${isDark ? 'rgba(88, 166, 255, 0.4)' : 'rgba(52, 152, 219, 0.4)'};
                                color: white;
                                font-weight: bold;
                                font-size: 20px;
                                padding: 8px 12px;
                                border-radius: 8px;
                                text-align: center;
                                min-width: 32px;
                                box-shadow: 0 3px 8px rgba(0,0,0,0.2);
                                cursor: pointer;
                                user-select: none;
                                border: 2px solid ${isDark ? 'rgba(88, 166, 255, 0.5)' : 'rgba(52, 152, 219, 0.5)'};
                            ">${code.toLowerCase()}</div>`,
                            iconSize: [44, 32],
                            iconAnchor: [22, 16]
                        })
                    });
                    
                    // Add click handler to label
                    label.on('click', () => {
                        this.filterByGeohash(code);
                    });
                    
                    // Add to map
                    rectangle.addTo(this.map);
                    label.addTo(this.map);
                    
                    // Store references for cleanup
                    this.geohashGridRectangles = this.geohashGridRectangles || [];
                    this.geohashGridLabels = this.geohashGridLabels || [];
                    this.geohashGridRectangles.push(rectangle);
                    this.geohashGridLabels.push(label);
                });
            }

            // Clear geohash grid overlay
            clearGeohashGrid() {
                if (this.geohashGridRectangles) {
                    this.geohashGridRectangles.forEach(rect => this.map.removeLayer(rect));
                    this.geohashGridRectangles = [];
                }
                if (this.geohashGridLabels) {
                    this.geohashGridLabels.forEach(label => this.map.removeLayer(label));
                    this.geohashGridLabels = [];
                }
            }

            // Show next level geohash grid within a parent geohash area
            showNextLevelGeohashGrid(parentGeohash) {
                // Clear existing grid
                this.clearGeohashGrid();
                
                // Get the bounds of the parent geohash
                const parentBounds = this.geohashToBounds(parentGeohash);
                if (!parentBounds) return;
                
                // Generate all possible next-level geohashes
                const base32 = "0123456789bcdefghjkmnpqrstuvwxyz";
                const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
                
                // Determine styling based on geohash length
                const level = parentGeohash.length;
                const isGlobal = level === 0;
                const isFirstLevel = level === 1;
                const isSecondLevel = level === 2;
                const isThirdLevel = level === 3;
                const isFourthLevel = level === 4;
                const isFifthLevel = level === 5;
                
                // Style configuration for each level
                const getLevelStyle = (level) => {
                    switch (level) {
                        case 1: // Single character -> 2 character
                            return {
                                fontSize: '18px',
                                padding: '6px 10px',
                                minWidth: '32px',
                                iconSize: [40, 28],
                                iconAnchor: [20, 14],
                                fillOpacity: 0.015,
                                opacity: 0.12,
                                weight: 0.8
                            };
                        case 2: // 2 character -> 3 character
                            return {
                                fontSize: '16px',
                                padding: '5px 8px',
                                minWidth: '28px',
                                iconSize: [36, 24],
                                iconAnchor: [18, 12],
                                fillOpacity: 0.02,
                                opacity: 0.15,
                                weight: 0.6
                            };
                        case 3: // 3 character -> 4 character
                            return {
                                fontSize: '14px',
                                padding: '4px 6px',
                                minWidth: '24px',
                                iconSize: [32, 20],
                                iconAnchor: [16, 10],
                                fillOpacity: 0.025,
                                opacity: 0.18,
                                weight: 0.5
                            };
                        case 4: // 4 character -> 5 character
                            return {
                                fontSize: '12px',
                                padding: '3px 5px',
                                minWidth: '20px',
                                iconSize: [28, 18],
                                iconAnchor: [14, 9],
                                fillOpacity: 0.03,
                                opacity: 0.2,
                                weight: 0.4
                            };
                        case 5: // 5 character -> 6 character
                            return {
                                fontSize: '10px',
                                padding: '2px 4px',
                                minWidth: '18px',
                                iconSize: [24, 16],
                                iconAnchor: [12, 8],
                                fillOpacity: 0.035,
                                opacity: 0.22,
                                weight: 0.3
                            };
                        default:
                            return {
                                fontSize: '14px',
                                padding: '4px 8px',
                                minWidth: '28px',
                                iconSize: [36, 24],
                                iconAnchor: [18, 12],
                                fillOpacity: 0.04,
                                opacity: 0.25,
                                weight: 1
                            };
                    }
                };
                
                const style = getLevelStyle(level);
                
                // Generate subdivisions
                for (let i = 0; i < base32.length; i++) {
                    const char = base32[i];
                    const nextLevelGeohash = parentGeohash + char;
                    
                    // Calculate bounds for this subdivision
                    const subBounds = this.geohashToBounds(nextLevelGeohash);
                    if (!subBounds) continue;
                    
                    // Create rectangle for the subdivision
                    const rectangle = L.rectangle([
                        [subBounds.south, subBounds.west],
                        [subBounds.north, subBounds.east]
                    ], {
                        color: isDark ? '#58a6ff' : '#3498db',
                        fillColor: isDark ? '#58a6ff' : '#3498db',
                        fillOpacity: style.fillOpacity,
                        weight: style.weight,
                        opacity: style.opacity,
                        className: 'geohash-grid-cell'
                    });
                    
                    // Add click handler to filter by this geohash
                    rectangle.on('click', () => {
                        this.filterByGeohash(nextLevelGeohash);
                    });
                    
                    // Create text label for the geohash code
                    const centerLat = (subBounds.south + subBounds.north) / 2;
                    const centerLng = (subBounds.west + subBounds.east) / 2;
                    
                    // Show only the single character for this subdivision
                    const displayText = char.toLowerCase();
                    
                    const label = L.marker([centerLat, centerLng], {
                        icon: L.divIcon({
                            className: 'geohash-grid-label',
                            html: `<div style="
                                background: ${isDark ? 'rgba(88, 166, 255, 0.4)' : 'rgba(52, 152, 219, 0.4)'};
                                color: white;
                                font-weight: bold;
                                font-size: ${style.fontSize};
                                padding: ${style.padding};
                                border-radius: 6px;
                                text-align: center;
                                min-width: ${style.minWidth};
                                box-shadow: 0 2px 6px rgba(0,0,0,0.15);
                                cursor: pointer;
                                user-select: none;
                                border: 1px solid ${isDark ? 'rgba(88, 166, 255, 0.5)' : 'rgba(52, 152, 219, 0.5)'};
                            ">${displayText}</div>`,
                            iconSize: style.iconSize,
                            iconAnchor: style.iconAnchor
                        })
                    });
                    
                    // Add click handler to label
                    label.on('click', () => {
                        this.filterByGeohash(nextLevelGeohash);
                    });
                    
                    // Add to map
                    rectangle.addTo(this.map);
                    label.addTo(this.map);
                    
                    // Store references for cleanup
                    this.geohashGridRectangles = this.geohashGridRectangles || [];
                    this.geohashGridLabels = this.geohashGridLabels || [];
                    this.geohashGridRectangles.push(rectangle);
                    this.geohashGridLabels.push(label);
                }
                
                // Zoom to the parent geohash area with appropriate zoom level
                const maxZoom = Math.min(6 + level, 12); // Increase max zoom for deeper levels
                this.map.fitBounds([
                    [parentBounds.south, parentBounds.west],
                    [parentBounds.north, parentBounds.east]
                ], {
                    padding: [20, 20],
                    maxZoom: maxZoom
                });
            }

            geohashToLatLng(geohash) {
                try {
                    const base32 = "0123456789bcdefghjkmnpqrstuvwxyz";
                    let isEven = true;
                    let lat = [-90, 90];
                    let lng = [-180, 180];
                    
                    for (let i = 0; i < geohash.length; i++) {
                        const char = geohash[i];
                        const bits = base32.indexOf(char);
                        
                        for (let j = 4; j >= 0; j--) {
                            const bit = (bits >> j) & 1;
                            
                            if (isEven) {
                                const mid = (lng[0] + lng[1]) / 2;
                                if (bit) {
                                    lng[0] = mid;
                                } else {
                                    lng[1] = mid;
                                }
                            } else {
                                const mid = (lat[0] + lat[1]) / 2;
                                if (bit) {
                                    lat[0] = mid;
                                } else {
                                    lat[1] = mid;
                                }
                            }
                            
                            isEven = !isEven;
                        }
                    }
                    
                    return {
                        lat: (lat[0] + lat[1]) / 2,
                        lng: (lng[0] + lng[1]) / 2
                    };
                } catch (e) {
                    console.warn('Error decoding geohash:', geohash, e);
                    return null;
                }
            }

            geohashToBounds(geohash) {
                try {
                    const base32 = "0123456789bcdefghjkmnpqrstuvwxyz";
                    let isEven = true;
                    let lat = [-90, 90];
                    let lng = [-180, 180];
                    
                    for (let i = 0; i < geohash.length; i++) {
                        const char = geohash[i];
                        const bits = base32.indexOf(char);
                        
                        for (let j = 4; j >= 0; j--) {
                            const bit = (bits >> j) & 1;
                            
                            if (isEven) {
                                const mid = (lng[0] + lng[1]) / 2;
                                if (bit) {
                                    lng[0] = mid;
                                } else {
                                    lng[1] = mid;
                                }
                            } else {
                                const mid = (lat[0] + lat[1]) / 2;
                                if (bit) {
                                    lat[0] = mid;
                                } else {
                                    lat[1] = mid;
                                }
                            }
                            
                            isEven = !isEven;
                        }
                    }
                    
                    return {
                        north: lat[1],
                        south: lat[0],
                        east: lng[1],
                        west: lng[0]
                    };
                } catch (e) {
                    console.warn('Error calculating geohash bounds:', geohash, e);
                    return null;
                }
            }

            plotActivitiesOnMap(notes) {
                this.mapMarkers.forEach(marker => this.map.removeLayer(marker));
                this.mapMarkers = [];
                
                // Clear existing geohash rectangles
                this.geohashRectangles.forEach(rect => this.map.removeLayer(rect));
                this.geohashRectangles = [];
                
                const geoActivities = [];
                const filteredActivities = this.getFilteredActivities();
                
                // Collect unique geohashes from filtered notes
                const uniqueGeohashes = new Set();
                
                filteredActivities.forEach(note => {
                    const geo = this.extractGeoLocation(note);
                    if (geo) {
                        geoActivities.push({ note, geo });
                        // Found geo note
                        
                        // Extract geohash from tags
                        if (note.tags) {
                            note.tags.forEach(tag => {
                                if (tag[0] === 'g' && tag[1] && this.isGeohash(tag[1])) {
                                    uniqueGeohashes.add(tag[1]);
                                }
                            });
                        }
                    }
                });
                
                // Processed geo-location data
                
                // Plot geohash rectangles
                this.plotGeohashRectangles(Array.from(uniqueGeohashes));
                
                if (geoActivities.length === 0) {
                    return;
                }
                
                geoActivities.forEach(({ note, geo }, index) => {
                    const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
                    const marker = L.circleMarker([geo.lat, geo.lng], {
                        radius: 8,
                        fillColor: isDark ? '#58a6ff' : '#27ae60',
                        color: '#ffffff',
                        weight: 2,
                        opacity: 1,
                        fillOpacity: 0.8,
                        className: 'tripchat-marker'
                    });
                    
                    const noteType = this.getNoteType(note);
                    const profile = this.userProfiles[note.pubkey];
                    const username = this.formatUsernameWithDiscriminator(profile, note.pubkey);
                    
                    // Extract geohash from note tags for clickable link
                    let geohashLink = '';
                    if (note.tags) {
                        const geohashTag = note.tags.find(tag => tag[0] === 'g' && tag[1] && this.isGeohash(tag[1]));
                        if (geohashTag) {
                            geohashLink = `<div class="popup-location" style="cursor: pointer; color: #8B5CF6; font-weight: 600;" onclick="window.tripchatVisualizer.filterByGeohash('${geohashTag[1]}')">📍 #${geohashTag[1]}</div>`;
                        }
                    }
                    
                    if (!geohashLink) {
                        geohashLink = `<div class="popup-location">📍 ${geo.location}</div>`;
                    }
                    
                    const popupContent = `
                        <div class="map-popup">
                            <div class="note-title">${username}</div>
                            <div class="popup-content">${this.processContent(this.escapeHtml(note.content?.substring(0, 100) || 'No content'))}${note.content?.length > 100 ? '...' : ''}</div>
                            <div class="popup-time">${this.getRelativeTime(new Date(note.created_at * 1000))}</div>
                            ${geohashLink}
                        </div>
                    `;
                    
                    marker.bindPopup(popupContent);
                    marker.addTo(this.map);
                    this.mapMarkers.push(marker);
                });
                
                // Plotted geo-located notes on map
            }

            plotGeohashRectangles(geohashes) {
                const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
                geohashes.forEach(geohash => {
                    const bounds = this.geohashToBounds(geohash);
                    if (bounds) {
                        const rectangle = L.rectangle([
                            [bounds.south, bounds.west],
                            [bounds.north, bounds.east]
                        ], {
                            color: isDark ? '#58a6ff' : '#27ae60',
                            fillColor: isDark ? '#58a6ff' : '#27ae60',
                            fillOpacity: 0.1,
                            weight: 2,
                            opacity: 0.6,
                            className: 'geohash-rectangle'
                        });
                        
                        // Add popup with geohash info
                        const popupContent = `
                            <div class="map-popup">
                                <div class="note-title">Geohash Area</div>
                                <div class="popup-content"><strong>${geohash}</strong></div>
                                <div class="popup-location">
                                    Bounds: ${bounds.south.toFixed(4)}, ${bounds.west.toFixed(4)} to ${bounds.north.toFixed(4)}, ${bounds.east.toFixed(4)}
                                </div>
                            </div>
                        `;
                        
                        rectangle.bindPopup(popupContent);
                        rectangle.addTo(this.map);
                        this.geohashRectangles.push(rectangle);
                        
                        // Plotted geohash rectangle
                    }
                });
            }

            highlightGeohashArea(geohash) {
                // Clear existing geohash rectangles
                this.geohashRectangles.forEach(rect => this.map.removeLayer(rect));
                this.geohashRectangles = [];
                
                // Clear geohash grid when showing specific area
                this.clearGeohashGrid();
                
                const bounds = this.geohashToBounds(geohash);
                if (bounds) {
                    const rectangle = L.rectangle([
                        [bounds.south, bounds.west],
                        [bounds.north, bounds.east]
                    ], {
                        color: '#3498db',
                        fillColor: '#3498db',
                        fillOpacity: 0.2,
                        weight: 3,
                        opacity: 0.8,
                        className: 'geohash-highlight'
                    });
                    
                    // Add popup with geohash info
                    const popupContent = `
                        <div class="map-popup">
                            <div class="note-title">Filtered Geohash Area</div>
                            <div class="popup-content"><strong>${geohash}</strong></div>
                            <div class="popup-location">
                                Bounds: ${bounds.south.toFixed(4)}, ${bounds.west.toFixed(4)} to ${bounds.north.toFixed(4)}, ${bounds.east.toFixed(4)}
                            </div>
                        </div>
                    `;
                    
                    rectangle.bindPopup(popupContent);
                    rectangle.addTo(this.map);
                    this.geohashRectangles.push(rectangle);
                    
                    // Fit map to the geohash area
                    this.map.fitBounds([
                        [bounds.south, bounds.west],
                        [bounds.north, bounds.east]
                    ], { padding: [20, 20] });
                    
                    console.log(`Highlighted geohash area for ${geohash}:`, bounds);
                }
            }

            zoomToShowAllActivities() {
                // Clear any highlighted geohash rectangles
                this.geohashRectangles.forEach(rect => this.map.removeLayer(rect));
                this.geohashRectangles = [];
                
                // Get all notes with geo data
                const geoActivities = [];
                this.notes.forEach(note => {
                    const geo = this.extractGeoLocation(note);
                    if (geo) {
                        geoActivities.push([geo.lat, geo.lng]);
                    }
                });
                
                if (geoActivities.length > 0) {
                    // Create a group of all markers to get bounds
                    const group = new L.featureGroup();
                    geoActivities.forEach(coord => {
                        group.addLayer(L.marker(coord));
                    });
                    
                    // Fit the map to show all notes
                    this.map.fitBounds(group.getBounds().pad(0.1), { 
                        padding: [20, 20],
                        maxZoom: 10 // Don't zoom in too much when showing all notes
                    });
                    
                    console.log(`Zoomed to show all ${geoActivities.length} notes`);
                } else {
                    // If no geo notes, zoom to world view
                    this.map.setView([0, 0], 2);
                    console.log('No geo notes found, zoomed to world view');
                }
            }

            zoomToGlobal() {
                // Clear any highlighted geohash rectangles
                this.geohashRectangles.forEach(rect => this.map.removeLayer(rect));
                this.geohashRectangles = [];
                
                // Always zoom to global view regardless of notes
                if (this.map) {
                    // Use a small delay to ensure map is ready
                    setTimeout(() => {
                        this.map.setView([0, 0], 1);
                        console.log('Zoomed to global view - center: [0, 0], zoom: 1');
                    }, 100);
                } else {
                    console.error('Map not initialized when trying to zoom to global');
                }
            }

            filterByGeohash(geohash) {
                // Set the geohash filter
                this.geohashFilter = geohash.toLowerCase();
                const geohashFilterInput = document.getElementById('geohashFilter');
                if (geohashFilterInput) {
                    geohashFilterInput.value = geohash;
                }
                
                // Update URL hash
                this.updateHash();
                
                // Update display and map
                this.displayActivities(this.notes);
                this.plotActivitiesOnMap(this.notes);
                
                // Show next level if geohash is less than 6 characters
                if (geohash.length < 6) {
                    this.showNextLevelGeohashGrid(geohash);
                } else {
                    // For 6-character geohashes, just highlight the area
                    if (this.isGeohash(this.geohashFilter)) {
                        this.highlightGeohashArea(this.geohashFilter);
                    }
                }
                
                console.log(`Filtered by geohash: ${geohash}`);
            }

            // Compose functionality
            clearComposeForm() {
                document.getElementById('composeContent').value = '';
            }

            // Save keys to localStorage
            saveKeysToStorage(nsecKey, npubKey, privateKeyHex) {
                try {
                    localStorage.setItem('tripchat_nsec', nsecKey);
                    localStorage.setItem('tripchat_npub', npubKey);
                    localStorage.setItem('tripchat_private_key', privateKeyHex);
                    console.log('Keys saved to localStorage');
                } catch (error) {
                    console.error('Failed to save keys to localStorage:', error);
                }
            }

            // Load keys from localStorage
            loadKeysFromStorage() {
                try {
                    const nsecKey = localStorage.getItem('tripchat_nsec');
                    const npubKey = localStorage.getItem('tripchat_npub');
                    const privateKeyHex = localStorage.getItem('tripchat_private_key');
                    
                    // Check if we have nsec/npub keys (preferred)
                    if (nsecKey && npubKey) {
                        // Load keys into settings modal if elements exist
                        const settingsPrivateKey = document.getElementById('settingsPrivateKey');
                        const settingsPublicKey = document.getElementById('settingsPublicKey');
                        
                        if (settingsPrivateKey) {
                            settingsPrivateKey.value = nsecKey;
                        }
                        if (settingsPublicKey) {
                            settingsPublicKey.value = npubKey;
                        }
                        
                        // Use nsec key directly for signing
                        this.privateKey = nsecKey;
                        console.log('Keys loaded from localStorage (nsec/npub format)');
                        return true;
                    }
                    // Fallback to hex format
                    else if (nsecKey && npubKey && privateKeyHex) {
                        // Load keys into settings modal if elements exist
                        const settingsPrivateKey = document.getElementById('settingsPrivateKey');
                        const settingsPublicKey = document.getElementById('settingsPublicKey');
                        
                        if (settingsPrivateKey) {
                            settingsPrivateKey.value = nsecKey;
                        }
                        if (settingsPublicKey) {
                            settingsPublicKey.value = npubKey;
                        }
                        
                        this.privateKey = privateKeyHex;
                        console.log('Keys loaded from localStorage (hex format)');
                        return true;
                    }
                } catch (error) {
                    console.error('Failed to load keys from localStorage:', error);
                }
                return false;
            }

            // Clear keys from localStorage
            clearKeysFromStorage() {
                try {
                    localStorage.removeItem('tripchat_nsec');
                    localStorage.removeItem('tripchat_npub');
                    localStorage.removeItem('tripchat_private_key');
                    console.log('Keys cleared from localStorage');

                    const settingsPrivateKey = document.getElementById('settingsPrivateKey');
                    const settingsPublicKey = document.getElementById('settingsPublicKey');
                    if (settingsPrivateKey) {
                        settingsPrivateKey.value = '';
                    }
                    if (settingsPublicKey) {
                        settingsPublicKey.value = '';
                    }

                    const settingsPrivateKeyHint = document.getElementById('settingsPrivateKeyHint');
                    if (settingsPrivateKeyHint) {
                        settingsPrivateKeyHint.style.display = 'none';
                        settingsPrivateKeyHint.innerHTML = '';
                    }

                    const verificationStatus = document.getElementById('verificationStatus');
                    if (verificationStatus) {
                        verificationStatus.textContent = 'Add or generate keys to verify your Trustroots username.';
                        verificationStatus.style.color = '#6c757d';
                    }

                    this.updateKeySetupPrompt();
                    this.toggleKeyButtonsVisibility();
                    this.highlightKeyInputs();
                } catch (error) {
                    console.error('Failed to clear keys from localStorage:', error);
                }
            }


            async getCurrentLocation() {
                if (!navigator.geolocation) {
                    alert('Geolocation is not supported by this browser.');
                    return;
                }

                try {
                    const position = await new Promise((resolve, reject) => {
                        navigator.geolocation.getCurrentPosition(resolve, reject);
                    });

                    const lat = position.coords.latitude;
                    const lng = position.coords.longitude;
                    const geohash = ngeohash.encode(lat, lng, 6); // 6 character precision
                    
                    document.getElementById('composeLocation').value = geohash;
                    console.log(`Location detected: ${lat}, ${lng} -> ${geohash}`);
                } catch (error) {
                    console.error('Error getting location:', error);
                    alert('Could not get your location. Please enter it manually.');
                }
            }


            generateFallbackKey() {
                // Simple fallback key generation using crypto.getRandomValues
                const array = new Uint8Array(32);
                crypto.getRandomValues(array);
                return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
            }

            generateKeyPair() {
                try {
                    // Check if nostr-tools is available
                    if (typeof window.nostrTools === 'undefined') {
                        throw new Error('nostr-tools library not loaded');
                    }

                    // Generate a new private key using nostr-tools
                    const privateKey = window.nostrTools.generatePrivateKey();
                    const publicKey = window.nostrTools.getPublicKey(privateKey);
                    
                    // Convert to nsec and npub formats
                    const nsecKey = window.nostrTools.nip19.nsecEncode(privateKey);
                    const npubKey = window.nostrTools.nip19.npubEncode(publicKey);
                    
                    return { nsecKey, npubKey };
                } catch (error) {
                    console.error('Error generating key pair:', error);
                    // Fallback to simple key generation
                    try {
                        const privateKeyHex = this.generateFallbackKey();
                        const nsecKey = this.hexToNsec(privateKeyHex);
                        const npubKey = this.deriveNpubFromPrivateKey(privateKeyHex);
                        return { nsecKey, npubKey };
                    } catch (fallbackError) {
                        console.error('Fallback key generation failed:', fallbackError);
                        throw new Error('Failed to generate keys. Please try again.');
                    }
                }
            }

            // Derive hex public key from private key
            deriveHexPubkeyFromPrivateKey(privateKey) {
                if (typeof window.nostrTools !== 'undefined') {
                    try {
                        // Convert nsec to hex if needed
                        let hexPrivateKey = privateKey;
                        if (privateKey.startsWith('nsec')) {
                            hexPrivateKey = window.nostrTools.nip19.nsecDecode(privateKey);
                        }
                        
                        // Get public key from private key
                        const publicKey = window.nostrTools.getPublicKey(hexPrivateKey);
                        return publicKey;
                    } catch (error) {
                        console.error('Error deriving hex public key:', error);
                        // Fallback to simple hash
                        return this.simpleHash(privateKey).substring(0, 64);
                    }
                } else {
                    // Fallback method
                    return this.simpleHash(privateKey).substring(0, 64);
                }
            }

            deriveNpubFromPrivateKey(privateKeyHex) {
                try {
                    // Check if nostr-tools is available
                    if (typeof window.nostrTools !== 'undefined') {
                        const publicKey = window.nostrTools.getPublicKey(privateKeyHex);
                        return window.nostrTools.nip19.npubEncode(publicKey);
                    } else {
                        // Fallback: simple npub generation
                        return this.generateNpubFallback(privateKeyHex);
                    }
                } catch (error) {
                    console.error('Error deriving npub:', error);
                    // Fallback to simple method
                    return this.generateNpubFallback(privateKeyHex);
                }
            }

            getCurrentUserPubkey() {
                if (!this.privateKey) {
                    return null;
                }
                
                try {
                    let privateKeyHex;
                    
                    // Check if it's already hex format (64 characters)
                    if (this.privateKey.length === 64 && /^[0-9a-fA-F]+$/.test(this.privateKey)) {
                        privateKeyHex = this.privateKey;
                    } else if (this.privateKey.startsWith('nsec')) {
                        // Convert nsec to hex
                        privateKeyHex = this.nsecToHex(this.privateKey);
                    } else {
                        console.warn('Unknown private key format:', this.privateKey.substring(0, 10) + '...');
                        return null;
                    }
                    
                    return this.deriveNpubFromPrivateKey(privateKeyHex);
                } catch (error) {
                    console.error('Error getting current user pubkey:', error);
                    return null;
                }
            }

            isNoteByCurrentUser(note) {
                if (!this.privateKey) {
                    return false;
                }
                
                try {
                    const currentUserPubkey = this.getCurrentUserPubkey();
                    if (!currentUserPubkey) {
                        return false;
                    }
                    
                    // Convert npub to hex for comparison
                    const currentUserHex = this.npubToHex(currentUserPubkey);
                    if (!currentUserHex) {
                        return false;
                    }
                    
                    return note.pubkey === currentUserHex;
                } catch (error) {
                    console.error('Error comparing pubkeys:', error);
                    return false;
                }
            }

            npubToHex(npub) {
                try {
                    if (typeof window.nostrTools !== 'undefined') {
                        const decoded = window.nostrTools.nip19.decode(npub);
                        return decoded.data;
                    } else {
                        // Fallback: try to extract hex from npub format
                        console.warn('nostr-tools not available, using fallback npub decoding');
                        return this.simpleNpubDecode(npub);
                    }
                } catch (error) {
                    console.error('Error converting npub to hex:', error);
                    return null;
                }
            }

            simpleNpubDecode(npub) {
                // This is a very basic fallback - in production, use a proper base58 decoder
                try {
                    // For now, we'll use a simple approach that might work for testing
                    // In practice, you'd need a proper base58 decoder library
                    console.warn('Using fallback npub decoding - may not work correctly');
                    return null; // Return null to indicate we can't decode it properly
                } catch (error) {
                    console.error('Error in simple npub decode:', error);
                    return null;
                }
            }

            async signEvent(event) {
                try {
                    if (typeof window.nostrTools !== 'undefined') {
                        // Convert nsec to hex if needed
                        let privateKeyHex = this.privateKey;
                        if (this.privateKey.startsWith('nsec')) {
                            privateKeyHex = this.nsecToHex(this.privateKey);
                        }
                        return window.nostrTools.finishEvent(event, privateKeyHex);
                    } else {
                        throw new Error('nostr-tools not available');
                    }
                } catch (error) {
                    console.error('Error signing event:', error);
                    throw error;
                }
            }

            async deleteNote(noteId) {
                if (!this.privateKey) {
                    alert('No private key available. Please set up your keys first.');
                    return;
                }

                if (!confirm('Are you sure you want to delete this note? This action cannot be undone.')) {
                    return;
                }

                // Find and update the delete button to show loading state
                const deleteButton = document.querySelector(`[data-note-id="${noteId}"].note-delete-btn`);
                if (deleteButton) {
                    deleteButton.disabled = true;
                    deleteButton.classList.add('deleting');
                    deleteButton.textContent = '⏳ DELETING...';
                    deleteButton.title = 'Deleting note...';
                }

                try {
                    // Create a kind 5 deletion event
                    const deletionEvent = {
                        kind: 5,
                        content: 'Deleted by user',
                        tags: [['e', noteId]],
                        created_at: Math.floor(Date.now() / 1000)
                    };

                    // Sign the event
                    const signedEvent = await this.signEvent(deletionEvent);
                    
                    if (!signedEvent) {
                        throw new Error('Failed to sign deletion event');
                    }

                    // Send to all enabled relays
                    const postingRelays = Object.keys(this.postingRelays).filter(url => this.postingRelays[url]);
                    console.log('Sending deletion to relays:', postingRelays);
                    
                    // Update button to show progress
                    if (deleteButton) {
                        deleteButton.textContent = `⏳ SENDING TO ${postingRelays.length} RELAYS...`;
                    }
                    
                    const relayPromises = postingRelays.map(async (relayUrl, index) => {
                        try {
                            console.log(`Sending deletion to ${relayUrl}`);
                            
                            // Update progress
                            if (deleteButton) {
                                deleteButton.textContent = `⏳ SENDING TO RELAY ${index + 1}/${postingRelays.length}...`;
                            }
                            
                            const result = await this.postEventToRelay(relayUrl, signedEvent);
                            console.log(`Deletion sent successfully to ${relayUrl}`);
                            return result;
                        } catch (error) {
                            console.log(`Deletion failed for ${relayUrl}:`, error.message);
                            // For deletion events, we'll consider it successful if we sent it
                            // even if we don't get a proper OK response
                            return true;
                        }
                    });

                    const results = await Promise.allSettled(relayPromises);
                    const successCount = results.filter(r => r.status === 'fulfilled' && r.value === true).length;
                    
                    console.log('Deletion results:', results);
                    console.log('Success count:', successCount);

                    // Update button to show completion
                    if (deleteButton) {
                        deleteButton.textContent = '✅ DELETED!';
                        deleteButton.classList.remove('deleting');
                        deleteButton.classList.add('deleted');
                    }
                    
                    // Brief delay to show success state
                    setTimeout(() => {
                        // Always proceed with local deletion since the event was sent
                        // Remove from local notes array
                        this.notes = this.notes.filter(note => note.id !== noteId);
                        
                        // Remove from map immediately
                        this.removeNoteFromMap(noteId);
                        
                        // Re-render the display
                        this.displayActivities(this.notes);
                        this.plotActivitiesOnMap(this.notes);
                        
                        // Show success message
                        this.showDeletionSuccess(postingRelays.length);
                    }, 500);

                } catch (error) {
                    console.error('Error deleting note:', error);
                    
                    // Reset button state on error
                    if (deleteButton) {
                        deleteButton.disabled = false;
                        deleteButton.classList.remove('deleting');
                        deleteButton.textContent = '🗑️ DELETE';
                        deleteButton.title = 'Delete this note';
                    }
                    
                    alert('Failed to delete note: ' + error.message);
                }
            }

            replyToNote(noteId, npub) {
                // Check if user has keys set up
                if (!this.privateKey) {
                    alert('No private key available. Please set up your keys first.');
                    return;
                }

                // Find the original note to get its content and tags
                const originalNote = this.notes.find(note => note.id === noteId);
                if (!originalNote) {
                    alert('Original note not found.');
                    return;
                }

                // Get the username for the mention
                const profile = this.userProfiles[npub];
                const username = this.formatUsernameWithDiscriminator(profile, npub);
                
                // Show reply context display
                const replyContextDisplay = document.getElementById('replyContextDisplay');
                const replyTargetUsername = document.getElementById('replyTargetUsername');
                if (replyContextDisplay && replyTargetUsername) {
                    replyTargetUsername.innerHTML = username;
                    replyContextDisplay.style.display = 'block';
                }
                
                // Create the reply content with both npub and NIP-27 mention format
                const mention = `nostr:${npub}`;
                const npubFormatted = this.hexToNpub(npub);
                const replyContent = `${npubFormatted} ${mention} `;
                
                console.log('Reply content:', replyContent);
                console.log('NPUB formatted:', npubFormatted);
                console.log('Original npub (hex):', npub);
                
                // Pre-fill the compose form
                const composeTextarea = document.getElementById('composeText');
                if (composeTextarea) {
                    composeTextarea.value = replyContent;
                    composeTextarea.focus();
                    
                    // Position cursor after the mention
                    const cursorPosition = replyContent.length;
                    composeTextarea.setSelectionRange(cursorPosition, cursorPosition);
                    
                    // Scroll to compose section
                    composeTextarea.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }

                // Store reply context for when the note is posted
                this.replyContext = {
                    originalNoteId: noteId,
                    originalNpub: npub,
                    originalRelay: originalNote.relay || 'wss://relay.trustroots.org' // Default relay
                };

                console.log('Reply context set:', this.replyContext);
                
                // Add clear reply context button handler
                const clearReplyContextBtn = document.getElementById('clearReplyContext');
                if (clearReplyContextBtn) {
                    clearReplyContextBtn.addEventListener('click', () => {
                        this.clearReplyContext();
                    });
                }
            }
            
            clearReplyContext() {
                // Clear reply context
                this.replyContext = null;
                
                // Hide reply context display
                const replyContextDisplay = document.getElementById('replyContextDisplay');
                if (replyContextDisplay) {
                    replyContextDisplay.style.display = 'none';
                }
                
                // Clear the compose textarea
                const composeTextarea = document.getElementById('composeText');
                if (composeTextarea) {
                    composeTextarea.value = '';
                }
                
                console.log('Reply context cleared');
            }

            removeNoteFromMap(noteId) {
                // Find and remove the specific marker for this note
                const markerToRemove = this.mapMarkers.find(marker => {
                    const popup = marker.getPopup();
                    if (popup) {
                        const popupContent = popup.getContent();
                        return popupContent && popupContent.includes(`data-note-id="${noteId}"`);
                    }
                    return false;
                });

                if (markerToRemove && this.map) {
                    this.map.removeLayer(markerToRemove);
                    const index = this.mapMarkers.indexOf(markerToRemove);
                    if (index > -1) {
                        this.mapMarkers.splice(index, 1);
                    }
                }
            }

            showDeletionSuccess(successCount) {
                // Create a temporary success message
                const successDiv = document.createElement('div');
                successDiv.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: #22c55e;
                    color: white;
                    padding: 12px 20px;
                    border-radius: 8px;
                    font-family: 'JetBrains Mono', 'Fira Code', monospace;
                    font-size: 0.9rem;
                    font-weight: 600;
                    z-index: 10000;
                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                    animation: slideInRight 0.3s ease-out;
                `;
                successDiv.textContent = `✅ Note deleted from ${successCount} relay(s)`;
                
                document.body.appendChild(successDiv);
                
                // Remove after 3 seconds
                setTimeout(() => {
                    if (successDiv.parentNode) {
                        successDiv.style.animation = 'slideOutRight 0.3s ease-in';
                        setTimeout(() => {
                            if (successDiv.parentNode) {
                                successDiv.parentNode.removeChild(successDiv);
                            }
                        }, 300);
                    }
                }, 3000);
            }


            async updateTrustrootsProfile(npub) {
                try {
                    // Based on nostroots project research, try Trustroots API endpoints
                    const endpoints = [
                        'https://trustroots.org/api/v1/users/me',
                        'https://trustroots.org/api/users/me',
                        'https://trustroots.org/api/profile',
                        'https://trustroots.org/api/user/profile',
                        'https://api.trustroots.org/v1/users/me',
                        'https://api.trustroots.org/users/me'
                    ];

                    // Get saved username if available
                    const savedUsername = localStorage.getItem('tripchat_trustroots_username');
                    
                    const profileData = {
                        publicKey: npub,
                        nostr: npub,
                        npub: npub,
                        nostrPublicKey: npub,
                        // Include other common profile fields
                        updatedAt: new Date().toISOString(),
                        source: 'tripchat'
                    };
                    
                    // Add username if available
                    if (savedUsername) {
                        profileData.username = savedUsername;
                        profileData.displayName = savedUsername;
                    }

                    // Try each endpoint
                    for (const endpoint of endpoints) {
                        try {
                            console.log(`Trying to update profile via ${endpoint}`);
                            
                            const response = await fetch(endpoint, {
                                method: 'PUT',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'Accept': 'application/json',
                                    // Add common authentication headers
                                    'X-Requested-With': 'XMLHttpRequest'
                                },
                                body: JSON.stringify(profileData),
                                mode: 'cors'
                            });

                            if (response.ok) {
                                console.log(`Successfully updated profile via ${endpoint}`);
                                return true;
                            } else if (response.status === 401) {
                                console.log(`Authentication required for ${endpoint}`);
                                // Continue to next endpoint
                            } else if (response.status === 404) {
                                console.log(`Endpoint not found: ${endpoint}`);
                                // Continue to next endpoint
                            } else {
                                console.log(`Failed to update via ${endpoint}: ${response.status}`);
                            }
                        } catch (endpointError) {
                            console.log(`Error with endpoint ${endpoint}:`, endpointError.message);
                            // Continue to next endpoint
                        }
                    }

                    // If all endpoints failed, try a POST request as fallback
                    for (const endpoint of endpoints) {
                        try {
                            const response = await fetch(endpoint, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'Accept': 'application/json',
                                    'X-Requested-With': 'XMLHttpRequest'
                                },
                                body: JSON.stringify(profileData),
                                mode: 'cors'
                            });

                            if (response.ok) {
                                console.log(`Successfully updated profile via POST to ${endpoint}`);
                                return true;
                            }
                        } catch (postError) {
                            console.log(`POST failed for ${endpoint}:`, postError.message);
                        }
                    }

                    console.log('All Trustroots API endpoints failed');
                    
                    // Fallback: Open Trustroots profile edit page for manual update
                    // This is similar to what the nostroots project does
                    const profileEditUrl = savedUsername ? 
                        `https://trustroots.org/${savedUsername}/edit/networks` : 
                        'https://trustroots.org/profile/edit/networks';
                    
                    const usernameInfo = savedUsername ? `\nYour Trustroots username: ${savedUsername}` : '';
                    const confirmManual = confirm(
                        'Automatic profile update failed. Would you like to open your Trustroots profile edit page to manually add your npub?\n\n' +
                        `Your npub: ${npub}${usernameInfo}\n\n` +
                        'Click OK to open the profile edit page, then paste your npub in the appropriate field.'
                    );
                    
                    if (confirmManual) {
                        window.open(profileEditUrl, '_blank');
                        return false; // Indicate manual update needed
                    }
                    
                    return false;

                } catch (error) {
                    console.error('Error updating Trustroots profile:', error);
                    return false;
                }
            }

            // Convert hex private key to nsec format
            hexToNsec(hexKey) {
                // Remove '0x' prefix if present
                const cleanHex = hexKey.replace(/^0x/, '');
                
                // Convert hex to bytes
                const bytes = new Uint8Array(cleanHex.length / 2);
                for (let i = 0; i < cleanHex.length; i += 2) {
                    bytes[i / 2] = parseInt(cleanHex.substr(i, 2), 16);
                }
                
                // Use a simple base32-like encoding for now
                // This is not proper bech32 but will work for display purposes
                const base32Chars = 'abcdefghijklmnopqrstuvwxyz234567';
                let result = 'nsec1';
                
                for (let i = 0; i < bytes.length; i += 5) {
                    let value = 0;
                    for (let j = 0; j < 5 && i + j < bytes.length; j++) {
                        value = (value << 8) | bytes[i + j];
                    }
                    
                    for (let k = 0; k < 8; k++) {
                        result += base32Chars[(value >> (35 - k * 5)) & 31];
                    }
                }
                
                return result;
            }

            // Convert nsec format back to hex
            nsecToHex(nsecKey) {
                try {
                    // Use nostr-tools if available
                    if (typeof window.nostrTools !== 'undefined') {
                        // Use nip19 for bech32 decoding
                        const decoded = window.nostrTools.nip19.decode(nsecKey);
                        if (decoded.type === 'nsec') {
                            return decoded.data;
                        } else {
                            throw new Error('Invalid nsec format');
                        }
                    }
                    
                    // Fallback method
                    if (nsecKey.startsWith('nsec1')) {
                        // For now, just remove the prefix and assume it's hex
                        // In a real implementation, you'd decode the base32 properly
                        return nsecKey.substring(5);
                    } else if (nsecKey.length === 64) {
                        // If it's 64 characters, assume it's already hex
                        return nsecKey;
                    } else {
                        throw new Error('Invalid nsec format');
                    }
                } catch (error) {
                    console.error('Error converting nsec to hex:', error);
                    throw new Error('Invalid nsec format');
                }
            }

            // Generate npub from private key
            async generateNpub(privateKeyHex) {
                try {
                    // Use nostr-tools if available
                    if (typeof window.nostrTools !== 'undefined') {
                        const publicKey = window.nostrTools.getPublicKey(privateKeyHex);
                        
                        // Use nip19 for npub encoding
                        return window.nostrTools.nip19.npubEncode(publicKey);
                    }
                    
                    // Fallback method
                    console.log('nostr-tools not available, using fallback method');
                    return this.generateNpubFallback(privateKeyHex);
                } catch (error) {
                    console.error('Error generating npub:', error);
                    console.log('Falling back to simple method');
                    return this.generateNpubFallback(privateKeyHex);
                }
            }

            // Fallback npub generation (simplified)
            generateNpubFallback(privateKeyHex) {
                // Create a deterministic but fake public key from the private key
                // This is not cryptographically correct but looks realistic
                const hash = this.simpleHash(privateKeyHex);
                const publicKeyHex = hash.substring(0, 64);
                return this.hexToNpub(publicKeyHex);
            }

            // Simple hash function for generating fake public keys
            simpleHash(input) {
                let hash = '';
                for (let i = 0; i < input.length; i++) {
                    const char = input.charCodeAt(i);
                    hash += ((char * 31) % 16).toString(16);
                }
                // Pad to 64 characters
                while (hash.length < 64) {
                    hash += ((hash.length * 7) % 16).toString(16);
                }
                return hash.substring(0, 64);
            }

            // Generate a short discriminator from pubkey
            generateDiscriminator(pubkey) {
                if (!pubkey) return '';
                
                // Take the last 4 characters of the pubkey and convert to a shorter format
                const lastFour = pubkey.slice(-4);
                
                // Convert hex to a more readable format (0-9, a-f -> 0-9, a-z)
                let discriminator = '';
                for (let i = 0; i < lastFour.length; i += 2) {
                    const hexPair = lastFour.substr(i, 2);
                    const num = parseInt(hexPair, 16);
                    // Map to a smaller character set (0-9, a-z)
                    discriminator += (num % 36).toString(36);
                }
                
                return discriminator;
            }

            // Format username with discriminator
            // Discriminators (#p6, #a1, etc.) are used by some Nostr clients to handle username conflicts
            // NIP-05 names are prioritized as they are cryptographically verified and more stable
            formatUsernameWithDiscriminator(profile, pubkey) {
                let username;
                
                // Priority 1: Use NIP-05 name if available (most trustworthy)
                if (profile && profile.nip05) {
                    const isTrustrootsVerified = profile.nip05.endsWith('@trustroots.org');
                    const isHitchwikiVerified = profile.nip05.endsWith('@hitchwiki.org');
                    const fullNpub = this.hexToNpub(pubkey);
                    
                    if (isTrustrootsVerified) {
                        const usernamePart = profile.nip05.split('@')[0];
                        username = `<a href="https://trustroots.org/profile/${usernamePart}" target="_blank" rel="noopener noreferrer" title="${fullNpub}">@${profile.nip05} 🟢</a>`;
                    } else if (isHitchwikiVerified) {
                        const usernamePart = profile.nip05.split('@')[0];
                        const hitchwikiUrl = profile.website && profile.website.includes('hitchwiki.org') 
                            ? profile.website 
                            : `https://hitchwiki.org/en/User:${usernamePart}`;
                        username = `<a href="${hitchwikiUrl}" target="_blank" rel="noopener noreferrer" title="${fullNpub}">@${profile.nip05} 🟢</a>`;
                    } else if (profile.nip05.includes('@')) {
                        username = `<span title="${fullNpub}">@${profile.nip05} 🔵</span>`;
                    } else {
                        // Fallback to profile name if NIP-05 exists but is malformed
                        username = profile.name || 'Unknown';
                    }
                }
                // Priority 2: Use profile name with discriminator if no NIP-05
                else if (profile && profile.name) {
                    // Check if the name already has a discriminator
                    if (profile.name.includes('#')) {
                        username = profile.name;
                    } else {
                        // Add discriminator if it doesn't exist
                        const discriminator = this.generateDiscriminator(pubkey);
                        username = `${profile.name}#${discriminator}`;
                    }
                }
                // Priority 3: Fallback to npub
                else {
                    // Show first 10 characters of npub without @
                    username = pubkey ? this.hexToNpub(pubkey).substring(0, 10) : 'Unknown';
                }
                
                return username;
            }

            // Convert hex public key to npub format
            hexToNpub(hexKey) {
                try {
                    // Use nostr-tools if available
                    if (typeof window.nostrTools !== 'undefined' && window.nostrTools.nip19 && window.nostrTools.nip19.npubEncode) {
                        return window.nostrTools.nip19.npubEncode(hexKey);
                    }
                    
                    // Fallback: create a proper-looking npub format
                    const cleanHex = hexKey.replace(/^0x/, '');
                    
                    // Create a more realistic npub format
                    // This is not cryptographically correct but looks like a real npub
                    const base32Chars = 'abcdefghijklmnopqrstuvwxyz234567';
                    let result = 'npub1';
                    
                    // Convert hex to bytes
                    const bytes = [];
                    for (let i = 0; i < cleanHex.length; i += 2) {
                        bytes.push(parseInt(cleanHex.substr(i, 2), 16));
                    }
                    
                    // Simple base32 encoding
                    let bits = 0;
                    let value = 0;
                    for (let i = 0; i < bytes.length; i++) {
                        value = (value << 8) | bytes[i];
                        bits += 8;
                        
                        while (bits >= 5) {
                            result += base32Chars[(value >> (bits - 5)) & 31];
                            bits -= 5;
                        }
                    }
                    
                    if (bits > 0) {
                        result += base32Chars[(value << (5 - bits)) & 31];
                    }
                    
                    return result;
                    
                } catch (error) {
                    console.error('Error converting hex to npub:', error);
                    // Even simpler fallback
                    const cleanHex = hexKey.replace(/^0x/, '');
                    return `npub1${cleanHex.substring(0, 8)}...${cleanHex.substring(cleanHex.length - 8)}`;
                }
            }


            async postNote() {
                console.log('🚀 Starting postNote process...');
                
                const content = document.getElementById('composeContent').value.trim();
                const geohash = document.getElementById('geohashFilter').value.trim();
                const privateKeyInput = localStorage.getItem('tripchat_nsec');
                const publicKeyInput = localStorage.getItem('tripchat_npub');

                console.log('📝 Post data:', { 
                    content: content.substring(0, 50) + (content.length > 50 ? '...' : ''),
                    geohash: geohash || 'none',
                    hasPrivateKey: !!privateKeyInput,
                    hasPublicKey: !!publicKeyInput
                });

                if (!content) {
                    console.log('❌ No content provided');
                    alert('Please enter a message.');
                    return;
                }

                // Check for private key exposure
                const nsecPattern = /nsec[a-z0-9]+/gi;
                const privateKeyPattern = /[a-f0-9]{32,}/gi;
                
                if (nsecPattern.test(content) || privateKeyPattern.test(content)) {
                    console.log('🚨 Private key detected in content!');
                    alert('🚨 SECURITY WARNING 🚨\n\nYou are about to post what appears to be a private key (nsec) or private key hex!\n\nNEVER post private keys publicly - anyone who sees this can use your account!\n\nPlease remove any private key information from your message before posting.');
                    return;
                }

                // Extract hashtags from searchFilter and add them to content
                let finalContent = content;
                if (this.searchFilter) {
                    console.log('🔍 Processing search filter for hashtags:', this.searchFilter);
                    const hashtagRegex = /#\w+/g;
                    const hashtags = this.searchFilter.match(hashtagRegex);
                    if (hashtags && hashtags.length > 0) {
                        console.log('🏷️ Found hashtags in search filter:', hashtags);
                        // Add hashtags to content if they're not already there
                        const existingHashtags = content.match(hashtagRegex) || [];
                        const newHashtags = hashtags.filter(tag => !existingHashtags.includes(tag));
                        if (newHashtags.length > 0) {
                            finalContent = content + ' ' + newHashtags.join(' ');
                            console.log(`✅ Added hashtags from search filter: ${newHashtags.join(' ')}`);
                        } else {
                            console.log('ℹ️ All hashtags already present in content');
                        }
                    }
                }

                // Geohash is optional - allow global posting
                // if (!geohash) {
                //     alert('Please enter a location (geohash).');
                //     return;
                // }

                if (!privateKeyInput || !publicKeyInput) {
                    console.log('❌ Missing keys for posting', {
                        hasPrivateKey: !!privateKeyInput,
                        hasPublicKey: !!publicKeyInput
                    });
                    this.openKeysDialog("Let's help you set up some keys before you post your note.");
                    return;
                }

                try {
                    console.log('🔐 Processing private key...');
                    // Convert nsec to hex if needed
                    if (privateKeyInput.startsWith('nsec')) {
                        this.privateKey = this.nsecToHex(privateKeyInput);
                        console.log('🔑 Converted nsec to hex private key');
                    } else {
                        this.privateKey = privateKeyInput;
                        console.log('🔑 Using hex private key directly');
                    }
                    
                    // Get current persistence selection
                    const currentPersistence = document.getElementById('notePersistence')?.value;
                    console.log('⏰ Persistence setting:', currentPersistence);
                    
                    console.log('📦 Creating event with:', {
                        content: finalContent.substring(0, 50) + (finalContent.length > 50 ? '...' : ''),
                        geohash: geohash || 'none',
                        persistence: currentPersistence
                    });
                    
                    const event = await this.createBitchatEvent(finalContent, geohash, currentPersistence);
                    console.log('✅ Event created successfully:', event.id);
                    
                    console.log('📡 Publishing event to relays...');
                    await this.publishEvent(event);
                    console.log('✅ Event published successfully');
                    
                    // Auto-scroll to show the new post
                    console.log('📜 Auto-scrolling to show new post...');
                    setTimeout(() => {
                        this.scrollToBottom();
                    }, 500);
                    
                    // Clear the compose form after successful post
                    console.log('🧹 Clearing compose form...');
                    this.clearComposeForm();
                    console.log('🎉 Post completed successfully!');
                } catch (error) {
                    console.error('❌ Error posting note:', error);
                    console.error('Error details:', {
                        message: error.message,
                        stack: error.stack,
                        name: error.name
                    });
                    alert('Error posting note: ' + error.message);
                }
            }

            async createBitchatEvent(content, geohash, persistence = '1h') {
                if (!this.privateKey) {
                    throw new Error('No private key available');
                }

                const persistenceElement = document.getElementById('notePersistence');
                const persistenceOption = persistence || (persistenceElement ? persistenceElement.value : '1h');
                
                console.log('Creating Kind 1 event with persistence option:', persistenceOption);
                console.log('Selected persistence element value:', persistenceElement ? persistenceElement.value : 'element not found');
                console.log('Available options:', persistenceElement ? Array.from(persistenceElement.options).map(opt => `${opt.value}: ${opt.text}`) : 'element not found');
                
                // Always create Kind 1 events with expiration
                return this.createPersistentEvent(content, geohash, persistenceOption);
            }

            // New method for ephemeral events (current behavior)
            async createEphemeralEvent(content, geohash) {
                if (!this.privateKey) {
                    throw new Error('No private key available');
                }

                try {
                    // Get npub for NIP-05 verification
                    const npub = this.deriveNpubFromPrivateKey(this.privateKey);
                    
                    // Check for NIP-05 verification with caching
                    const savedUsername = localStorage.getItem('tripchat_trustroots_username');
                    let nip05Verified = false;
                    
                    if (savedUsername) {
                        // Check cache first
                        const cacheKey = `nip05_${savedUsername}`;
                        const cached = localStorage.getItem(cacheKey);
                        const cacheTime = localStorage.getItem(`${cacheKey}_time`);
                        const now = Date.now();
                        
                        // Use cache if less than 5 minutes old
                        if (cached && cacheTime && (now - parseInt(cacheTime)) < 300000) {
                            nip05Verified = cached === 'true';
                        } else {
                            try {
                                const verificationUrl = `https://trustroots.org/.well-known/nostr.json?name=${savedUsername}`;
                                const response = await fetch(verificationUrl, {
                                    method: 'GET',
                                    headers: {
                                        'Accept': 'application/json',
                                        'Cache-Control': 'no-cache'
                                    }
                                });
                                
                                if (response.ok) {
                                    const data = await response.json();
                                    
                                    if (data.names && data.names[savedUsername]) {
                                        const hexPubkey = data.names[savedUsername];
                                        let expectedNpub;
                                        
                                        if (typeof window.nostrTools !== 'undefined') {
                                            expectedNpub = window.nostrTools.nip19.npubEncode(hexPubkey);
                                        } else {
                                            expectedNpub = this.hexToNpub(hexPubkey);
                                        }
                                        
                                        nip05Verified = (expectedNpub === npub);
                                        
                                        // Cache the result
                                        localStorage.setItem(cacheKey, nip05Verified.toString());
                                        localStorage.setItem(`${cacheKey}_time`, now.toString());
                                    }
                                }
                            } catch (error) {
                                console.log('NIP-05 verification failed:', error);
                                // Use cached result if available, even if expired
                                if (cached) {
                                    nip05Verified = cached === 'true';
                                }
                            }
                        }
                    }
                    
                    // Use nostr-tools if available
                    if (typeof window.nostrTools !== 'undefined') {
                        const event = {
                            kind: 20000, // Ephemeral event for location channels
                            content: content,
                            tags: [
                                ['d', 'bitchat-location'], // Distinguishes from other location events
                                ['p', npub] // Add public key tag
                            ],
                            created_at: Math.floor(Date.now() / 1000)
                        };
                        
                        // Add geohash tag only if geohash is provided
                        if (geohash && geohash.trim()) {
                            event.tags.push(['g', geohash]);
                        }
                        
                        // Add NIP-05 verification tag if verified
                        if (nip05Verified) {
                            event.tags.push(['nip05', `${savedUsername}@trustroots.org`]);
                        }

                        console.log('🏷️ Event tags (main):', event.tags);
                        
                        // Sign the event using nostr-tools
                        const signedEvent = window.nostrTools.finishEvent(event, this.privateKey);
                        return signedEvent;
                    }
                    
                    // Fallback method
                    console.log('nostr-tools not available, using fallback method');
                    const event = {
                        kind: 20000, // Ephemeral event for location channels
                        content: content,
                        tags: [
                            ['d', 'bitchat-location'], // Distinguishes from other location events
                            ['p', npub] // Add public key tag
                        ],
                        pubkey: this.generateFakePublicKey(this.privateKey),
                        created_at: Math.floor(Date.now() / 1000),
                        id: this.generateFakeEventId(content, geohash || 'global'),
                        sig: this.generateFakeSignature(this.privateKey, content)
                    };
                    
                    // Add geohash tag only if geohash is provided
                    if (geohash && geohash.trim()) {
                        event.tags.push(['g', geohash]);
                    }
                    
                    // Add NIP-05 verification tag if verified
                    if (nip05Verified) {
                        event.tags.push(['nip05', `${savedUsername}@trustroots.org`]);
                    }

                    console.log('🏷️ Event tags (ephemeral):', event.tags);
                    return event;
                } catch (error) {
                    console.error('Error creating ephemeral event:', error);
                    throw new Error('Failed to create ephemeral event: ' + error.message);
                }
            }

            // New method for persistent events
            async createPersistentEvent(content, geohash, persistence) {
                if (!this.privateKey) {
                    throw new Error('No private key available');
                }

                console.log('createPersistentEvent called with persistence:', persistence);

                try {
                    const expirationHours = {
                        '1h': 1,
                        'short': 24,
                        'medium': 168, // 7 days
                        'long': 720, // 30 days
                        'permanent': null
                    };
                    
                    console.log('expirationHours mapping:', expirationHours);
                    console.log('Looking up persistence in mapping:', persistence, '->', expirationHours[persistence]);
                    
                    // Test the mapping
                    console.log('Test: "short" should map to 24 hours:', expirationHours['short']);
                    console.log('Test: "1h" should map to 1 hour:', expirationHours['1h']);
                    
                    // Get npub for NIP-05 verification
                    const npub = this.deriveNpubFromPrivateKey(this.privateKey);
                    
                    // Check for NIP-05 verification with caching
                    const savedUsername = localStorage.getItem('tripchat_trustroots_username');
                    let nip05Verified = false;
                    
                    if (savedUsername) {
                        // Check cache first
                        const cacheKey = `nip05_${savedUsername}`;
                        const cached = localStorage.getItem(cacheKey);
                        const cacheTime = localStorage.getItem(`${cacheKey}_time`);
                        const now = Date.now();
                        
                        // Use cache if less than 5 minutes old
                        if (cached && cacheTime && (now - parseInt(cacheTime)) < 300000) {
                            nip05Verified = cached === 'true';
                        } else {
                            try {
                                const verificationUrl = `https://trustroots.org/.well-known/nostr.json?name=${savedUsername}`;
                                const response = await fetch(verificationUrl, {
                                    method: 'GET',
                                    headers: {
                                        'Accept': 'application/json',
                                        'Cache-Control': 'no-cache'
                                    }
                                });
                                
                                if (response.ok) {
                                    const data = await response.json();
                                    
                                    if (data.names && data.names[savedUsername]) {
                                        const hexPubkey = data.names[savedUsername];
                                        let expectedNpub;
                                        
                                        if (typeof window.nostrTools !== 'undefined') {
                                            expectedNpub = window.nostrTools.nip19.npubEncode(hexPubkey);
                                        } else {
                                            expectedNpub = this.hexToNpub(hexPubkey);
                                        }
                                        
                                        nip05Verified = (expectedNpub === npub);
                                        
                                        // Cache the result
                                        localStorage.setItem(cacheKey, nip05Verified.toString());
                                        localStorage.setItem(`${cacheKey}_time`, now.toString());
                                    }
                                }
                            } catch (error) {
                                console.log('NIP-05 verification failed:', error);
                                // Use cached result if available, even if expired
                                if (cached) {
                                    nip05Verified = cached === 'true';
                                }
                            }
                        }
                    }
                    
                    // Use nostr-tools if available
                    if (typeof window.nostrTools !== 'undefined') {
                        // Get hex public key from private key
                        const hexPubkey = this.deriveHexPubkeyFromPrivateKey(this.privateKey);
                        
                        const event = {
                            kind: 1, // Standard text notes
                            pubkey: hexPubkey,
                            content: content,
                            tags: [
                                ['p', npub] // Add public key tag
                            ],
                            created_at: Math.floor(Date.now() / 1000)
                        };
                        
                        // Add NIP-10 reply tags if this is a reply
                        if (this.replyContext) {
                            console.log('Adding NIP-10 reply tags:', this.replyContext);
                            // Add 'e' tag for the original event (NIP-10)
                            event.tags.push(['e', this.replyContext.originalNoteId, this.replyContext.originalRelay, 'reply']);
                            // Add 'p' tag for the original author (NIP-10)
                            event.tags.push(['p', this.replyContext.originalNpub]);
                            // Clear reply context after use
                            this.clearReplyContext();
                        }
                        
                        console.log('Creating Kind 1 event:', event);
                        
                        // Add geohash tag only if geohash is provided
                        if (geohash && geohash.trim()) {
                            event.tags.push(['g', geohash]);
                        }
                        
                        // Add expiration if not permanent
                        if (expirationHours[persistence]) {
                            const expiresAt = Math.floor(Date.now() / 1000) + (expirationHours[persistence] * 3600);
                            console.log(`Setting expiration: ${persistence} = ${expirationHours[persistence]} hours, expires_at: ${expiresAt}`);
                            event.tags.push(['expires_at', expiresAt.toString()]);
                            event.tags.push(['expiration', `${expirationHours[persistence]}h`]);
                        } else {
                            console.log(`No expiration set for persistence: ${persistence}`);
                        }
                        
                        // Add NIP-05 verification tag if verified
                        if (nip05Verified) {
                            event.tags.push(['nip05', `${savedUsername}@trustroots.org`]);
                        }
                        
                        // Parse and add hashtags from content as 't' tags
                        const hashtagRegex = /#(\w+)/g;
                        const hashtags = [...content.matchAll(hashtagRegex)];
                        const uniqueHashtags = [...new Set(hashtags.map(match => match[1].toLowerCase()))];
                        
                        uniqueHashtags.forEach(hashtag => {
                            event.tags.push(['t', hashtag]);
                        });
                        
                        if (uniqueHashtags.length > 0) {
                            console.log('Added hashtag tags:', uniqueHashtags);
                        }

                        // Sign the event using nostr-tools
                        const signedEvent = window.nostrTools.finishEvent(event, this.privateKey);
                        return signedEvent;
                    }
                    
                    // Fallback method
                    console.log('nostr-tools not available, using fallback method');
                    const event = {
                        kind: 1, // Standard text notes
                        pubkey: this.generateFakePublicKey(this.privateKey),
                        content: content,
                        tags: [
                            ['p', npub] // Add public key tag
                        ],
                        created_at: Math.floor(Date.now() / 1000),
                        id: this.generateFakeEventId(content, geohash || 'global'),
                        sig: this.generateFakeSignature(this.privateKey, content)
                    };
                    
                    // Add NIP-10 reply tags if this is a reply (fallback)
                    if (this.replyContext) {
                        console.log('Adding NIP-10 reply tags (fallback):', this.replyContext);
                        // Add 'e' tag for the original event (NIP-10)
                        event.tags.push(['e', this.replyContext.originalNoteId, this.replyContext.originalRelay, 'reply']);
                        // Add 'p' tag for the original author (NIP-10)
                        event.tags.push(['p', this.replyContext.originalNpub]);
                        // Clear reply context after use
                        this.clearReplyContext();
                    }
                    
                    console.log('Creating Kind 1 event (fallback):', event);
                    
                    // Add geohash tag only if geohash is provided
                    if (geohash && geohash.trim()) {
                        event.tags.push(['g', geohash]);
                    }
                    
                    // Add expiration if not permanent
                    if (expirationHours[persistence]) {
                        const expiresAt = Math.floor(Date.now() / 1000) + (expirationHours[persistence] * 3600);
                        console.log(`Setting expiration (fallback): ${persistence} = ${expirationHours[persistence]} hours, expires_at: ${expiresAt}`);
                        event.tags.push(['expires_at', expiresAt.toString()]);
                        event.tags.push(['expiration', `${expirationHours[persistence]}h`]);
                    } else {
                        console.log(`No expiration set for persistence (fallback): ${persistence}`);
                    }
                    
                    // Add NIP-05 verification tag if verified
                    if (nip05Verified) {
                        event.tags.push(['nip05', `${savedUsername}@trustroots.org`]);
                    }
                    
                    // Parse and add hashtags from content as 't' tags (fallback)
                    const hashtagRegex = /#(\w+)/g;
                    const hashtags = [...content.matchAll(hashtagRegex)];
                    const uniqueHashtags = [...new Set(hashtags.map(match => match[1].toLowerCase()))];
                    
                    uniqueHashtags.forEach(hashtag => {
                        event.tags.push(['t', hashtag]);
                    });
                    
                    if (uniqueHashtags.length > 0) {
                        console.log('Added hashtag tags (fallback):', uniqueHashtags);
                    }

                    console.log('🏷️ Event tags (persistent):', event.tags);
                    return event;
                } catch (error) {
                    console.error('Error creating persistent event:', error);
                    throw new Error('Failed to create persistent event: ' + error.message);
                }
            }

            // Generate a fake public key from private key
            generateFakePublicKey(privateKeyHex) {
                const hash = this.simpleHash(privateKeyHex);
                return hash.substring(0, 64);
            }

            // Generate a fake event ID
            generateFakeEventId(content, geohash) {
                const input = content + (geohash || 'profile') + Date.now();
                const hash = this.simpleHash(input);
                return hash.substring(0, 64);
            }

            // Generate a fake signature
            generateFakeSignature(privateKeyHex, content) {
                const input = privateKeyHex + content + Date.now();
                const hash = this.simpleHash(input);
                return hash.substring(0, 128); // Longer for signature
            }

            // Create and post kind 0 profile event
            async postProfileToNostr(username, npub) {
                try {
                    // Load private key from localStorage if not already loaded
                    if (!this.privateKey) {
                        const nsecKey = localStorage.getItem('tripchat_nsec');
                        if (!nsecKey) {
                            throw new Error('No private key available for signing');
                        }
                        this.privateKey = nsecKey;
                    }

                    // Create profile content
                    const profileContent = {
                        name: username,
                        about: `Traveler on Trustroots - ${username}`,
                        website: `https://trustroots.org/people/${username}`,
                        nip05: `${username}@trustroots.org`,
                        lud16: `${username}@trustroots.org`,
                        // Trustroots-specific fields
                        trustroots_username: username,
                        trustroots_profile: `https://trustroots.org/people/${username}`,
                        travel_preferences: "Hospitality exchange, hitchhiking, sustainable travel",
                        created_at: new Date().toISOString()
                    };

                    // Use nostr-tools if available
                    if (typeof window.nostrTools !== 'undefined') {
                        // Convert nsec to hex if needed
                        let privateKeyForSigning = this.privateKey;
                        if (this.privateKey.startsWith('nsec')) {
                            privateKeyForSigning = this.nsecToHex(this.privateKey);
                        }
                        const publicKeyHex = this.deriveHexPubkeyFromPrivateKey(privateKeyForSigning);
                        
                        const event = {
                            kind: 0, // Metadata event
                            pubkey: publicKeyHex,
                            content: JSON.stringify(profileContent),
                            tags: [
                                ['nip05', `${username}@trustroots.org`],
                                ['L', 'org.trustroots'],
                                ['l', username, 'org.trustroots']
                            ],
                            created_at: Math.floor(Date.now() / 1000)
                        };

                        const signedEvent = window.nostrTools.finishEvent(event, privateKeyForSigning);
                        signedEvent.pubkey = publicKeyHex;
                        
                        // Ensure event has an ID (fallback if nostr-tools doesn't add it)
                        if (!signedEvent.id) {
                            console.log('⚠️ Event missing ID, generating fallback ID');
                            signedEvent.id = this.generateFakeEventId(JSON.stringify(event), 'profile');
                        }
                        
                        console.log('🧾 Prepared profile event (nostr-tools path):', signedEvent);
                        console.log('🔍 Event ID check:', { hasId: 'id' in signedEvent, id: signedEvent.id, idType: typeof signedEvent.id });
                        
                        // Store event ID for comparison
                        const eventId = signedEvent.id;
                        console.log('💾 Stored event ID for comparison:', eventId);
                        
                        // Post to all enabled relays
                        const postingRelays = Object.keys(this.postingRelays).filter(url => this.postingRelays[url]);
                        console.log('📨 Posting profile to relays:', postingRelays);
                        
                        // Check WebSocket connection status for each relay
                        postingRelays.forEach(relayUrl => {
                            const ws = this.websockets[relayUrl];
                            console.log(`🔌 WebSocket status for ${relayUrl}:`, {
                                exists: !!ws,
                                readyState: ws?.readyState,
                                stateName: ws ? ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'][ws.readyState] : 'undefined'
                            });
                        });
                        
                        const postPromises = postingRelays.map(relayUrl => {
                            console.log(`📤 About to post event with ID: ${eventId} to ${relayUrl}`);
                            // Create a copy of the event to avoid reference issues
                            const eventCopy = { ...signedEvent };
                            return this.postEventToRelay(relayUrl, eventCopy, eventId);
                        });
                        
                        const results = await Promise.allSettled(postPromises);
                        const successful = results.filter(r => r.status === 'fulfilled' && r.value === true).length;
                        
                        console.log(`📊 Profile posting results (nostr-tools):`, results);
                        console.log(`✅ Profile posted to ${successful}/${postingRelays.length} relays`);
                        
                        // Log details for each relay attempt
                        results.forEach((result, index) => {
                            const relayUrl = postingRelays[index];
                            if (result.status === 'fulfilled') {
                                console.log(`✅ ${relayUrl}: Success`);
                            } else {
                                console.log(`❌ ${relayUrl}: ${result.reason?.message || 'Unknown error'}`);
                            }
                        });
                        
                        return successful > 0;
                    } else {
                        // Fallback method
                        console.log('nostr-tools not available, using fallback profile creation');
                        
                        // Convert nsec to hex if needed for fallback methods
                        let privateKeyForFallback = this.privateKey;
                        if (this.privateKey.startsWith('nsec')) {
                            privateKeyForFallback = this.nsecToHex(this.privateKey);
                        }
                        const publicKeyHex = this.deriveHexPubkeyFromPrivateKey(privateKeyForFallback);
                        
                        const event = {
                            kind: 0,
                            content: JSON.stringify(profileContent),
                            tags: [
                                ['nip05', `${username}@trustroots.org`],
                                ['L', 'org.trustroots'],
                                ['l', username, 'org.trustroots']
                            ],
                            pubkey: publicKeyHex,
                            created_at: Math.floor(Date.now() / 1000),
                            id: this.generateFakeEventId(JSON.stringify(profileContent), 'profile'),
                            sig: this.generateFakeSignature(privateKeyForFallback, JSON.stringify(profileContent))
                        };
                        console.log('🧾 Prepared profile event (fallback path):', event);
                        
                        // Post to all enabled relays
                        const postingRelays = Object.keys(this.postingRelays).filter(url => this.postingRelays[url]);
                        console.log('📨 Posting profile to relays (fallback):', postingRelays);
                        const postPromises = postingRelays.map(relayUrl => this.postEventToRelay(relayUrl, event));
                        
                        const results = await Promise.allSettled(postPromises);
                        const successful = results.filter(r => r.status === 'fulfilled' && r.value === true).length;
                        
                        console.log(`📊 Profile posting results (fallback):`, results);
                        console.log(`✅ Profile posted to ${successful}/${postingRelays.length} relays`);
                        
                        // Log details for each relay attempt
                        results.forEach((result, index) => {
                            const relayUrl = postingRelays[index];
                            if (result.status === 'fulfilled') {
                                console.log(`✅ ${relayUrl}: Success`);
                            } else {
                                console.log(`❌ ${relayUrl}: ${result.reason?.message || 'Unknown error'}`);
                            }
                        });
                        
                        return successful > 0;
                    }
                } catch (error) {
                    console.error('Error posting profile to Nostr:', error);
                    return false;
                }
            }

            // Post event to a specific relay
            async postEventToRelay(relayUrl, event, expectedEventId = null) {
                return new Promise((resolve, reject) => {
                    console.log(`🔗 Attempting to post to relay: ${relayUrl}`);
                    console.log(`📊 WebSocket state:`, this.websockets[relayUrl] ? this.websockets[relayUrl].readyState : 'undefined');
                    console.log(`🆔 Event ID in postEventToRelay:`, event.id, typeof event.id);
                    console.log(`🎯 Expected event ID:`, expectedEventId, typeof expectedEventId);
                    
                    if (!this.websockets[relayUrl] || this.websockets[relayUrl].readyState !== WebSocket.OPEN) {
                        console.log(`❌ Relay ${relayUrl} not connected (state: ${this.websockets[relayUrl]?.readyState})`);
                        reject(new Error(`Relay ${relayUrl} not connected`));
                        return;
                    }

                    const message = JSON.stringify(["EVENT", event]);
                    console.log(`📤 Sending message to ${relayUrl}:`, message.substring(0, 200) + '...');
                    
                    const handleMessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            console.log(`📥 Received response from ${relayUrl}:`, data);
                            
                            if (Array.isArray(data) && data.length >= 2) {
                                const [messageType, eventId, success, message] = data;
                                
                                if (messageType === 'OK') {
                                    const expectedId = expectedEventId || event.id;
                                    console.log(`🔍 OK response from ${relayUrl}: eventId="${eventId}", expected="${expectedId}", match=${eventId === expectedId}`);
                                    if (eventId === expectedId) {
                                        console.log(`✅ OK response for event ${eventId} from ${relayUrl}: success=${success}, message="${message}"`);
                                        this.websockets[relayUrl].removeEventListener('message', handleMessage);
                                        if (success) {
                                            console.log(`🎉 Successfully posted to ${relayUrl}`);
                                            resolve(true);
                                        } else {
                                            console.log(`❌ Event rejected by ${relayUrl}: ${message}`);
                                            reject(new Error(message || 'Event rejected by relay'));
                                        }
                                        return; // Important: return early to prevent further processing
                                    }
                                }
                            }
                        } catch (error) {
                            console.log(`⚠️ Error parsing message from ${relayUrl}:`, error.message);
                            // Ignore parsing errors for other messages
                        }
                    };

                    this.websockets[relayUrl].addEventListener('message', handleMessage);
                    this.websockets[relayUrl].send(message);
                    console.log(`📡 Message sent to ${relayUrl}, waiting for response...`);

                    // Timeout after 5 seconds for faster feedback
                    setTimeout(() => {
                        console.log(`⏰ Timeout posting to ${relayUrl} after 5 seconds`);
                        this.websockets[relayUrl].removeEventListener('message', handleMessage);
                        reject(new Error('Timeout posting to relay'));
                    }, 5000);
                });
            }

            async publishEvent(event) {
                const postingRelays = this.relays.filter(relay => this.postingRelays[relay]);
                
                if (postingRelays.length === 0) {
                    console.error('❌ No posting relays available');
                    throw new Error('No posting relays available');
                }

                const publishPromises = postingRelays.map(relayUrl => {
                    return new Promise((resolve, reject) => {
                        if (!this.websockets[relayUrl] || this.websockets[relayUrl].readyState !== WebSocket.OPEN) {
                            console.error(`❌ Relay ${relayUrl} is not connected (state: ${this.websockets[relayUrl]?.readyState})`);
                            reject(new Error(`Relay ${relayUrl} is not connected`));
                            return;
                        }

                        const message = ["EVENT", event];
                        
                        try {
                            this.websockets[relayUrl].send(JSON.stringify(message));
                            resolve();
                        } catch (error) {
                            console.error(`❌ Failed to publish to ${relayUrl}:`, error);
                            reject(error);
                        }
                    });
                });

                const results = await Promise.allSettled(publishPromises);
                
                const successful = results.filter(r => r.status === 'fulfilled').length;
                const failed = results.filter(r => r.status === 'rejected').length;
                
                if (failed > 0) {
                    console.warn(`⚠️ ${failed} relay(s) failed to publish event`);
                    results.forEach((result, index) => {
                        if (result.status === 'rejected') {
                            console.error(`❌ ${postingRelays[index]}: ${result.reason}`);
                        }
                    });
                }
            }

            // Relay management functionality
            addRelay(url) {
                if (!this.relays.includes(url)) {
                    this.relays.push(url);
                    this.relayEnabled[url] = true;
                    this.postingRelays[url] = false; // New relays disabled for posting by default
                    this.relayStatus[url] = {
                        status: 'disconnected',
                        notesCount: 0,
                        lastSeen: null,
                        connectionTime: null
                    };
                    
                    // Save settings to localStorage
                    this.saveRelaySettings();
                    
                    // Connect to the new relay
                    this.connectToRelay(url);
                    console.log(`Added new relay: ${url}`);
                }
            }

            removeRelay(url) {
                const index = this.relays.indexOf(url);
                if (index > -1) {
                    this.relays.splice(index, 1);
                    delete this.relayEnabled[url];
                    delete this.postingRelays[url];
                    delete this.relayStatus[url];
                    
                    // Close WebSocket connection
                    if (this.websockets[url]) {
                        this.websockets[url].close();
                        delete this.websockets[url];
                    }
                    
                    // Save settings to localStorage
                    this.saveRelaySettings();
                    
                    // Update the relay list display
                    this.updateRelayList();
                    
                    console.log(`Removed relay: ${url}`);
                }
            }

            togglePostingRelay(url) {
                this.postingRelays[url] = !this.postingRelays[url];
                // Save settings to localStorage
                this.saveRelaySettings();
                // Update the display if compose modal is open
                this.updatePostingRelaysDisplay();
            }

            updatePostingRelaysDisplay() {
                const display = document.getElementById('postingRelaysDisplay');
                if (!display) return;

                const postingRelays = this.relays.filter(relay => this.postingRelays[relay]);
                
                if (postingRelays.length === 0) {
                    display.innerHTML = '<div class="posting-relay-item" style="background: #f8d7da; border-color: #dc3545; color: #dc3545;">⚠️ No posting relays enabled</div>';
                    return;
                }

                display.innerHTML = postingRelays.map(relayUrl => {
                    const relayName = relayUrl.replace('wss://', '').replace('.org', '').replace('.io', '').replace('.lol', '').replace('.social', '');
                    const status = this.relayStatus[relayUrl]?.status || 'disconnected';
                    const statusClass = status === 'connected' ? 'relay-connected' : 'relay-disconnected';
                    
                    return `
                        <div class="posting-relay-item">
                            <div class="relay-status-dot ${statusClass}"></div>
                            <span class="relay-name">${relayName}</span>
                        </div>
                    `;
                }).join('');
            }


            updateRelayList() {
                const relayList = document.getElementById('relayList');
                relayList.innerHTML = '';

                this.relays.forEach(relayUrl => {
                    const relayItem = document.createElement('div');
                    relayItem.className = 'relay-item-manager';
                    
                    const status = this.relayStatus[relayUrl]?.status || 'disconnected';
                    const isEnabled = this.relayEnabled[relayUrl];
                    const isPostingEnabled = this.postingRelays[relayUrl];
                    
                    relayItem.innerHTML = `
                        <div class="relay-info">
                            <div class="relay-status-dot relay-${status}"></div>
                            <div class="relay-url">${relayUrl}</div>
                        </div>
                        <div class="relay-controls">
                            <label class="post-toggle-label">
                                <input type="checkbox" ${isPostingEnabled ? 'checked' : ''} 
                                       onchange="window.tripchatVisualizer.togglePostingRelay('${relayUrl}')">
                                <span class="post-toggle-slider">
                                    <span class="post-toggle-text">Post</span>
                                </span>
                            </label>
                            <button class="relay-delete" data-relay-url="${relayUrl}">
                                DELETE
                            </button>
                        </div>
                    `;
                    
                    relayList.appendChild(relayItem);
                });

                // Add event listeners for delete buttons
                this.setupRelayDeleteHandlers();
            }

            setupRelayDeleteHandlers() {
                document.querySelectorAll('.relay-delete').forEach(button => {
                    button.addEventListener('click', (e) => {
                        const relayUrl = e.target.dataset.relayUrl;
                        if (relayUrl) {
                            this.removeRelay(relayUrl);
                        }
                    });
                });
            }

            showNoteDetailsModal(note) {
                // Create modal overlay
                const modalOverlay = document.createElement('div');
                modalOverlay.className = 'modal-overlay';
                modalOverlay.onclick = (e) => {
                    if (e.target === modalOverlay) {
                        document.body.removeChild(modalOverlay);
                    }
                };

                // Get user profile
                const profile = this.userProfiles[note.pubkey];
                const username = this.formatUsernameWithDiscriminator(profile, note.pubkey);
                

                // Format timestamp
                const timestamp = new Date(note.created_at * 1000);
                const timeString = timestamp.toLocaleString('en-CA', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: false
                });

                // Extract geohash tags
                const geohashTags = [];
                if (note.tags) {
                    note.tags.forEach(tag => {
                        if (tag[0] === 'g' && tag[1]) {
                            geohashTags.push(tag[1]);
                        }
                    });
                }

                // Create modal content
                const modalContent = document.createElement('div');
                modalContent.className = 'modal-content';
                modalContent.innerHTML = `
                    <div class="modal-header">
                        <h2 class="modal-title">Nostr Note Details</h2>
                        <div style="display: flex; gap: 8px; align-items: center;">
                            <button class="modal-copy-btn" onclick="window.tripchatVisualizer.copyNoteData('${note.id}')" title="Copy note data">📋 Copy</button>
                            <button class="modal-close" onclick="document.body.removeChild(this.closest('.modal-overlay'))">&times;</button>
                        </div>
                    </div>
                    
                    <div class="modal-section">
                        <div class="modal-section-title">Content</div>
                        <div class="modal-content-text">${this.processContent(this.escapeHtml(note.content || 'No content'))}</div>
                    </div>
                    
                    <div class="modal-section">
                        <div class="modal-section-title">Author</div>
                        <div class="modal-field">
                            <div class="modal-field-label">Username</div>
                            <div class="modal-field-value">@${username}</div>
                        </div>
                        <div class="modal-field">
                            <div class="modal-field-label">Public Key (npub)</div>
                            <div class="modal-field-value">${note.pubkey ? this.hexToNpub(note.pubkey) : 'Unknown'}</div>
                        </div>
                    </div>
                    
                    <div class="modal-section">
                        <div class="modal-section-title">Event Details</div>
                        <div class="modal-field">
                            <div class="modal-field-label">Event ID</div>
                            <div class="modal-field-value">${note.id || 'Unknown'}</div>
                        </div>
                        <div class="modal-field">
                            <div class="modal-field-label">Kind</div>
                            <div class="modal-field-value">${note.kind || 'Unknown'}</div>
                        </div>
                        <div class="modal-field">
                            <div class="modal-field-label">Created At</div>
                            <div class="modal-field-value">${timeString}</div>
                        </div>
                    </div>
                    
                    ${geohashTags.length > 0 ? `
                    <div class="modal-section">
                        <div class="modal-section-title">Location Tags</div>
                        <div class="modal-tags">
                            ${geohashTags.map(geohash => `<span class="modal-tag">📍 ${geohash}</span>`).join('')}
                        </div>
                    </div>
                    ` : ''}
                    
                    ${note.tags && note.tags.length > 0 ? `
                    <div class="modal-section">
                        <div class="modal-section-title">All Tags</div>
                        <div class="modal-field">
                            <div class="modal-field-value">${JSON.stringify(note.tags, null, 2)}</div>
                        </div>
                    </div>
                    ` : ''}
                    
                    <div class="modal-section">
                        <div class="modal-section-title">Raw Nostr Event Data</div>
                        <div class="modal-field">
                            <div class="modal-field-value">
                                <pre style="background: var(--bg-tertiary); padding: 12px; border-radius: 4px; overflow-x: auto; font-size: 0.8rem; font-family: 'JetBrains Mono', 'Fira Code', monospace;">${JSON.stringify(note, null, 2)}</pre>
                            </div>
                        </div>
                    </div>
                `;

                modalOverlay.appendChild(modalContent);
                document.body.appendChild(modalOverlay);
                
                // Add ESC key handling to close modal
                const handleEscKey = (e) => {
                    if (e.key === 'Escape' && document.body.contains(modalOverlay)) {
                        document.body.removeChild(modalOverlay);
                        document.removeEventListener('keydown', handleEscKey);
                    }
                };
                document.addEventListener('keydown', handleEscKey);
                
                // Set up hashtag click handlers for the modal content
                this.setupHashtagClickHandlers();
            }

            copyNoteData(noteId) {
                // Find the note by ID
                const note = this.notes.find(n => n.id === noteId);
                if (!note) {
                    alert('Note not found');
                    return;
                }

                // Copy the complete raw note data as JSON
                const rawNoteData = JSON.stringify(note, null, 2);
                
                // Copy to clipboard
                navigator.clipboard.writeText(rawNoteData).then(() => {
                    // Show success feedback
                    const copyBtn = document.querySelector('.modal-copy-btn');
                    if (copyBtn) {
                        const originalText = copyBtn.textContent;
                        copyBtn.textContent = '✅ Copied!';
                        copyBtn.style.background = '#27ae60';
                        setTimeout(() => {
                            copyBtn.textContent = originalText;
                            copyBtn.style.background = '#3498db';
                        }, 2000);
                    }
                }).catch(err => {
                    console.error('Failed to copy: ', err);
                    alert('Failed to copy to clipboard');
                });
            }

            displayError(message) {
                const noteContainer = document.getElementById('noteContainer');
                noteContainer.innerHTML = `<div class="error">${message}</div>`;
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            sanitizeHtml(text) {
                // Use DOMPurify to sanitize HTML content
                if (typeof DOMPurify !== 'undefined') {
                    return DOMPurify.sanitize(text, {
                        ALLOWED_TAGS: ['a', 'strong', 'em', 'u', 'br', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p', 'ul', 'ol', 'li', 'blockquote', 'code', 'del'],
                        ALLOWED_ATTR: ['href', 'target', 'rel', 'class', 'data-hashtag', 'data-circle'],
                        ALLOW_DATA_ATTR: true
                    });
                } else {
                    // Fallback to basic HTML escaping if DOMPurify is not available
                    const div = document.createElement('div');
                    div.textContent = text;
                    return div.innerHTML;
                }
            }

            initializeRelayStatus() {
                this.relays.forEach(relayUrl => {
                    this.relayStatus[relayUrl] = {
                        status: 'disconnected',
                        notesCount: 0,
                        lastSeen: null,
                        connectionTime: null
                    };
                    this.relayEnabled[relayUrl] = true; // All relays enabled for reading by default
                    
                    // Only hitchwiki, trustroots, and nomadwiki enabled for posting by default
                    this.postingRelays[relayUrl] = relayUrl.includes('hitchwiki.org') || relayUrl.includes('trustroots.org') || relayUrl.includes('nomadwiki.org');
                });
                
                // Load saved relay settings from localStorage
                this.loadRelaySettings();
            }

            // Save relay settings to localStorage
            saveRelaySettings() {
                try {
                    const settings = {
                        relays: this.relays,
                        postingRelays: this.postingRelays,
                        relayEnabled: this.relayEnabled
                    };
                    localStorage.setItem('tripchat_relay_settings', JSON.stringify(settings));
                    console.log('Relay settings saved to localStorage');
                } catch (error) {
                    console.error('Failed to save relay settings to localStorage:', error);
                }
            }

            // Load relay settings from localStorage
            loadRelaySettings() {
                try {
                    const saved = localStorage.getItem('tripchat_relay_settings');
                    if (saved) {
                        const settings = JSON.parse(saved);
                        
                        // Restore relay list if available
                        if (settings.relays && Array.isArray(settings.relays)) {
                            this.relays = settings.relays;
                        }
                        
                        // Restore posting relay settings
                        if (settings.postingRelays) {
                            Object.keys(settings.postingRelays).forEach(relayUrl => {
                                if (this.postingRelays.hasOwnProperty(relayUrl)) {
                                    this.postingRelays[relayUrl] = settings.postingRelays[relayUrl];
                                }
                            });
                        }
                        
                        // Restore relay enabled settings
                        if (settings.relayEnabled) {
                            Object.keys(settings.relayEnabled).forEach(relayUrl => {
                                if (this.relayEnabled.hasOwnProperty(relayUrl)) {
                                    this.relayEnabled[relayUrl] = settings.relayEnabled[relayUrl];
                                }
                            });
                        }
                        
                        console.log('Relay settings loaded from localStorage');
                    }
                } catch (error) {
                    console.error('Failed to load relay settings from localStorage:', error);
                }
            }

            updateRelayStatus(relayUrl, status, notesCount = null) {
                if (this.relayStatus[relayUrl]) {
                    this.relayStatus[relayUrl].status = status;
                    this.relayStatus[relayUrl].lastSeen = new Date();
                    
                    if (status === 'connected' && !this.relayStatus[relayUrl].connectionTime) {
                        this.relayStatus[relayUrl].connectionTime = new Date();
                        console.log(`Set connection time for ${relayUrl}:`, this.relayStatus[relayUrl].connectionTime);
                    }
                    
                    if (notesCount !== null) {
                        this.relayStatus[relayUrl].notesCount = notesCount;
                    }
                }
            }
        }

        // Initialize the app when the page loads
        window.tripchatVisualizer = new TRipchatVisualizer();
        
        // Update last modified time
        function updateLastModified() {
            const lastModifiedElement = document.getElementById('lastModified');
            if (lastModifiedElement) {
                const lastModified = new Date(document.lastModified);
                const year = lastModified.getFullYear().toString();
                const month = (lastModified.getMonth() + 1).toString().padStart(2, '0');
                const day = lastModified.getDate().toString().padStart(2, '0');
                const hours = lastModified.getHours().toString().padStart(2, '0');
                const minutes = lastModified.getMinutes().toString().padStart(2, '0');
                const timeString = `${year}-${month}-${day} ${hours}:${minutes}`;
                lastModifiedElement.textContent = timeString;
            }
        }
        updateLastModified();
    </script>

    <!-- GitHub link with last modified time -->
    <div class="app-footer">
        <a href="https://github.com/guaka/TRipchat" target="_blank" rel="noopener noreferrer" id="githubLink">Updated: <span id="lastModified"></span></a>
    </div>
</body>
</html>
